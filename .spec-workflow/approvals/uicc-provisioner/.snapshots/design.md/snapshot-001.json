{
  "id": "snapshot_1764070796727_0peo22y7n",
  "approvalId": "approval_1764070796706_lrfclzu6z",
  "approvalTitle": "UICC Provisioner Design Document",
  "version": 1,
  "timestamp": "2025-11-25T11:39:56.727Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: UICC Provisioner\n\n## Introduction\n\nThis document describes the technical design for the UICC Provisioner component of CardLink. The provisioner enables PC/SC-based smart card access to configure UICC cards for SCP81 OTA testing, including PSK keys, admin URLs, triggers, and BIP settings.\n\n## System Architecture\n\n### High-Level Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                              CLI Layer                                       │\n│                         (cardlink-provision)                                 │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                          Provisioner Core                                    │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │\n│  │ProfileManager│  │ APDULogger │  │EventEmitter │  │ KeyManager  │        │\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘        │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                         Card Operations Layer                                │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │\n│  │  PSKConfig  │  │  URLConfig  │  │TriggerConfig│  │  BIPConfig  │        │\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘        │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                       Security Domain Layer                                  │\n│  ┌─────────────────────────────────────────────────────────────────┐        │\n│  │                    SecureDomainManager                          │        │\n│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐    │        │\n│  │  │  SCP02    │  │  SCP03    │  │  PINAuth  │  │  ADMAuth  │    │        │\n│  │  └───────────┘  └───────────┘  └───────────┘  └───────────┘    │        │\n│  └─────────────────────────────────────────────────────────────────┘        │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                           APDU Layer                                         │\n│  ┌─────────────────────────────────────────────────────────────────┐        │\n│  │                      APDUInterface                               │        │\n│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐    │        │\n│  │  │ TLVParser │  │SWDecoder  │  │APDUBuilder│  │ Scripting │    │        │\n│  │  └───────────┘  └───────────┘  └───────────┘  └───────────┘    │        │\n│  └─────────────────────────────────────────────────────────────────┘        │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                          PC/SC Layer                                         │\n│  ┌─────────────────────────────────────────────────────────────────┐        │\n│  │                       PCSCClient                                 │        │\n│  │  ┌───────────┐  ┌───────────┐  ┌───────────┐  ┌───────────┐    │        │\n│  │  │ReaderMgr  │  │ CardConn  │  │ATRParser  │  │ProtocolMgr│    │        │\n│  │  └───────────┘  └───────────┘  └───────────┘  └───────────┘    │        │\n│  └─────────────────────────────────────────────────────────────────┘        │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                        pyscard Library                                       │\n│                    (smartcard.System, etc.)                                  │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### Component Descriptions\n\n| Component | Responsibility |\n|-----------|----------------|\n| **PCSCClient** | PC/SC reader management, card connection, low-level transmit |\n| **APDUInterface** | APDU construction, transmission, response parsing |\n| **SecureDomainManager** | Security Domain selection, secure channel establishment |\n| **SCP02/SCP03** | Secure channel protocol implementations |\n| **PSKConfig** | PSK identity and key provisioning |\n| **URLConfig** | Admin server URL configuration |\n| **TriggerConfig** | OTA trigger mechanism configuration |\n| **BIPConfig** | BIP/CAT settings configuration |\n| **ProfileManager** | Card profile save/load/apply operations |\n| **KeyManager** | Cryptographic key handling and secure storage |\n| **EventEmitter** | Event publication for external integration |\n\n## Component Design\n\n### 1. PCSCClient\n\nManages PC/SC reader discovery and card communication.\n\n```python\nfrom smartcard.System import readers\nfrom smartcard.CardConnection import CardConnection\nfrom smartcard.CardMonitoring import CardMonitor, CardObserver\nfrom typing import Optional, List, Callable\nfrom dataclasses import dataclass\nimport threading\n\n@dataclass\nclass ReaderInfo:\n    name: str\n    index: int\n    has_card: bool\n    atr: Optional[bytes] = None\n\n@dataclass\nclass CardInfo:\n    atr: bytes\n    protocol: int  # T=0 or T=1\n    reader_name: str\n    historical_bytes: bytes\n\nclass PCSCClient:\n    \"\"\"PC/SC reader and card management.\"\"\"\n\n    def __init__(self, event_emitter: Optional['EventEmitter'] = None):\n        self._context = None\n        self._connection: Optional[CardConnection] = None\n        self._current_reader: Optional[str] = None\n        self._event_emitter = event_emitter\n        self._card_monitor: Optional[CardMonitor] = None\n        self._lock = threading.Lock()\n\n    def list_readers(self) -> List[ReaderInfo]:\n        \"\"\"List all available PC/SC readers.\"\"\"\n        reader_list = readers()\n        result = []\n        for idx, reader in enumerate(reader_list):\n            info = ReaderInfo(\n                name=str(reader),\n                index=idx,\n                has_card=self._check_card_present(reader)\n            )\n            if info.has_card:\n                info.atr = self._get_atr(reader)\n            result.append(info)\n        return result\n\n    def connect(self, reader_name: str, protocol: int = None) -> CardInfo:\n        \"\"\"Connect to card in specified reader.\"\"\"\n        reader_list = readers()\n        target_reader = None\n        for reader in reader_list:\n            if str(reader) == reader_name or reader_name in str(reader):\n                target_reader = reader\n                break\n\n        if not target_reader:\n            raise ReaderNotFoundError(f\"Reader not found: {reader_name}\")\n\n        connection = target_reader.createConnection()\n        if protocol:\n            connection.connect(protocol)\n        else:\n            connection.connect()\n\n        self._connection = connection\n        self._current_reader = str(target_reader)\n\n        atr = bytes(connection.getATR())\n        card_info = CardInfo(\n            atr=atr,\n            protocol=connection.getProtocol(),\n            reader_name=self._current_reader,\n            historical_bytes=self._extract_historical_bytes(atr)\n        )\n\n        if self._event_emitter:\n            self._event_emitter.emit('card_connected', card_info)\n\n        return card_info\n\n    def disconnect(self) -> None:\n        \"\"\"Disconnect from current card.\"\"\"\n        if self._connection:\n            self._connection.disconnect()\n            self._connection = None\n            if self._event_emitter:\n                self._event_emitter.emit('card_disconnected', {\n                    'reader': self._current_reader\n                })\n\n    def transmit(self, apdu: bytes) -> tuple[bytes, int, int]:\n        \"\"\"Transmit APDU and return (data, SW1, SW2).\"\"\"\n        if not self._connection:\n            raise NotConnectedError(\"No card connection\")\n\n        with self._lock:\n            response, sw1, sw2 = self._connection.transmit(list(apdu))\n\n            # Handle GET RESPONSE for T=0\n            if sw1 == 0x61:\n                get_response = [0x00, 0xC0, 0x00, 0x00, sw2]\n                response, sw1, sw2 = self._connection.transmit(get_response)\n\n            return bytes(response), sw1, sw2\n\n    def start_monitoring(self,\n                         on_insert: Callable[[str, bytes], None],\n                         on_remove: Callable[[str], None]) -> None:\n        \"\"\"Start monitoring for card insertion/removal.\"\"\"\n        class Observer(CardObserver):\n            def __init__(self, insert_cb, remove_cb):\n                self._insert_cb = insert_cb\n                self._remove_cb = remove_cb\n\n            def update(self, observable, actions):\n                added, removed = actions\n                for card in added:\n                    self._insert_cb(str(card.reader), bytes(card.atr))\n                for card in removed:\n                    self._remove_cb(str(card.reader))\n\n        self._card_monitor = CardMonitor()\n        self._card_monitor.addObserver(Observer(on_insert, on_remove))\n\n    def stop_monitoring(self) -> None:\n        \"\"\"Stop card monitoring.\"\"\"\n        if self._card_monitor:\n            self._card_monitor.deleteObservers()\n            self._card_monitor = None\n\n    def _check_card_present(self, reader) -> bool:\n        \"\"\"Check if card is present in reader.\"\"\"\n        try:\n            conn = reader.createConnection()\n            conn.connect()\n            conn.disconnect()\n            return True\n        except:\n            return False\n\n    def _get_atr(self, reader) -> Optional[bytes]:\n        \"\"\"Get ATR from card in reader.\"\"\"\n        try:\n            conn = reader.createConnection()\n            conn.connect()\n            atr = bytes(conn.getATR())\n            conn.disconnect()\n            return atr\n        except:\n            return None\n\n    def _extract_historical_bytes(self, atr: bytes) -> bytes:\n        \"\"\"Extract historical bytes from ATR.\"\"\"\n        if len(atr) < 2:\n            return b''\n        # T0 byte contains number of historical bytes in lower nibble\n        t0 = atr[1]\n        num_historical = t0 & 0x0F\n        # Historical bytes are at the end before TCK (if present)\n        return atr[-(num_historical + 1):-1] if num_historical > 0 else b''\n\n\nclass ATRParser:\n    \"\"\"Parse and interpret ATR (Answer To Reset).\"\"\"\n\n    @staticmethod\n    def parse(atr: bytes) -> dict:\n        \"\"\"Parse ATR into structured data.\"\"\"\n        result = {\n            'raw': atr.hex().upper(),\n            'ts': atr[0] if len(atr) > 0 else None,\n            't0': atr[1] if len(atr) > 1 else None,\n            'protocols': [],\n            'historical_bytes': b'',\n            'card_type': 'Unknown'\n        }\n\n        if result['ts'] == 0x3B:\n            result['convention'] = 'Direct'\n        elif result['ts'] == 0x3F:\n            result['convention'] = 'Inverse'\n\n        # Determine supported protocols\n        if result['t0']:\n            t0 = result['t0']\n            if t0 & 0x80:  # TA1 present\n                result['protocols'].append('T=0')\n            # Further protocol detection from TD bytes...\n\n        # Identify card type from historical bytes\n        result['card_type'] = ATRParser._identify_card_type(atr)\n\n        return result\n\n    @staticmethod\n    def _identify_card_type(atr: bytes) -> str:\n        \"\"\"Identify card type from ATR patterns.\"\"\"\n        atr_hex = atr.hex().upper()\n\n        # Common UICC/SIM patterns\n        if '80318065' in atr_hex:\n            return 'UICC (3GPP)'\n        if '8031A065' in atr_hex:\n            return 'USIM'\n        if 'A000000087' in atr_hex:\n            return 'eUICC'\n\n        return 'Smart Card'\n```\n\n### 2. APDUInterface\n\nHandles APDU construction, transmission, and response parsing.\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Optional, List, Dict\nfrom enum import IntEnum\n\nclass INS(IntEnum):\n    \"\"\"Common instruction bytes.\"\"\"\n    SELECT = 0xA4\n    READ_BINARY = 0xB0\n    UPDATE_BINARY = 0xD6\n    READ_RECORD = 0xB2\n    UPDATE_RECORD = 0xDC\n    GET_RESPONSE = 0xC0\n    VERIFY = 0x20\n    GET_STATUS = 0xF2\n    INSTALL = 0xE6\n    DELETE = 0xE4\n    PUT_KEY = 0xD8\n    SET_STATUS = 0xF0\n    INITIALIZE_UPDATE = 0x50\n    EXTERNAL_AUTHENTICATE = 0x82\n\n@dataclass\nclass APDUCommand:\n    \"\"\"APDU command structure.\"\"\"\n    cla: int\n    ins: int\n    p1: int\n    p2: int\n    data: bytes = b''\n    le: Optional[int] = None\n\n    def to_bytes(self) -> bytes:\n        \"\"\"Convert to byte array for transmission.\"\"\"\n        cmd = bytes([self.cla, self.ins, self.p1, self.p2])\n\n        if self.data:\n            cmd += bytes([len(self.data)]) + self.data\n\n        if self.le is not None:\n            cmd += bytes([self.le])\n\n        return cmd\n\n@dataclass\nclass APDUResponse:\n    \"\"\"APDU response structure.\"\"\"\n    data: bytes\n    sw1: int\n    sw2: int\n\n    @property\n    def sw(self) -> int:\n        \"\"\"Combined status word.\"\"\"\n        return (self.sw1 << 8) | self.sw2\n\n    @property\n    def is_success(self) -> bool:\n        \"\"\"Check if response indicates success.\"\"\"\n        return self.sw1 == 0x90 and self.sw2 == 0x00\n\n    @property\n    def status_message(self) -> str:\n        \"\"\"Human-readable status message.\"\"\"\n        return SWDecoder.decode(self.sw1, self.sw2)\n\n\nclass SWDecoder:\n    \"\"\"Decode status words to human-readable messages.\"\"\"\n\n    STATUS_WORDS = {\n        0x9000: \"Success\",\n        0x6283: \"Selected file invalidated\",\n        0x6300: \"Verification failed\",\n        0x63C0: \"Verification failed, 0 retries left\",\n        0x63C1: \"Verification failed, 1 retry left\",\n        0x63C2: \"Verification failed, 2 retries left\",\n        0x63C3: \"Verification failed, 3 retries left\",\n        0x6581: \"Memory failure\",\n        0x6700: \"Wrong length\",\n        0x6882: \"Secure messaging not supported\",\n        0x6982: \"Security status not satisfied\",\n        0x6983: \"Authentication method blocked\",\n        0x6984: \"Referenced data invalidated\",\n        0x6985: \"Conditions of use not satisfied\",\n        0x6986: \"Command not allowed\",\n        0x6A80: \"Incorrect parameters in data field\",\n        0x6A81: \"Function not supported\",\n        0x6A82: \"File or application not found\",\n        0x6A83: \"Record not found\",\n        0x6A84: \"Not enough memory space\",\n        0x6A86: \"Incorrect P1-P2\",\n        0x6A88: \"Referenced data not found\",\n        0x6B00: \"Wrong parameters P1-P2\",\n        0x6D00: \"Instruction not supported\",\n        0x6E00: \"Class not supported\",\n        0x6F00: \"No precise diagnosis\",\n    }\n\n    @classmethod\n    def decode(cls, sw1: int, sw2: int) -> str:\n        \"\"\"Decode SW1 SW2 to message.\"\"\"\n        sw = (sw1 << 8) | sw2\n\n        if sw in cls.STATUS_WORDS:\n            return cls.STATUS_WORDS[sw]\n\n        # Handle ranges\n        if sw1 == 0x61:\n            return f\"Response available: {sw2} bytes\"\n        if sw1 == 0x6C:\n            return f\"Wrong Le field, expected {sw2}\"\n        if sw1 == 0x63 and (sw2 & 0xF0) == 0xC0:\n            return f\"Verification failed, {sw2 & 0x0F} retries left\"\n\n        return f\"Unknown status: {sw1:02X}{sw2:02X}\"\n\n\nclass APDUInterface:\n    \"\"\"High-level APDU interface.\"\"\"\n\n    def __init__(self, pcsc_client: PCSCClient,\n                 logger: Optional['APDULogger'] = None,\n                 event_emitter: Optional['EventEmitter'] = None):\n        self._client = pcsc_client\n        self._logger = logger\n        self._event_emitter = event_emitter\n\n    def send(self, command: APDUCommand) -> APDUResponse:\n        \"\"\"Send APDU command and get response.\"\"\"\n        cmd_bytes = command.to_bytes()\n\n        if self._logger:\n            self._logger.log_command(cmd_bytes)\n\n        data, sw1, sw2 = self._client.transmit(cmd_bytes)\n\n        response = APDUResponse(data=data, sw1=sw1, sw2=sw2)\n\n        if self._logger:\n            self._logger.log_response(response)\n\n        if self._event_emitter:\n            self._event_emitter.emit('apdu_exchange', {\n                'command': cmd_bytes.hex().upper(),\n                'response': data.hex().upper(),\n                'sw': f\"{sw1:02X}{sw2:02X}\"\n            })\n\n        return response\n\n    def send_raw(self, apdu_hex: str) -> APDUResponse:\n        \"\"\"Send raw APDU from hex string.\"\"\"\n        apdu_bytes = bytes.fromhex(apdu_hex.replace(' ', ''))\n        data, sw1, sw2 = self._client.transmit(apdu_bytes)\n        return APDUResponse(data=data, sw1=sw1, sw2=sw2)\n\n    def select_by_aid(self, aid: bytes) -> APDUResponse:\n        \"\"\"SELECT application by AID.\"\"\"\n        cmd = APDUCommand(\n            cla=0x00,\n            ins=INS.SELECT,\n            p1=0x04,  # Select by name\n            p2=0x00,  # First or only occurrence\n            data=aid,\n            le=0x00\n        )\n        return self.send(cmd)\n\n    def select_by_path(self, path: List[int]) -> APDUResponse:\n        \"\"\"SELECT file by path.\"\"\"\n        data = b''.join(fid.to_bytes(2, 'big') for fid in path)\n        cmd = APDUCommand(\n            cla=0x00,\n            ins=INS.SELECT,\n            p1=0x08,  # Select by path from MF\n            p2=0x04,  # Return FCP template\n            data=data\n        )\n        return self.send(cmd)\n\n    def read_binary(self, offset: int = 0, length: int = 0) -> APDUResponse:\n        \"\"\"READ BINARY from current file.\"\"\"\n        cmd = APDUCommand(\n            cla=0x00,\n            ins=INS.READ_BINARY,\n            p1=(offset >> 8) & 0x7F,\n            p2=offset & 0xFF,\n            le=length if length else 0x00\n        )\n        return self.send(cmd)\n\n    def update_binary(self, offset: int, data: bytes) -> APDUResponse:\n        \"\"\"UPDATE BINARY in current file.\"\"\"\n        cmd = APDUCommand(\n            cla=0x00,\n            ins=INS.UPDATE_BINARY,\n            p1=(offset >> 8) & 0x7F,\n            p2=offset & 0xFF,\n            data=data\n        )\n        return self.send(cmd)\n\n    def verify_pin(self, pin: bytes, pin_ref: int = 0x01) -> APDUResponse:\n        \"\"\"VERIFY PIN.\"\"\"\n        cmd = APDUCommand(\n            cla=0x00,\n            ins=INS.VERIFY,\n            p1=0x00,\n            p2=pin_ref,\n            data=pin\n        )\n        return self.send(cmd)\n\n    def get_status(self, p1: int, p2: int, aid_filter: bytes = b'') -> APDUResponse:\n        \"\"\"GET STATUS for Security Domain.\"\"\"\n        cmd = APDUCommand(\n            cla=0x80,\n            ins=INS.GET_STATUS,\n            p1=p1,\n            p2=p2,\n            data=bytes([0x4F, len(aid_filter)]) + aid_filter if aid_filter else bytes([0x4F, 0x00]),\n            le=0x00\n        )\n        return self.send(cmd)\n\n\nclass TLVParser:\n    \"\"\"Parse and build TLV (Tag-Length-Value) structures.\"\"\"\n\n    @staticmethod\n    def parse(data: bytes) -> Dict[int, bytes]:\n        \"\"\"Parse TLV data into dictionary.\"\"\"\n        result = {}\n        offset = 0\n\n        while offset < len(data):\n            # Parse tag (1 or 2 bytes)\n            tag = data[offset]\n            offset += 1\n            if (tag & 0x1F) == 0x1F:  # Two-byte tag\n                tag = (tag << 8) | data[offset]\n                offset += 1\n\n            # Parse length (1 or more bytes)\n            length = data[offset]\n            offset += 1\n            if length == 0x81:\n                length = data[offset]\n                offset += 1\n            elif length == 0x82:\n                length = (data[offset] << 8) | data[offset + 1]\n                offset += 2\n\n            # Extract value\n            value = data[offset:offset + length]\n            offset += length\n\n            result[tag] = value\n\n        return result\n\n    @staticmethod\n    def build(tag: int, value: bytes) -> bytes:\n        \"\"\"Build TLV from tag and value.\"\"\"\n        result = b''\n\n        # Encode tag\n        if tag > 0xFF:\n            result += bytes([(tag >> 8) & 0xFF, tag & 0xFF])\n        else:\n            result += bytes([tag])\n\n        # Encode length\n        length = len(value)\n        if length < 0x80:\n            result += bytes([length])\n        elif length < 0x100:\n            result += bytes([0x81, length])\n        else:\n            result += bytes([0x82, (length >> 8) & 0xFF, length & 0xFF])\n\n        # Append value\n        result += value\n\n        return result\n```\n\n### 3. SecureDomainManager\n\nManages Security Domain operations and secure channel establishment.\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Optional, List\nfrom enum import IntEnum\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\n\nclass LifeCycleState(IntEnum):\n    \"\"\"Security Domain life cycle states.\"\"\"\n    OP_READY = 0x01\n    INITIALIZED = 0x07\n    SECURED = 0x0F\n    CARD_LOCKED = 0x7F\n    TERMINATED = 0xFF\n\n@dataclass\nclass SecurityDomainInfo:\n    \"\"\"Information about a Security Domain.\"\"\"\n    aid: bytes\n    life_cycle_state: LifeCycleState\n    privileges: int\n    associated_sd: Optional[bytes] = None\n\nclass SecureDomainManager:\n    \"\"\"Manages Security Domain operations.\"\"\"\n\n    ISD_AID = bytes.fromhex('A000000151000000')\n\n    def __init__(self, apdu_interface: APDUInterface):\n        self._apdu = apdu_interface\n        self._secure_channel: Optional['SecureChannel'] = None\n        self._current_sd: Optional[bytes] = None\n\n    def select_isd(self) -> APDUResponse:\n        \"\"\"Select Issuer Security Domain.\"\"\"\n        response = self._apdu.select_by_aid(self.ISD_AID)\n        if response.is_success:\n            self._current_sd = self.ISD_AID\n        return response\n\n    def select_sd(self, aid: bytes) -> APDUResponse:\n        \"\"\"Select a Security Domain by AID.\"\"\"\n        response = self._apdu.select_by_aid(aid)\n        if response.is_success:\n            self._current_sd = aid\n        return response\n\n    def get_status_isd(self) -> List[SecurityDomainInfo]:\n        \"\"\"Get status of ISD and associated SDs.\"\"\"\n        response = self._apdu.get_status(0x80, 0x00)\n        return self._parse_get_status_response(response.data)\n\n    def get_status_apps(self) -> List[dict]:\n        \"\"\"Get status of applications.\"\"\"\n        response = self._apdu.get_status(0x40, 0x00)\n        return self._parse_get_status_response(response.data)\n\n    def authenticate_scp02(self, keys: 'SCPKeys') -> bool:\n        \"\"\"Establish SCP02 secure channel.\"\"\"\n        scp02 = SCP02(self._apdu, keys)\n        if scp02.initialize():\n            self._secure_channel = scp02\n            return True\n        return False\n\n    def authenticate_scp03(self, keys: 'SCPKeys') -> bool:\n        \"\"\"Establish SCP03 secure channel.\"\"\"\n        scp03 = SCP03(self._apdu, keys)\n        if scp03.initialize():\n            self._secure_channel = scp03\n            return True\n        return False\n\n    def send_secured(self, command: APDUCommand) -> APDUResponse:\n        \"\"\"Send command through secure channel.\"\"\"\n        if not self._secure_channel:\n            raise SecurityError(\"No secure channel established\")\n        return self._secure_channel.send(command)\n\n    def install_for_install(self, load_aid: bytes, module_aid: bytes,\n                           instance_aid: bytes, privileges: int,\n                           parameters: bytes = b'') -> APDUResponse:\n        \"\"\"INSTALL [for install] command.\"\"\"\n        data = (\n            bytes([len(load_aid)]) + load_aid +\n            bytes([len(module_aid)]) + module_aid +\n            bytes([len(instance_aid)]) + instance_aid +\n            bytes([0x01, privileges]) +\n            bytes([len(parameters)]) + parameters +\n            bytes([0x00])  # Token length\n        )\n        cmd = APDUCommand(\n            cla=0x80,\n            ins=INS.INSTALL,\n            p1=0x04,  # For install\n            p2=0x00,\n            data=data\n        )\n        return self.send_secured(cmd) if self._secure_channel else self._apdu.send(cmd)\n\n    def delete(self, aid: bytes, cascade: bool = False) -> APDUResponse:\n        \"\"\"DELETE command.\"\"\"\n        data = TLVParser.build(0x4F, aid)\n        cmd = APDUCommand(\n            cla=0x80,\n            ins=INS.DELETE,\n            p1=0x00,\n            p2=0x80 if cascade else 0x00,\n            data=data\n        )\n        return self.send_secured(cmd) if self._secure_channel else self._apdu.send(cmd)\n\n    def put_key(self, key_version: int, key_index: int,\n                key_type: int, key_data: bytes) -> APDUResponse:\n        \"\"\"PUT KEY command.\"\"\"\n        # Build key data block\n        key_block = bytes([key_version, key_type, len(key_data)]) + key_data\n\n        cmd = APDUCommand(\n            cla=0x80,\n            ins=INS.PUT_KEY,\n            p1=key_version,\n            p2=key_index,\n            data=key_block\n        )\n        return self.send_secured(cmd)\n\n    def _parse_get_status_response(self, data: bytes) -> List[SecurityDomainInfo]:\n        \"\"\"Parse GET STATUS response.\"\"\"\n        result = []\n        offset = 0\n\n        while offset < len(data):\n            entry_len = data[offset]\n            offset += 1\n\n            entry_data = data[offset:offset + entry_len]\n            offset += entry_len\n\n            # Parse TLV in entry\n            tlv = TLVParser.parse(entry_data)\n\n            if 0x4F in tlv:\n                info = SecurityDomainInfo(\n                    aid=tlv[0x4F],\n                    life_cycle_state=LifeCycleState(tlv.get(0x9F70, b'\\x00')[0] if 0x9F70 in tlv else 0),\n                    privileges=tlv.get(0xC5, b'\\x00')[0] if 0xC5 in tlv else 0\n                )\n                result.append(info)\n\n        return result\n\n\n@dataclass\nclass SCPKeys:\n    \"\"\"Secure Channel Protocol keys.\"\"\"\n    enc: bytes  # Encryption key\n    mac: bytes  # MAC key\n    dek: bytes  # Data encryption key (for PUT KEY)\n    key_version: int = 0x01\n\n    @classmethod\n    def default_test_keys(cls) -> 'SCPKeys':\n        \"\"\"Return default test keys (GlobalPlatform test keys).\"\"\"\n        default_key = bytes.fromhex('404142434445464748494A4B4C4D4E4F')\n        return cls(enc=default_key, mac=default_key, dek=default_key)\n\n\nclass SCP02:\n    \"\"\"SCP02 secure channel implementation.\"\"\"\n\n    def __init__(self, apdu_interface: APDUInterface, keys: SCPKeys):\n        self._apdu = apdu_interface\n        self._keys = keys\n        self._session_keys: Optional[dict] = None\n        self._mac_chain: bytes = bytes(8)\n\n    def initialize(self) -> bool:\n        \"\"\"Initialize SCP02 secure channel.\"\"\"\n        # INITIALIZE UPDATE\n        host_challenge = os.urandom(8)\n        cmd = APDUCommand(\n            cla=0x80,\n            ins=INS.INITIALIZE_UPDATE,\n            p1=self._keys.key_version,\n            p2=0x00,\n            data=host_challenge,\n            le=0x00\n        )\n        response = self._apdu.send(cmd)\n\n        if not response.is_success:\n            return False\n\n        # Parse response\n        if len(response.data) < 28:\n            return False\n\n        key_diversification = response.data[0:10]\n        key_version = response.data[10]\n        scp_id = response.data[11]\n        sequence_counter = response.data[12:14]\n        card_challenge = response.data[14:20]\n        card_cryptogram = response.data[20:28]\n\n        # Derive session keys\n        self._session_keys = self._derive_session_keys(sequence_counter)\n\n        # Verify card cryptogram\n        if not self._verify_card_cryptogram(host_challenge, sequence_counter,\n                                           card_challenge, card_cryptogram):\n            return False\n\n        # Calculate host cryptogram\n        host_cryptogram = self._calculate_host_cryptogram(\n            host_challenge, sequence_counter, card_challenge\n        )\n\n        # EXTERNAL AUTHENTICATE\n        cmd = APDUCommand(\n            cla=0x84,\n            ins=INS.EXTERNAL_AUTHENTICATE,\n            p1=0x01,  # C-MAC\n            p2=0x00,\n            data=host_cryptogram\n        )\n        # Add C-MAC\n        cmd_with_mac = self._add_cmac(cmd)\n        response = self._apdu.send(cmd_with_mac)\n\n        return response.is_success\n\n    def send(self, command: APDUCommand) -> APDUResponse:\n        \"\"\"Send command with secure channel protection.\"\"\"\n        secured_cmd = self._add_cmac(command)\n        return self._apdu.send(secured_cmd)\n\n    def _derive_session_keys(self, sequence_counter: bytes) -> dict:\n        \"\"\"Derive session keys from static keys.\"\"\"\n        # Simplified key derivation (actual implementation uses full derivation)\n        derivation_data = bytes([0x01, 0x82]) + sequence_counter + bytes(12)\n\n        cipher = Cipher(algorithms.TripleDES(self._keys.enc + self._keys.enc[:8]),\n                       modes.CBC(bytes(8)), backend=default_backend())\n        encryptor = cipher.encryptor()\n        s_enc = encryptor.update(derivation_data) + encryptor.finalize()\n\n        derivation_data = bytes([0x01, 0x01]) + sequence_counter + bytes(12)\n        cipher = Cipher(algorithms.TripleDES(self._keys.mac + self._keys.mac[:8]),\n                       modes.CBC(bytes(8)), backend=default_backend())\n        encryptor = cipher.encryptor()\n        s_mac = encryptor.update(derivation_data) + encryptor.finalize()\n\n        return {'enc': s_enc[:16], 'mac': s_mac[:16]}\n\n    def _verify_card_cryptogram(self, host_challenge: bytes, sequence_counter: bytes,\n                                card_challenge: bytes, card_cryptogram: bytes) -> bool:\n        \"\"\"Verify card cryptogram.\"\"\"\n        # Calculate expected cryptogram\n        data = host_challenge + sequence_counter + card_challenge\n        data = data + bytes(24 - len(data))  # Pad to 24 bytes\n\n        cipher = Cipher(algorithms.TripleDES(self._session_keys['enc'] + self._session_keys['enc'][:8]),\n                       modes.CBC(bytes(8)), backend=default_backend())\n        encryptor = cipher.encryptor()\n        result = encryptor.update(data) + encryptor.finalize()\n\n        return result[-8:] == card_cryptogram\n\n    def _calculate_host_cryptogram(self, host_challenge: bytes,\n                                   sequence_counter: bytes,\n                                   card_challenge: bytes) -> bytes:\n        \"\"\"Calculate host cryptogram.\"\"\"\n        data = sequence_counter + card_challenge + host_challenge\n        data = data + bytes(24 - len(data))\n\n        cipher = Cipher(algorithms.TripleDES(self._session_keys['enc'] + self._session_keys['enc'][:8]),\n                       modes.CBC(bytes(8)), backend=default_backend())\n        encryptor = cipher.encryptor()\n        result = encryptor.update(data) + encryptor.finalize()\n\n        return result[-8:]\n\n    def _add_cmac(self, command: APDUCommand) -> APDUCommand:\n        \"\"\"Add C-MAC to command.\"\"\"\n        # Build data for MAC calculation\n        cmd_bytes = command.to_bytes()\n\n        # Modify CLA to indicate secure messaging\n        new_cla = command.cla | 0x04\n\n        # Calculate MAC\n        mac_input = self._mac_chain + bytes([new_cla]) + cmd_bytes[1:]\n        mac_input = self._pad_iso9797(mac_input)\n\n        cipher = Cipher(algorithms.TripleDES(self._session_keys['mac'] + self._session_keys['mac'][:8]),\n                       modes.CBC(bytes(8)), backend=default_backend())\n        encryptor = cipher.encryptor()\n        result = encryptor.update(mac_input) + encryptor.finalize()\n\n        c_mac = result[-8:]\n        self._mac_chain = c_mac\n\n        # Return new command with MAC appended\n        return APDUCommand(\n            cla=new_cla,\n            ins=command.ins,\n            p1=command.p1,\n            p2=command.p2,\n            data=command.data + c_mac,\n            le=command.le\n        )\n\n    def _pad_iso9797(self, data: bytes) -> bytes:\n        \"\"\"ISO 9797-1 Method 2 padding.\"\"\"\n        padded = data + bytes([0x80])\n        while len(padded) % 8 != 0:\n            padded += bytes([0x00])\n        return padded\n\n\nclass SCP03:\n    \"\"\"SCP03 secure channel implementation (AES-based).\"\"\"\n\n    def __init__(self, apdu_interface: APDUInterface, keys: SCPKeys):\n        self._apdu = apdu_interface\n        self._keys = keys\n        self._session_keys: Optional[dict] = None\n        self._counter: int = 0\n\n    def initialize(self) -> bool:\n        \"\"\"Initialize SCP03 secure channel.\"\"\"\n        # Similar to SCP02 but with AES and different key derivation\n        host_challenge = os.urandom(8)\n        cmd = APDUCommand(\n            cla=0x80,\n            ins=INS.INITIALIZE_UPDATE,\n            p1=self._keys.key_version,\n            p2=0x00,\n            data=host_challenge,\n            le=0x00\n        )\n        response = self._apdu.send(cmd)\n\n        if not response.is_success or len(response.data) < 32:\n            return False\n\n        # Parse response and derive keys (SCP03 specific)\n        # ... implementation details ...\n\n        return True\n\n    def send(self, command: APDUCommand) -> APDUResponse:\n        \"\"\"Send command with SCP03 protection.\"\"\"\n        # Add AES-CMAC\n        # ... implementation details ...\n        return self._apdu.send(command)\n```\n\n### 4. PSKConfig\n\nHandles PSK key provisioning on the UICC.\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Optional\nimport os\nimport secrets\n\n@dataclass\nclass PSKConfiguration:\n    \"\"\"PSK configuration data.\"\"\"\n    identity: bytes\n    key: bytes\n    key_size: int\n\n    @classmethod\n    def generate(cls, identity: str, key_size: int = 32) -> 'PSKConfiguration':\n        \"\"\"Generate new PSK with random key.\"\"\"\n        if key_size not in (16, 32, 64):\n            raise ValueError(\"Key size must be 16, 32, or 64 bytes\")\n\n        return cls(\n            identity=identity.encode('utf-8'),\n            key=secrets.token_bytes(key_size),\n            key_size=key_size\n        )\n\n    @classmethod\n    def from_hex(cls, identity: str, key_hex: str) -> 'PSKConfiguration':\n        \"\"\"Create PSK from hex key string.\"\"\"\n        key = bytes.fromhex(key_hex.replace(' ', ''))\n        return cls(\n            identity=identity.encode('utf-8'),\n            key=key,\n            key_size=len(key)\n        )\n\n\nclass PSKConfig:\n    \"\"\"Configure PSK on UICC card.\"\"\"\n\n    # File IDs for PSK storage (vendor-specific, example values)\n    EF_PSK_ID = 0x6F01\n    EF_PSK_KEY = 0x6F02\n\n    def __init__(self, apdu_interface: APDUInterface,\n                 sd_manager: SecureDomainManager):\n        self._apdu = apdu_interface\n        self._sd = sd_manager\n\n    def configure(self, psk: PSKConfiguration) -> bool:\n        \"\"\"Configure PSK identity and key on card.\"\"\"\n        # Store PSK identity\n        if not self._write_psk_identity(psk.identity):\n            return False\n\n        # Store PSK key\n        if not self._write_psk_key(psk.key):\n            return False\n\n        return True\n\n    def read_configuration(self) -> Optional[PSKConfiguration]:\n        \"\"\"Read current PSK configuration from card.\"\"\"\n        identity = self._read_psk_identity()\n        if identity is None:\n            return None\n\n        # Note: Key should not be readable for security\n        # We can only verify it exists\n        key_exists = self._verify_psk_key_exists()\n\n        if not key_exists:\n            return None\n\n        return PSKConfiguration(\n            identity=identity,\n            key=b'',  # Key is write-only\n            key_size=0\n        )\n\n    def verify(self, psk: PSKConfiguration) -> bool:\n        \"\"\"Verify PSK configuration matches.\"\"\"\n        current = self.read_configuration()\n        if current is None:\n            return False\n\n        return current.identity == psk.identity\n\n    def _write_psk_identity(self, identity: bytes) -> bool:\n        \"\"\"Write PSK identity to card.\"\"\"\n        # Select PSK identity file\n        response = self._apdu.select_by_path([0x3F00, 0x7FFF, self.EF_PSK_ID])\n        if not response.is_success:\n            # Try to create file if it doesn't exist\n            if not self._create_psk_file(self.EF_PSK_ID, len(identity)):\n                return False\n            response = self._apdu.select_by_path([0x3F00, 0x7FFF, self.EF_PSK_ID])\n\n        # Write identity\n        response = self._apdu.update_binary(0, identity)\n        return response.is_success\n\n    def _write_psk_key(self, key: bytes) -> bool:\n        \"\"\"Write PSK key to card.\"\"\"\n        # Select PSK key file\n        response = self._apdu.select_by_path([0x3F00, 0x7FFF, self.EF_PSK_KEY])\n        if not response.is_success:\n            if not self._create_psk_file(self.EF_PSK_KEY, len(key)):\n                return False\n            response = self._apdu.select_by_path([0x3F00, 0x7FFF, self.EF_PSK_KEY])\n\n        # Write key (may require secure channel)\n        response = self._apdu.update_binary(0, key)\n        return response.is_success\n\n    def _read_psk_identity(self) -> Optional[bytes]:\n        \"\"\"Read PSK identity from card.\"\"\"\n        response = self._apdu.select_by_path([0x3F00, 0x7FFF, self.EF_PSK_ID])\n        if not response.is_success:\n            return None\n\n        response = self._apdu.read_binary(0, 0)\n        if not response.is_success:\n            return None\n\n        # Strip padding\n        return response.data.rstrip(b'\\xFF').rstrip(b'\\x00')\n\n    def _verify_psk_key_exists(self) -> bool:\n        \"\"\"Verify PSK key file exists and has content.\"\"\"\n        response = self._apdu.select_by_path([0x3F00, 0x7FFF, self.EF_PSK_KEY])\n        return response.is_success\n\n    def _create_psk_file(self, fid: int, size: int) -> bool:\n        \"\"\"Create PSK file on card.\"\"\"\n        # CREATE FILE command (may require secure channel)\n        # Implementation depends on card profile\n        return False\n\n\nclass KeyManager:\n    \"\"\"Secure key handling utilities.\"\"\"\n\n    @staticmethod\n    def generate_random_key(size: int) -> bytes:\n        \"\"\"Generate cryptographically secure random key.\"\"\"\n        return secrets.token_bytes(size)\n\n    @staticmethod\n    def derive_key(master_key: bytes, label: bytes, context: bytes,\n                   output_size: int) -> bytes:\n        \"\"\"Derive key using HKDF.\"\"\"\n        from cryptography.hazmat.primitives import hashes\n        from cryptography.hazmat.primitives.kdf.hkdf import HKDF\n\n        hkdf = HKDF(\n            algorithm=hashes.SHA256(),\n            length=output_size,\n            salt=None,\n            info=label + context,\n            backend=default_backend()\n        )\n        return hkdf.derive(master_key)\n\n    @staticmethod\n    def secure_compare(a: bytes, b: bytes) -> bool:\n        \"\"\"Constant-time comparison to prevent timing attacks.\"\"\"\n        if len(a) != len(b):\n            return False\n        result = 0\n        for x, y in zip(a, b):\n            result |= x ^ y\n        return result == 0\n\n    @staticmethod\n    def secure_erase(data: bytearray) -> None:\n        \"\"\"Securely erase sensitive data from memory.\"\"\"\n        for i in range(len(data)):\n            data[i] = 0\n```\n\n### 5. URLConfig\n\nConfigures admin server URL on the UICC.\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom urllib.parse import urlparse\n\n@dataclass\nclass URLConfiguration:\n    \"\"\"Admin server URL configuration.\"\"\"\n    url: str\n    scheme: str\n    host: str\n    port: int\n    path: str\n\n    @classmethod\n    def from_url(cls, url: str) -> 'URLConfiguration':\n        \"\"\"Parse URL into configuration.\"\"\"\n        parsed = urlparse(url)\n\n        if parsed.scheme not in ('http', 'https'):\n            raise ValueError(\"URL must use http or https scheme\")\n\n        port = parsed.port\n        if port is None:\n            port = 443 if parsed.scheme == 'https' else 80\n\n        return cls(\n            url=url,\n            scheme=parsed.scheme,\n            host=parsed.hostname,\n            port=port,\n            path=parsed.path or '/'\n        )\n\n    def to_tlv(self) -> bytes:\n        \"\"\"Encode URL as TLV for card storage.\"\"\"\n        url_bytes = self.url.encode('utf-8')\n        return TLVParser.build(0x5A, url_bytes)  # Example tag\n\n\nclass URLConfig:\n    \"\"\"Configure admin server URL on UICC.\"\"\"\n\n    EF_ADMIN_URL = 0x6F03\n    MAX_URL_LENGTH = 255\n\n    def __init__(self, apdu_interface: APDUInterface):\n        self._apdu = apdu_interface\n\n    def configure(self, config: URLConfiguration) -> bool:\n        \"\"\"Store admin URL on card.\"\"\"\n        if len(config.url) > self.MAX_URL_LENGTH:\n            raise ValueError(f\"URL exceeds maximum length of {self.MAX_URL_LENGTH}\")\n\n        # Select URL file\n        response = self._apdu.select_by_path([0x3F00, 0x7FFF, self.EF_ADMIN_URL])\n        if not response.is_success:\n            return False\n\n        # Encode and write\n        url_data = config.to_tlv()\n        response = self._apdu.update_binary(0, url_data)\n\n        return response.is_success\n\n    def read_configuration(self) -> Optional[URLConfiguration]:\n        \"\"\"Read current URL configuration.\"\"\"\n        response = self._apdu.select_by_path([0x3F00, 0x7FFF, self.EF_ADMIN_URL])\n        if not response.is_success:\n            return None\n\n        response = self._apdu.read_binary(0, 0)\n        if not response.is_success:\n            return None\n\n        # Parse TLV\n        tlv = TLVParser.parse(response.data)\n        if 0x5A not in tlv:\n            return None\n\n        url_str = tlv[0x5A].decode('utf-8').rstrip('\\x00')\n        return URLConfiguration.from_url(url_str)\n\n    def validate(self, url: str) -> bool:\n        \"\"\"Validate URL format.\"\"\"\n        try:\n            config = URLConfiguration.from_url(url)\n            return len(url) <= self.MAX_URL_LENGTH\n        except:\n            return False\n```\n\n### 6. TriggerConfig\n\nConfigures OTA trigger mechanisms on the UICC.\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Optional, List\nfrom enum import IntEnum\n\nclass TriggerType(IntEnum):\n    \"\"\"OTA trigger types.\"\"\"\n    SMS_PP = 0x01\n    POLLING = 0x02\n    BIP_PUSH = 0x03\n\n@dataclass\nclass SMSTriggerConfig:\n    \"\"\"SMS-PP trigger configuration.\"\"\"\n    tar: bytes  # Toolkit Application Reference (3 bytes)\n    originating_address: Optional[str] = None\n    kic: Optional[bytes] = None  # Ciphering key\n    kid: Optional[bytes] = None  # Signing key\n    counter: int = 0\n    security_level: int = 0x00\n\n@dataclass\nclass PollTriggerConfig:\n    \"\"\"Polling trigger configuration.\"\"\"\n    interval_seconds: int\n    enabled: bool = True\n\n@dataclass\nclass TriggerConfiguration:\n    \"\"\"Complete trigger configuration.\"\"\"\n    trigger_type: TriggerType\n    sms_config: Optional[SMSTriggerConfig] = None\n    poll_config: Optional[PollTriggerConfig] = None\n\n\nclass TriggerConfig:\n    \"\"\"Configure OTA triggers on UICC.\"\"\"\n\n    EF_TRIGGER_CONFIG = 0x6F04\n\n    def __init__(self, apdu_interface: APDUInterface):\n        self._apdu = apdu_interface\n\n    def configure_sms_trigger(self, config: SMSTriggerConfig) -> bool:\n        \"\"\"Configure SMS-PP trigger.\"\"\"\n        # Build trigger data TLV\n        data = b''\n        data += TLVParser.build(0x80, config.tar)  # TAR\n        data += TLVParser.build(0x81, bytes([config.security_level]))\n\n        if config.kic:\n            data += TLVParser.build(0x82, config.kic)\n        if config.kid:\n            data += TLVParser.build(0x83, config.kid)\n        if config.originating_address:\n            data += TLVParser.build(0x84, config.originating_address.encode())\n\n        data += TLVParser.build(0x85, config.counter.to_bytes(5, 'big'))\n\n        # Write to card\n        response = self._apdu.select_by_path([0x3F00, 0x7FFF, self.EF_TRIGGER_CONFIG])\n        if not response.is_success:\n            return False\n\n        trigger_tlv = TLVParser.build(0xA0, data)  # SMS trigger wrapper\n        response = self._apdu.update_binary(0, trigger_tlv)\n\n        return response.is_success\n\n    def configure_poll_trigger(self, config: PollTriggerConfig) -> bool:\n        \"\"\"Configure polling trigger.\"\"\"\n        data = bytes([0x01 if config.enabled else 0x00])\n        data += config.interval_seconds.to_bytes(4, 'big')\n\n        response = self._apdu.select_by_path([0x3F00, 0x7FFF, self.EF_TRIGGER_CONFIG])\n        if not response.is_success:\n            return False\n\n        trigger_tlv = TLVParser.build(0xA1, data)  # Poll trigger wrapper\n        response = self._apdu.update_binary(0, trigger_tlv)\n\n        return response.is_success\n\n    def read_configuration(self) -> List[TriggerConfiguration]:\n        \"\"\"Read all trigger configurations.\"\"\"\n        response = self._apdu.select_by_path([0x3F00, 0x7FFF, self.EF_TRIGGER_CONFIG])\n        if not response.is_success:\n            return []\n\n        response = self._apdu.read_binary(0, 0)\n        if not response.is_success:\n            return []\n\n        return self._parse_trigger_config(response.data)\n\n    def disable_trigger(self, trigger_type: TriggerType) -> bool:\n        \"\"\"Disable a specific trigger.\"\"\"\n        # Read current config, remove specified trigger, rewrite\n        configs = self.read_configuration()\n        configs = [c for c in configs if c.trigger_type != trigger_type]\n        return self._write_all_triggers(configs)\n\n    def _parse_trigger_config(self, data: bytes) -> List[TriggerConfiguration]:\n        \"\"\"Parse trigger configuration data.\"\"\"\n        configs = []\n        tlv = TLVParser.parse(data)\n\n        if 0xA0 in tlv:\n            # SMS trigger\n            sms_tlv = TLVParser.parse(tlv[0xA0])\n            sms_config = SMSTriggerConfig(\n                tar=sms_tlv.get(0x80, b'\\x00\\x00\\x00'),\n                security_level=sms_tlv.get(0x81, b'\\x00')[0] if 0x81 in sms_tlv else 0,\n                kic=sms_tlv.get(0x82),\n                kid=sms_tlv.get(0x83)\n            )\n            configs.append(TriggerConfiguration(\n                trigger_type=TriggerType.SMS_PP,\n                sms_config=sms_config\n            ))\n\n        if 0xA1 in tlv:\n            # Poll trigger\n            poll_data = tlv[0xA1]\n            poll_config = PollTriggerConfig(\n                enabled=poll_data[0] == 0x01,\n                interval_seconds=int.from_bytes(poll_data[1:5], 'big')\n            )\n            configs.append(TriggerConfiguration(\n                trigger_type=TriggerType.POLLING,\n                poll_config=poll_config\n            ))\n\n        return configs\n\n    def _write_all_triggers(self, configs: List[TriggerConfiguration]) -> bool:\n        \"\"\"Write all trigger configurations.\"\"\"\n        # Implementation to rewrite all triggers\n        return True\n```\n\n### 7. BIPConfig\n\nConfigures BIP (Bearer Independent Protocol) settings.\n\n```python\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom enum import IntEnum\n\nclass BearerType(IntEnum):\n    \"\"\"Bearer types for BIP.\"\"\"\n    CSD = 0x01\n    GPRS = 0x02\n    DEFAULT = 0x03\n    PACKET_SERVICE = 0x09\n    EUTRAN = 0x0B\n\n@dataclass\nclass BIPConfiguration:\n    \"\"\"BIP configuration parameters.\"\"\"\n    bearer_type: BearerType\n    apn: Optional[str] = None\n    buffer_size: int = 1400\n    connection_timeout: int = 60\n\n    def to_tlv(self) -> bytes:\n        \"\"\"Encode BIP config as TLV.\"\"\"\n        data = b''\n        data += TLVParser.build(0x80, bytes([self.bearer_type]))\n\n        if self.apn:\n            # Encode APN as label format\n            apn_encoded = self._encode_apn(self.apn)\n            data += TLVParser.build(0x81, apn_encoded)\n\n        data += TLVParser.build(0x82, self.buffer_size.to_bytes(2, 'big'))\n        data += TLVParser.build(0x83, self.connection_timeout.to_bytes(2, 'big'))\n\n        return data\n\n    def _encode_apn(self, apn: str) -> bytes:\n        \"\"\"Encode APN in DNS label format.\"\"\"\n        result = b''\n        for label in apn.split('.'):\n            result += bytes([len(label)]) + label.encode('ascii')\n        return result\n\n\nclass BIPConfig:\n    \"\"\"Configure BIP settings on UICC.\"\"\"\n\n    EF_BIP_CONFIG = 0x6F05\n\n    def __init__(self, apdu_interface: APDUInterface):\n        self._apdu = apdu_interface\n\n    def configure(self, config: BIPConfiguration) -> bool:\n        \"\"\"Store BIP configuration on card.\"\"\"\n        response = self._apdu.select_by_path([0x3F00, 0x7FFF, self.EF_BIP_CONFIG])\n        if not response.is_success:\n            return False\n\n        data = config.to_tlv()\n        response = self._apdu.update_binary(0, data)\n\n        return response.is_success\n\n    def read_configuration(self) -> Optional[BIPConfiguration]:\n        \"\"\"Read current BIP configuration.\"\"\"\n        response = self._apdu.select_by_path([0x3F00, 0x7FFF, self.EF_BIP_CONFIG])\n        if not response.is_success:\n            return None\n\n        response = self._apdu.read_binary(0, 0)\n        if not response.is_success:\n            return None\n\n        return self._parse_bip_config(response.data)\n\n    def check_terminal_support(self) -> dict:\n        \"\"\"Check terminal profile for BIP support.\"\"\"\n        # Read terminal profile\n        response = self._apdu.select_by_path([0x3F00, 0x7F10, 0x6F52])  # EF_TST\n        if not response.is_success:\n            return {'bip_supported': False}\n\n        response = self._apdu.read_binary(0, 0)\n        if not response.is_success:\n            return {'bip_supported': False}\n\n        # Parse terminal profile for BIP capabilities\n        profile = response.data\n        return {\n            'bip_supported': len(profile) > 17 and (profile[17] & 0x01),\n            'open_channel': len(profile) > 17 and (profile[17] & 0x01),\n            'close_channel': len(profile) > 17 and (profile[17] & 0x02),\n            'receive_data': len(profile) > 17 and (profile[17] & 0x04),\n            'send_data': len(profile) > 17 and (profile[17] & 0x08)\n        }\n\n    def _parse_bip_config(self, data: bytes) -> Optional[BIPConfiguration]:\n        \"\"\"Parse BIP configuration from TLV data.\"\"\"\n        if not data or data == b'\\xFF' * len(data):\n            return None\n\n        tlv = TLVParser.parse(data)\n\n        bearer = BearerType(tlv[0x80][0]) if 0x80 in tlv else BearerType.DEFAULT\n\n        apn = None\n        if 0x81 in tlv:\n            apn = self._decode_apn(tlv[0x81])\n\n        buffer_size = int.from_bytes(tlv.get(0x82, b'\\x05\\x78'), 'big')\n        timeout = int.from_bytes(tlv.get(0x83, b'\\x00\\x3C'), 'big')\n\n        return BIPConfiguration(\n            bearer_type=bearer,\n            apn=apn,\n            buffer_size=buffer_size,\n            connection_timeout=timeout\n        )\n\n    def _decode_apn(self, data: bytes) -> str:\n        \"\"\"Decode APN from DNS label format.\"\"\"\n        labels = []\n        offset = 0\n        while offset < len(data):\n            length = data[offset]\n            if length == 0:\n                break\n            offset += 1\n            labels.append(data[offset:offset + length].decode('ascii'))\n            offset += length\n        return '.'.join(labels)\n```\n\n### 8. ProfileManager\n\nManages card configuration profiles.\n\n```python\nfrom dataclasses import dataclass, asdict\nfrom typing import Optional, Dict, Any, List\nimport json\nfrom pathlib import Path\nfrom datetime import datetime\n\n@dataclass\nclass CardProfile:\n    \"\"\"Complete card configuration profile.\"\"\"\n    name: str\n    created_at: str\n    card_info: Dict[str, Any]\n    psk_identity: Optional[str] = None\n    psk_key: Optional[str] = None  # Hex encoded, optional export\n    admin_url: Optional[str] = None\n    triggers: List[Dict[str, Any]] = None\n    bip_config: Optional[Dict[str, Any]] = None\n    security_domains: List[Dict[str, Any]] = None\n\n    def to_json(self, include_keys: bool = False) -> str:\n        \"\"\"Export profile to JSON.\"\"\"\n        data = asdict(self)\n        if not include_keys:\n            data.pop('psk_key', None)\n        return json.dumps(data, indent=2)\n\n    @classmethod\n    def from_json(cls, json_str: str) -> 'CardProfile':\n        \"\"\"Load profile from JSON.\"\"\"\n        data = json.loads(json_str)\n        return cls(**data)\n\n\nclass ProfileManager:\n    \"\"\"Manages card configuration profiles.\"\"\"\n\n    def __init__(self,\n                 pcsc_client: PCSCClient,\n                 apdu_interface: APDUInterface,\n                 sd_manager: SecureDomainManager,\n                 psk_config: PSKConfig,\n                 url_config: URLConfig,\n                 trigger_config: TriggerConfig,\n                 bip_config: BIPConfig):\n        self._pcsc = pcsc_client\n        self._apdu = apdu_interface\n        self._sd = sd_manager\n        self._psk = psk_config\n        self._url = url_config\n        self._trigger = trigger_config\n        self._bip = bip_config\n\n    def save_profile(self, name: str, include_keys: bool = False) -> CardProfile:\n        \"\"\"Save current card configuration as profile.\"\"\"\n        # Get card info\n        card_info = self._get_card_info()\n\n        # Get PSK config\n        psk = self._psk.read_configuration()\n        psk_identity = psk.identity.decode() if psk else None\n\n        # Get URL config\n        url = self._url.read_configuration()\n        admin_url = url.url if url else None\n\n        # Get triggers\n        triggers = [asdict(t) for t in self._trigger.read_configuration()]\n\n        # Get BIP config\n        bip = self._bip.read_configuration()\n        bip_dict = asdict(bip) if bip else None\n\n        # Get Security Domains\n        sds = self._sd.get_status_isd()\n        sd_list = [{'aid': sd.aid.hex(), 'state': sd.life_cycle_state.name}\n                   for sd in sds]\n\n        profile = CardProfile(\n            name=name,\n            created_at=datetime.utcnow().isoformat(),\n            card_info=card_info,\n            psk_identity=psk_identity,\n            admin_url=admin_url,\n            triggers=triggers,\n            bip_config=bip_dict,\n            security_domains=sd_list\n        )\n\n        return profile\n\n    def load_profile(self, profile: CardProfile) -> Dict[str, Any]:\n        \"\"\"Load profile and return diff with current card.\"\"\"\n        current = self.save_profile(\"current\")\n\n        diff = {\n            'psk_identity': {\n                'current': current.psk_identity,\n                'profile': profile.psk_identity,\n                'changed': current.psk_identity != profile.psk_identity\n            },\n            'admin_url': {\n                'current': current.admin_url,\n                'profile': profile.admin_url,\n                'changed': current.admin_url != profile.admin_url\n            },\n            'triggers': {\n                'current': current.triggers,\n                'profile': profile.triggers,\n                'changed': current.triggers != profile.triggers\n            },\n            'bip_config': {\n                'current': current.bip_config,\n                'profile': profile.bip_config,\n                'changed': current.bip_config != profile.bip_config\n            }\n        }\n\n        return diff\n\n    def apply_profile(self, profile: CardProfile,\n                      psk_key: Optional[bytes] = None) -> Dict[str, bool]:\n        \"\"\"Apply profile to card.\"\"\"\n        results = {}\n\n        # Apply PSK\n        if profile.psk_identity:\n            if psk_key or profile.psk_key:\n                key = psk_key or bytes.fromhex(profile.psk_key)\n                psk = PSKConfiguration(\n                    identity=profile.psk_identity.encode(),\n                    key=key,\n                    key_size=len(key)\n                )\n                results['psk'] = self._psk.configure(psk)\n            else:\n                results['psk'] = False\n\n        # Apply URL\n        if profile.admin_url:\n            url = URLConfiguration.from_url(profile.admin_url)\n            results['url'] = self._url.configure(url)\n\n        # Apply triggers\n        if profile.triggers:\n            results['triggers'] = self._apply_triggers(profile.triggers)\n\n        # Apply BIP config\n        if profile.bip_config:\n            bip = BIPConfiguration(**profile.bip_config)\n            results['bip'] = self._bip.configure(bip)\n\n        return results\n\n    def compare_profiles(self, profile1: CardProfile,\n                        profile2: CardProfile) -> Dict[str, Any]:\n        \"\"\"Compare two profiles and highlight differences.\"\"\"\n        diff = {}\n\n        fields = ['psk_identity', 'admin_url', 'triggers', 'bip_config']\n        for field in fields:\n            val1 = getattr(profile1, field)\n            val2 = getattr(profile2, field)\n            if val1 != val2:\n                diff[field] = {\n                    'profile1': val1,\n                    'profile2': val2\n                }\n\n        return diff\n\n    def export_profile(self, profile: CardProfile, path: Path,\n                      include_keys: bool = False) -> None:\n        \"\"\"Export profile to file.\"\"\"\n        json_str = profile.to_json(include_keys=include_keys)\n        path.write_text(json_str)\n\n    def import_profile(self, path: Path) -> CardProfile:\n        \"\"\"Import profile from file.\"\"\"\n        json_str = path.read_text()\n        return CardProfile.from_json(json_str)\n\n    def _get_card_info(self) -> Dict[str, Any]:\n        \"\"\"Get basic card information.\"\"\"\n        # Read ICCID\n        response = self._apdu.select_by_path([0x3F00, 0x2FE2])\n        iccid = None\n        if response.is_success:\n            resp = self._apdu.read_binary(0, 10)\n            if resp.is_success:\n                iccid = self._decode_iccid(resp.data)\n\n        return {\n            'iccid': iccid,\n            'atr': self._pcsc._connection.getATR() if self._pcsc._connection else None\n        }\n\n    def _decode_iccid(self, data: bytes) -> str:\n        \"\"\"Decode ICCID from BCD format.\"\"\"\n        result = ''\n        for byte in data:\n            result += f'{byte & 0x0F:X}'\n            if (byte >> 4) != 0x0F:\n                result += f'{byte >> 4:X}'\n        return result\n\n    def _apply_triggers(self, triggers: List[Dict]) -> bool:\n        \"\"\"Apply trigger configurations.\"\"\"\n        success = True\n        for trigger in triggers:\n            if trigger['trigger_type'] == TriggerType.SMS_PP.value:\n                config = SMSTriggerConfig(**trigger['sms_config'])\n                success = success and self._trigger.configure_sms_trigger(config)\n            elif trigger['trigger_type'] == TriggerType.POLLING.value:\n                config = PollTriggerConfig(**trigger['poll_config'])\n                success = success and self._trigger.configure_poll_trigger(config)\n        return success\n```\n\n### 9. EventEmitter\n\nEvent publication for external integration.\n\n```python\nfrom typing import Callable, Dict, List, Any\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport threading\nimport queue\n\n@dataclass\nclass ProvisionerEvent:\n    \"\"\"Event data structure.\"\"\"\n    event_type: str\n    timestamp: str\n    data: Dict[str, Any]\n\nclass EventEmitter:\n    \"\"\"Event emitter for provisioner events.\"\"\"\n\n    def __init__(self):\n        self._handlers: Dict[str, List[Callable]] = {}\n        self._event_queue: queue.Queue = queue.Queue()\n        self._lock = threading.Lock()\n\n    def on(self, event_type: str, handler: Callable[[ProvisionerEvent], None]) -> None:\n        \"\"\"Register event handler.\"\"\"\n        with self._lock:\n            if event_type not in self._handlers:\n                self._handlers[event_type] = []\n            self._handlers[event_type].append(handler)\n\n    def off(self, event_type: str, handler: Callable = None) -> None:\n        \"\"\"Remove event handler.\"\"\"\n        with self._lock:\n            if event_type in self._handlers:\n                if handler:\n                    self._handlers[event_type].remove(handler)\n                else:\n                    del self._handlers[event_type]\n\n    def emit(self, event_type: str, data: Dict[str, Any] = None) -> None:\n        \"\"\"Emit event to all registered handlers.\"\"\"\n        event = ProvisionerEvent(\n            event_type=event_type,\n            timestamp=datetime.utcnow().isoformat(),\n            data=data or {}\n        )\n\n        # Queue event for async processing\n        self._event_queue.put(event)\n\n        # Also call handlers directly\n        with self._lock:\n            handlers = self._handlers.get(event_type, [])\n            handlers += self._handlers.get('*', [])  # Wildcard handlers\n\n        for handler in handlers:\n            try:\n                handler(event)\n            except Exception as e:\n                # Log error but don't propagate\n                pass\n\n    def get_pending_events(self) -> List[ProvisionerEvent]:\n        \"\"\"Get all pending events from queue.\"\"\"\n        events = []\n        while not self._event_queue.empty():\n            try:\n                events.append(self._event_queue.get_nowait())\n            except queue.Empty:\n                break\n        return events\n```\n\n### 10. APDULogger\n\nComprehensive APDU logging.\n\n```python\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport json\nfrom pathlib import Path\n\n@dataclass\nclass APDULogEntry:\n    \"\"\"Single APDU exchange log entry.\"\"\"\n    timestamp: str\n    direction: str  # 'command' or 'response'\n    data: str  # Hex string\n    decoded: Optional[str] = None\n    sw: Optional[str] = None\n    sw_message: Optional[str] = None\n\nclass APDULogger:\n    \"\"\"Logs all APDU exchanges.\"\"\"\n\n    def __init__(self, max_entries: int = 10000):\n        self._entries: List[APDULogEntry] = []\n        self._max_entries = max_entries\n        self._enabled = True\n\n    def log_command(self, apdu: bytes) -> None:\n        \"\"\"Log outgoing APDU command.\"\"\"\n        if not self._enabled:\n            return\n\n        entry = APDULogEntry(\n            timestamp=datetime.utcnow().isoformat(),\n            direction='command',\n            data=apdu.hex().upper(),\n            decoded=self._decode_command(apdu)\n        )\n        self._add_entry(entry)\n\n    def log_response(self, response: APDUResponse) -> None:\n        \"\"\"Log incoming APDU response.\"\"\"\n        if not self._enabled:\n            return\n\n        entry = APDULogEntry(\n            timestamp=datetime.utcnow().isoformat(),\n            direction='response',\n            data=response.data.hex().upper() if response.data else '',\n            sw=f'{response.sw1:02X}{response.sw2:02X}',\n            sw_message=response.status_message\n        )\n        self._add_entry(entry)\n\n    def get_entries(self, count: Optional[int] = None) -> List[APDULogEntry]:\n        \"\"\"Get log entries.\"\"\"\n        if count:\n            return self._entries[-count:]\n        return self._entries.copy()\n\n    def clear(self) -> None:\n        \"\"\"Clear all log entries.\"\"\"\n        self._entries.clear()\n\n    def export(self, path: Path, format: str = 'json') -> None:\n        \"\"\"Export logs to file.\"\"\"\n        if format == 'json':\n            data = [asdict(e) for e in self._entries]\n            path.write_text(json.dumps(data, indent=2))\n        elif format == 'csv':\n            import csv\n            with open(path, 'w', newline='') as f:\n                writer = csv.writer(f)\n                writer.writerow(['timestamp', 'direction', 'data', 'decoded', 'sw', 'sw_message'])\n                for e in self._entries:\n                    writer.writerow([e.timestamp, e.direction, e.data,\n                                   e.decoded, e.sw, e.sw_message])\n\n    def enable(self) -> None:\n        \"\"\"Enable logging.\"\"\"\n        self._enabled = True\n\n    def disable(self) -> None:\n        \"\"\"Disable logging.\"\"\"\n        self._enabled = False\n\n    def _add_entry(self, entry: APDULogEntry) -> None:\n        \"\"\"Add entry with overflow handling.\"\"\"\n        self._entries.append(entry)\n        if len(self._entries) > self._max_entries:\n            self._entries = self._entries[-self._max_entries:]\n\n    def _decode_command(self, apdu: bytes) -> str:\n        \"\"\"Decode APDU command to human-readable form.\"\"\"\n        if len(apdu) < 4:\n            return \"Invalid APDU\"\n\n        cla, ins, p1, p2 = apdu[0], apdu[1], apdu[2], apdu[3]\n\n        ins_names = {\n            0xA4: 'SELECT',\n            0xB0: 'READ BINARY',\n            0xD6: 'UPDATE BINARY',\n            0xB2: 'READ RECORD',\n            0xDC: 'UPDATE RECORD',\n            0x20: 'VERIFY',\n            0xF2: 'GET STATUS',\n            0xE6: 'INSTALL',\n            0xE4: 'DELETE',\n            0xD8: 'PUT KEY',\n            0x50: 'INITIALIZE UPDATE',\n            0x82: 'EXTERNAL AUTHENTICATE'\n        }\n\n        ins_name = ins_names.get(ins, f'INS={ins:02X}')\n        return f'{ins_name} P1={p1:02X} P2={p2:02X}'\n```\n\n## CLI Design\n\n### Command Structure\n\n```\ncardlink-provision\n├── list                    # List readers and cards\n├── info <reader>           # Show card information\n│   ├── --atr              # ATR only\n│   ├── --iccid            # ICCID only\n│   ├── --sd               # Security Domains\n│   └── --all              # All information (default)\n├── psk <reader>           # PSK configuration\n│   ├── --identity <id>    # Set PSK identity\n│   ├── --key <hex>        # Set PSK key (hex)\n│   ├── --generate <size>  # Generate random key\n│   └── --export           # Export current PSK\n├── url <reader> <url>     # Set admin URL\n│   └── --read             # Read current URL\n├── trigger <reader>       # Trigger configuration\n│   ├── --sms              # Configure SMS-PP trigger\n│   ├── --poll <interval>  # Configure polling trigger\n│   ├── --tar <hex>        # Set TAR\n│   ├── --disable <type>   # Disable trigger\n│   └── --list             # List configured triggers\n├── bip <reader>           # BIP configuration\n│   ├── --bearer <type>    # Set bearer type\n│   ├── --apn <apn>        # Set APN\n│   └── --read             # Read current config\n├── apdu <reader> <hex>    # Send raw APDU\n│   └── --script <file>    # Run APDU script\n├── auth <reader>          # Authentication\n│   ├── --pin <pin>        # PIN authentication\n│   ├── --adm <key>        # ADM key authentication\n│   ├── --scp02            # SCP02 secure channel\n│   └── --scp03            # SCP03 secure channel\n└── profile                # Profile management\n    ├── save <name>        # Save current config\n    ├── load <file>        # Load and show diff\n    ├── apply <file>       # Apply profile to card\n    ├── compare <f1> <f2>  # Compare two profiles\n    └── export <name>      # Export to file\n        └── --with-keys    # Include PSK keys\n```\n\n### CLI Implementation\n\n```python\nimport click\nfrom typing import Optional\n\n@click.group()\n@click.version_option()\ndef cli():\n    \"\"\"CardLink UICC Provisioner - Configure UICC cards for SCP81 testing.\"\"\"\n    pass\n\n@cli.command()\ndef list():\n    \"\"\"List all connected PC/SC readers and cards.\"\"\"\n    client = PCSCClient()\n    readers = client.list_readers()\n\n    if not readers:\n        click.echo(\"No PC/SC readers found.\")\n        click.echo(\"\\nTroubleshooting:\")\n        click.echo(\"  - Ensure pcscd service is running (Linux)\")\n        click.echo(\"  - Check USB connection to card reader\")\n        click.echo(\"  - Verify reader drivers are installed\")\n        return\n\n    click.echo(f\"Found {len(readers)} reader(s):\\n\")\n    for reader in readers:\n        status = \"Card present\" if reader.has_card else \"No card\"\n        click.echo(f\"  [{reader.index}] {reader.name}\")\n        click.echo(f\"      Status: {status}\")\n        if reader.atr:\n            click.echo(f\"      ATR: {reader.atr.hex().upper()}\")\n        click.echo()\n\n@cli.command()\n@click.argument('reader')\n@click.option('--atr', is_flag=True, help='Show ATR only')\n@click.option('--iccid', is_flag=True, help='Show ICCID only')\n@click.option('--sd', is_flag=True, help='Show Security Domains')\n@click.option('--all', 'show_all', is_flag=True, default=True, help='Show all info')\n@click.option('--json', 'as_json', is_flag=True, help='Output as JSON')\ndef info(reader: str, atr: bool, iccid: bool, sd: bool, show_all: bool, as_json: bool):\n    \"\"\"Show card information.\"\"\"\n    client = PCSCClient()\n\n    try:\n        card_info = client.connect(reader)\n    except Exception as e:\n        click.echo(f\"Error: {e}\", err=True)\n        return\n\n    apdu = APDUInterface(client)\n    sd_mgr = SecureDomainManager(apdu)\n\n    info_data = {}\n\n    if atr or show_all:\n        info_data['atr'] = {\n            'raw': card_info.atr.hex().upper(),\n            'analysis': ATRParser.parse(card_info.atr)\n        }\n\n    if iccid or show_all:\n        # Read ICCID\n        response = apdu.select_by_path([0x3F00, 0x2FE2])\n        if response.is_success:\n            resp = apdu.read_binary(0, 10)\n            if resp.is_success:\n                info_data['iccid'] = decode_iccid(resp.data)\n\n    if sd or show_all:\n        sd_mgr.select_isd()\n        sds = sd_mgr.get_status_isd()\n        info_data['security_domains'] = [\n            {'aid': s.aid.hex().upper(), 'state': s.life_cycle_state.name}\n            for s in sds\n        ]\n\n    if as_json:\n        click.echo(json.dumps(info_data, indent=2))\n    else:\n        for key, value in info_data.items():\n            click.echo(f\"\\n{key.upper()}:\")\n            if isinstance(value, dict):\n                for k, v in value.items():\n                    click.echo(f\"  {k}: {v}\")\n            elif isinstance(value, list):\n                for item in value:\n                    click.echo(f\"  - {item}\")\n            else:\n                click.echo(f\"  {value}\")\n\n    client.disconnect()\n\n@cli.command()\n@click.argument('reader')\n@click.option('--identity', help='PSK identity string')\n@click.option('--key', help='PSK key (hex)')\n@click.option('--generate', type=int, help='Generate random key of size')\n@click.option('--export', 'do_export', is_flag=True, help='Export current PSK')\ndef psk(reader: str, identity: Optional[str], key: Optional[str],\n        generate: Optional[int], do_export: bool):\n    \"\"\"Configure PSK on card.\"\"\"\n    client = PCSCClient()\n    client.connect(reader)\n    apdu = APDUInterface(client)\n    sd_mgr = SecureDomainManager(apdu)\n    psk_cfg = PSKConfig(apdu, sd_mgr)\n\n    if do_export:\n        current = psk_cfg.read_configuration()\n        if current:\n            click.echo(f\"PSK Identity: {current.identity.decode()}\")\n            click.echo(\"PSK Key: [write-only, not readable]\")\n        else:\n            click.echo(\"No PSK configured\")\n        return\n\n    if identity:\n        if generate:\n            psk_config = PSKConfiguration.generate(identity, generate)\n            click.echo(f\"Generated {generate}-byte key: {psk_config.key.hex().upper()}\")\n        elif key:\n            psk_config = PSKConfiguration.from_hex(identity, key)\n        else:\n            click.echo(\"Error: --key or --generate required\", err=True)\n            return\n\n        if psk_cfg.configure(psk_config):\n            click.echo(\"PSK configured successfully\")\n        else:\n            click.echo(\"Failed to configure PSK\", err=True)\n\n    client.disconnect()\n\n@cli.command()\n@click.argument('reader')\n@click.argument('url', required=False)\n@click.option('--read', 'do_read', is_flag=True, help='Read current URL')\ndef url(reader: str, url: Optional[str], do_read: bool):\n    \"\"\"Configure admin server URL.\"\"\"\n    client = PCSCClient()\n    client.connect(reader)\n    apdu = APDUInterface(client)\n    url_cfg = URLConfig(apdu)\n\n    if do_read:\n        current = url_cfg.read_configuration()\n        if current:\n            click.echo(f\"Admin URL: {current.url}\")\n        else:\n            click.echo(\"No URL configured\")\n        return\n\n    if url:\n        if not url_cfg.validate(url):\n            click.echo(f\"Error: Invalid URL format\", err=True)\n            return\n\n        config = URLConfiguration.from_url(url)\n        if url_cfg.configure(config):\n            click.echo(f\"URL configured: {url}\")\n        else:\n            click.echo(\"Failed to configure URL\", err=True)\n\n    client.disconnect()\n\n@cli.command()\n@click.argument('reader')\n@click.argument('apdu_hex')\n@click.option('--script', type=click.Path(exists=True), help='Run APDU script')\ndef apdu(reader: str, apdu_hex: str, script: Optional[str]):\n    \"\"\"Send raw APDU command.\"\"\"\n    client = PCSCClient()\n    client.connect(reader)\n    apdu_if = APDUInterface(client)\n\n    if script:\n        # Run script file\n        with open(script) as f:\n            for line in f:\n                line = line.strip()\n                if line and not line.startswith('#'):\n                    response = apdu_if.send_raw(line)\n                    click.echo(f\">> {line}\")\n                    click.echo(f\"<< {response.data.hex().upper()} {response.sw:04X}\")\n    else:\n        response = apdu_if.send_raw(apdu_hex)\n        click.echo(f\"Response: {response.data.hex().upper()}\")\n        click.echo(f\"Status: {response.sw:04X} ({response.status_message})\")\n\n    client.disconnect()\n\n@cli.group()\ndef profile():\n    \"\"\"Profile management commands.\"\"\"\n    pass\n\n@profile.command()\n@click.argument('reader')\n@click.argument('name')\n@click.option('--with-keys', is_flag=True, help='Include PSK keys')\n@click.option('--output', '-o', type=click.Path(), help='Output file')\ndef save(reader: str, name: str, with_keys: bool, output: Optional[str]):\n    \"\"\"Save current card configuration as profile.\"\"\"\n    # Implementation\n    pass\n\n@profile.command()\n@click.argument('file', type=click.Path(exists=True))\ndef load(file: str):\n    \"\"\"Load profile and show diff with current card.\"\"\"\n    # Implementation\n    pass\n\n@profile.command()\n@click.argument('reader')\n@click.argument('file', type=click.Path(exists=True))\n@click.option('--key', help='PSK key if not in profile')\ndef apply(reader: str, file: str, key: Optional[str]):\n    \"\"\"Apply profile to card.\"\"\"\n    # Implementation\n    pass\n\nif __name__ == '__main__':\n    cli()\n```\n\n## Error Handling\n\n### Error Types\n\n```python\nclass ProvisionerError(Exception):\n    \"\"\"Base exception for provisioner errors.\"\"\"\n    pass\n\nclass ReaderNotFoundError(ProvisionerError):\n    \"\"\"PC/SC reader not found.\"\"\"\n    pass\n\nclass CardNotFoundError(ProvisionerError):\n    \"\"\"No card in reader.\"\"\"\n    pass\n\nclass NotConnectedError(ProvisionerError):\n    \"\"\"Not connected to card.\"\"\"\n    pass\n\nclass APDUError(ProvisionerError):\n    \"\"\"APDU command failed.\"\"\"\n    def __init__(self, sw1: int, sw2: int, message: str = None):\n        self.sw1 = sw1\n        self.sw2 = sw2\n        super().__init__(message or SWDecoder.decode(sw1, sw2))\n\nclass AuthenticationError(ProvisionerError):\n    \"\"\"Authentication failed.\"\"\"\n    pass\n\nclass SecurityError(ProvisionerError):\n    \"\"\"Security operation failed.\"\"\"\n    pass\n\nclass ProfileError(ProvisionerError):\n    \"\"\"Profile operation failed.\"\"\"\n    pass\n```\n\n### Error Handling Strategy\n\n```python\ndef handle_provisioner_operation(func):\n    \"\"\"Decorator for error handling in provisioner operations.\"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except ReaderNotFoundError as e:\n            click.echo(f\"Reader error: {e}\", err=True)\n            click.echo(\"\\nTroubleshooting:\")\n            click.echo(\"  - Check reader connection\")\n            click.echo(\"  - Run 'cardlink-provision list' to see available readers\")\n            return None\n        except CardNotFoundError as e:\n            click.echo(f\"Card error: {e}\", err=True)\n            click.echo(\"  - Ensure card is properly inserted\")\n            return None\n        except APDUError as e:\n            click.echo(f\"Card returned error: {e.sw1:02X}{e.sw2:02X} - {e}\", err=True)\n            return None\n        except AuthenticationError as e:\n            click.echo(f\"Authentication failed: {e}\", err=True)\n            return None\n        except Exception as e:\n            click.echo(f\"Unexpected error: {e}\", err=True)\n            return None\n    return wrapper\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n```python\nimport pytest\nfrom unittest.mock import Mock, patch\n\nclass TestPCSCClient:\n    def test_list_readers_empty(self):\n        with patch('smartcard.System.readers', return_value=[]):\n            client = PCSCClient()\n            assert client.list_readers() == []\n\n    def test_atr_parser(self):\n        atr = bytes.fromhex('3B9F96801FC78031A073BE21136743200718000000')\n        result = ATRParser.parse(atr)\n        assert result['convention'] == 'Direct'\n        assert 'UICC' in result['card_type'] or 'USIM' in result['card_type']\n\nclass TestAPDUInterface:\n    def test_select_by_aid(self):\n        mock_client = Mock()\n        mock_client.transmit.return_value = (b'\\x6F\\x10', 0x90, 0x00)\n\n        apdu = APDUInterface(mock_client)\n        response = apdu.select_by_aid(bytes.fromhex('A000000151000000'))\n\n        assert response.is_success\n        mock_client.transmit.assert_called_once()\n\nclass TestTLVParser:\n    def test_parse_simple(self):\n        data = bytes.fromhex('4F07A0000001510000')\n        result = TLVParser.parse(data)\n        assert 0x4F in result\n        assert result[0x4F] == bytes.fromhex('A0000001510000')\n\n    def test_build_simple(self):\n        result = TLVParser.build(0x4F, bytes.fromhex('A0000001510000'))\n        assert result == bytes.fromhex('4F07A0000001510000')\n```\n\n### Integration Tests\n\n```python\n@pytest.mark.integration\nclass TestProvisionerIntegration:\n    @pytest.fixture\n    def provisioner(self):\n        \"\"\"Setup provisioner with real reader.\"\"\"\n        client = PCSCClient()\n        readers = client.list_readers()\n        if not readers or not any(r.has_card for r in readers):\n            pytest.skip(\"No card reader with card available\")\n\n        reader = next(r for r in readers if r.has_card)\n        client.connect(reader.name)\n\n        yield client\n\n        client.disconnect()\n\n    def test_read_iccid(self, provisioner):\n        apdu = APDUInterface(provisioner)\n        response = apdu.select_by_path([0x3F00, 0x2FE2])\n        assert response.is_success\n\n        response = apdu.read_binary(0, 10)\n        assert response.is_success\n        assert len(response.data) == 10\n```\n\n## Dependencies\n\n### Required Packages\n\n```\npyscard>=2.0.0          # PC/SC interface\ncryptography>=3.4.0     # Cryptographic operations\nclick>=8.0.0            # CLI framework\n```\n\n### System Requirements\n\n- **Linux**: pcscd service, libpcsclite-dev\n- **macOS**: Native PC/SC support (no additional dependencies)\n- **Windows**: WinSCard (built-in)\n",
  "fileStats": {
    "size": 80869,
    "lines": 2359,
    "lastModified": "2025-11-25T11:39:50.755Z"
  },
  "comments": []
}