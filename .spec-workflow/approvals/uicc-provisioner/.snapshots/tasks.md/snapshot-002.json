{
  "id": "snapshot_1764071204676_7i3nzs8hz",
  "approvalId": "approval_1764071164980_3i1zd3jg4",
  "approvalTitle": "UICC Provisioner Tasks Document",
  "version": 2,
  "timestamp": "2025-11-25T11:46:44.676Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Tasks Document: UICC Provisioner\n\n## Task Overview\n\nThis document breaks down the UICC Provisioner implementation into actionable development tasks organized by component and functionality.\n\n## Tasks\n\n### 1. Project Setup and Dependencies\n\n- [ ] 1.1. Create `cardlink/provisioner/` package structure\n- [ ] 1.2. Add pyscard dependency to pyproject.toml with version constraint (>=2.0.0)\n- [ ] 1.3. Add cryptography dependency for SCP02/SCP03 operations\n- [ ] 1.4. Create platform-specific installation docs (pcscd for Linux, native for macOS/Windows)\n- [ ] 1.5. Add pytest fixtures for PC/SC mocking\n\n### 2. PC/SC Client Implementation\n\n- [ ] 2.1. Create `pcsc_client.py` with PCSCClient class\n- [ ] 2.2. Implement `list_readers()` using smartcard.System.readers()\n- [ ] 2.3. Implement `connect(reader_name, protocol)` with T=0/T=1 support\n- [ ] 2.4. Implement `disconnect()` with proper resource cleanup\n- [ ] 2.5. Implement `transmit(apdu)` with GET RESPONSE handling for T=0\n- [ ] 2.6. Create ReaderInfo and CardInfo dataclasses\n- [ ] 2.7. Implement card monitoring with CardMonitor and CardObserver\n- [ ] 2.8. Add `start_monitoring()` and `stop_monitoring()` methods\n- [ ] 2.9. Implement thread-safe transmit with threading.Lock\n- [ ] 2.10. Add connection state tracking and validation\n- [ ] 2.11. Write unit tests for PCSCClient with mocked smartcard module\n\n### 3. ATR Parser Implementation\n\n- [ ] 3.1. Create `atr_parser.py` with ATRParser class\n- [ ] 3.2. Implement `parse(atr)` to extract TS, T0, protocol bytes\n- [ ] 3.3. Implement historical bytes extraction\n- [ ] 3.4. Implement `_identify_card_type()` with pattern matching for UICC/USIM/eUICC\n- [ ] 3.5. Add protocol detection (T=0, T=1) from TD bytes\n- [ ] 3.6. Add convention detection (direct/inverse)\n- [ ] 3.7. Write unit tests with sample ATRs from common UICC vendors\n\n### 4. APDU Interface Implementation\n\n- [ ] 4.1. Create `apdu_interface.py` with APDUCommand and APDUResponse dataclasses\n- [ ] 4.2. Implement INS enum with all common instruction bytes\n- [ ] 4.3. Implement APDUCommand.to_bytes() with Lc/Le handling\n- [ ] 4.4. Implement APDUResponse properties (sw, is_success, status_message)\n- [ ] 4.5. Create SWDecoder class with STATUS_WORDS dictionary\n- [ ] 4.6. Implement SWDecoder.decode() with range handling (61xx, 6Cxx, 63Cx)\n- [ ] 4.7. Create APDUInterface class with send() method\n- [ ] 4.8. Implement `send_raw(apdu_hex)` for raw hex input\n- [ ] 4.9. Implement `select_by_aid(aid)` helper\n- [ ] 4.10. Implement `select_by_path(path)` helper\n- [ ] 4.11. Implement `read_binary(offset, length)` helper\n- [ ] 4.12. Implement `update_binary(offset, data)` helper\n- [ ] 4.13. Implement `verify_pin(pin, pin_ref)` helper\n- [ ] 4.14. Implement `get_status(p1, p2, aid_filter)` for GP commands\n- [ ] 4.15. Write unit tests for APDU construction and response parsing\n\n### 5. TLV Parser Implementation\n\n- [ ] 5.1. Create `tlv_parser.py` with TLVParser class\n- [ ] 5.2. Implement `parse(data)` with 1-byte and 2-byte tag support\n- [ ] 5.3. Implement length parsing (short form, 81, 82)\n- [ ] 5.4. Implement `build(tag, value)` for TLV construction\n- [ ] 5.5. Add recursive parsing for nested TLV structures\n- [ ] 5.6. Write unit tests with various TLV structures\n\n### 6. Security Domain Manager Implementation\n\n- [ ] 6.1. Create `secure_domain.py` with SecureDomainManager class\n- [ ] 6.2. Define ISD_AID constant (A000000151000000)\n- [ ] 6.3. Implement LifeCycleState enum\n- [ ] 6.4. Create SecurityDomainInfo dataclass\n- [ ] 6.5. Implement `select_isd()` method\n- [ ] 6.6. Implement `select_sd(aid)` method\n- [ ] 6.7. Implement `get_status_isd()` with response parsing\n- [ ] 6.8. Implement `get_status_apps()` for application listing\n- [ ] 6.9. Implement `_parse_get_status_response()` TLV parser\n- [ ] 6.10. Implement `install_for_install()` GP command\n- [ ] 6.11. Implement `delete(aid, cascade)` GP command\n- [ ] 6.12. Implement `put_key()` GP command\n- [ ] 6.13. Write unit tests for SD operations\n\n### 7. SCP02 Secure Channel Implementation\n\n- [ ] 7.1. Create `scp02.py` with SCP02 class\n- [ ] 7.2. Create SCPKeys dataclass with enc, mac, dek fields\n- [ ] 7.3. Implement `default_test_keys()` class method\n- [ ] 7.4. Implement `initialize()` with INITIALIZE UPDATE command\n- [ ] 7.5. Parse INITIALIZE UPDATE response (key diversification, sequence counter, card challenge, cryptogram)\n- [ ] 7.6. Implement `_derive_session_keys()` using Triple-DES CBC\n- [ ] 7.7. Implement `_verify_card_cryptogram()` for mutual authentication\n- [ ] 7.8. Implement `_calculate_host_cryptogram()`\n- [ ] 7.9. Implement EXTERNAL AUTHENTICATE with C-MAC\n- [ ] 7.10. Implement `_add_cmac()` for command MAC calculation\n- [ ] 7.11. Implement `_pad_iso9797()` ISO 9797-1 Method 2 padding\n- [ ] 7.12. Implement `send()` for secured command transmission\n- [ ] 7.13. Add MAC chaining support\n- [ ] 7.14. Write unit tests with test vectors\n\n### 8. SCP03 Secure Channel Implementation\n\n- [ ] 8.1. Create `scp03.py` with SCP03 class\n- [ ] 8.2. Implement `initialize()` with AES-based key derivation\n- [ ] 8.3. Implement INITIALIZE UPDATE for SCP03\n- [ ] 8.4. Implement session key derivation using AES-CMAC\n- [ ] 8.5. Implement card cryptogram verification (AES-CMAC)\n- [ ] 8.6. Implement host cryptogram calculation\n- [ ] 8.7. Implement EXTERNAL AUTHENTICATE with AES C-MAC\n- [ ] 8.8. Implement `send()` with C-MAC and optional C-ENC\n- [ ] 8.9. Add counter management for encryption\n- [ ] 8.10. Write unit tests with SCP03 test vectors\n\n### 9. PSK Configuration Implementation\n\n- [ ] 9.1. Create `psk_config.py` with PSKConfiguration dataclass\n- [ ] 9.2. Implement `generate(identity, key_size)` class method\n- [ ] 9.3. Implement `from_hex(identity, key_hex)` class method\n- [ ] 9.4. Create PSKConfig class with EF_PSK_ID and EF_PSK_KEY constants\n- [ ] 9.5. Implement `configure(psk)` to write identity and key\n- [ ] 9.6. Implement `_write_psk_identity()` with file selection and update\n- [ ] 9.7. Implement `_write_psk_key()` with secure channel requirement\n- [ ] 9.8. Implement `read_configuration()` to read current PSK identity\n- [ ] 9.9. Implement `verify(psk)` to compare configurations\n- [ ] 9.10. Implement `_create_psk_file()` for file creation if needed\n- [ ] 9.11. Write unit tests for PSK operations\n\n### 10. Key Manager Implementation\n\n- [ ] 10.1. Create `key_manager.py` with KeyManager class\n- [ ] 10.2. Implement `generate_random_key(size)` using secrets module\n- [ ] 10.3. Implement `derive_key()` using HKDF\n- [ ] 10.4. Implement `secure_compare()` for constant-time comparison\n- [ ] 10.5. Implement `secure_erase()` for memory clearing\n- [ ] 10.6. Write unit tests for key operations\n\n### 11. URL Configuration Implementation\n\n- [ ] 11.1. Create `url_config.py` with URLConfiguration dataclass\n- [ ] 11.2. Implement `from_url(url)` parser using urllib.parse\n- [ ] 11.3. Implement URL validation (scheme, length)\n- [ ] 11.4. Implement `to_tlv()` for card storage encoding\n- [ ] 11.5. Create URLConfig class with EF_ADMIN_URL constant\n- [ ] 11.6. Implement `configure(config)` to store URL\n- [ ] 11.7. Implement `read_configuration()` to read current URL\n- [ ] 11.8. Implement `validate(url)` format checker\n- [ ] 11.9. Write unit tests for URL operations\n\n### 12. Trigger Configuration Implementation\n\n- [ ] 12.1. Create `trigger_config.py` with TriggerType enum\n- [ ] 12.2. Create SMSTriggerConfig dataclass (TAR, originating address, KIc, KID, counter)\n- [ ] 12.3. Create PollTriggerConfig dataclass (interval, enabled)\n- [ ] 12.4. Create TriggerConfiguration dataclass\n- [ ] 12.5. Create TriggerConfig class with EF_TRIGGER_CONFIG constant\n- [ ] 12.6. Implement `configure_sms_trigger(config)` with TLV encoding\n- [ ] 12.7. Implement `configure_poll_trigger(config)`\n- [ ] 12.8. Implement `read_configuration()` to parse all triggers\n- [ ] 12.9. Implement `disable_trigger(trigger_type)`\n- [ ] 12.10. Implement `_parse_trigger_config()` TLV parser\n- [ ] 12.11. Write unit tests for trigger operations\n\n### 13. BIP Configuration Implementation\n\n- [ ] 13.1. Create `bip_config.py` with BearerType enum\n- [ ] 13.2. Create BIPConfiguration dataclass (bearer, APN, buffer, timeout)\n- [ ] 13.3. Implement `to_tlv()` with APN DNS label encoding\n- [ ] 13.4. Implement `_encode_apn()` for DNS label format\n- [ ] 13.5. Create BIPConfig class with EF_BIP_CONFIG constant\n- [ ] 13.6. Implement `configure(config)` to store BIP settings\n- [ ] 13.7. Implement `read_configuration()` to read current settings\n- [ ] 13.8. Implement `check_terminal_support()` to read terminal profile\n- [ ] 13.9. Implement `_decode_apn()` for reading stored APN\n- [ ] 13.10. Write unit tests for BIP operations\n\n### 14. Profile Manager Implementation\n\n- [ ] 14.1. Create `profile_manager.py` with CardProfile dataclass\n- [ ] 14.2. Implement `to_json(include_keys)` export method\n- [ ] 14.3. Implement `from_json(json_str)` class method\n- [ ] 14.4. Create ProfileManager class with all config dependencies\n- [ ] 14.5. Implement `save_profile(name, include_keys)` to capture card state\n- [ ] 14.6. Implement `_get_card_info()` to read ICCID and ATR\n- [ ] 14.7. Implement `_decode_iccid()` BCD decoder\n- [ ] 14.8. Implement `load_profile(profile)` to generate diff\n- [ ] 14.9. Implement `apply_profile(profile, psk_key)` to provision card\n- [ ] 14.10. Implement `compare_profiles(profile1, profile2)`\n- [ ] 14.11. Implement `export_profile(profile, path, include_keys)`\n- [ ] 14.12. Implement `import_profile(path)` file loader\n- [ ] 14.13. Write unit tests for profile operations\n\n### 15. Event Emitter Implementation\n\n- [ ] 15.1. Create `event_emitter.py` with ProvisionerEvent dataclass\n- [ ] 15.2. Create EventEmitter class with handler registry\n- [ ] 15.3. Implement `on(event_type, handler)` registration\n- [ ] 15.4. Implement `off(event_type, handler)` removal\n- [ ] 15.5. Implement `emit(event_type, data)` with async queue\n- [ ] 15.6. Add wildcard handler support ('*')\n- [ ] 15.7. Implement `get_pending_events()` for queue drain\n- [ ] 15.8. Add thread-safe handler management\n- [ ] 15.9. Write unit tests for event emission\n\n### 16. APDU Logger Implementation\n\n- [ ] 16.1. Create `apdu_logger.py` with APDULogEntry dataclass\n- [ ] 16.2. Create APDULogger class with max_entries limit\n- [ ] 16.3. Implement `log_command(apdu)` with decoding\n- [ ] 16.4. Implement `log_response(response)` with SW message\n- [ ] 16.5. Implement `_decode_command()` for human-readable output\n- [ ] 16.6. Implement `get_entries(count)` retrieval\n- [ ] 16.7. Implement `clear()` to reset log\n- [ ] 16.8. Implement `export(path, format)` for JSON and CSV\n- [ ] 16.9. Implement `enable()` and `disable()` toggles\n- [ ] 16.10. Add overflow handling with entry limit\n- [ ] 16.11. Write unit tests for logging operations\n\n### 17. Error Handling Implementation\n\n- [ ] 17.1. Create `exceptions.py` with ProvisionerError base class\n- [ ] 17.2. Define ReaderNotFoundError exception\n- [ ] 17.3. Define CardNotFoundError exception\n- [ ] 17.4. Define NotConnectedError exception\n- [ ] 17.5. Define APDUError exception with SW1/SW2\n- [ ] 17.6. Define AuthenticationError exception\n- [ ] 17.7. Define SecurityError exception\n- [ ] 17.8. Define ProfileError exception\n- [ ] 17.9. Create `handle_provisioner_operation` decorator\n- [ ] 17.10. Implement user-friendly error messages with troubleshooting hints\n\n### 18. CLI: List Command\n\n- [ ] 18.1. Create `cardlink/cli/provision.py` with Click group\n- [ ] 18.2. Implement `list` command\n- [ ] 18.3. Display reader index, name, and card status\n- [ ] 18.4. Display ATR for present cards\n- [ ] 18.5. Add troubleshooting hints when no readers found\n- [ ] 18.6. Write CLI tests for list command\n\n### 19. CLI: Info Command\n\n- [ ] 19.1. Implement `info` command with reader argument\n- [ ] 19.2. Add `--atr` flag for ATR-only output\n- [ ] 19.3. Add `--iccid` flag for ICCID-only output\n- [ ] 19.4. Add `--sd` flag for Security Domain listing\n- [ ] 19.5. Add `--all` flag (default) for complete info\n- [ ] 19.6. Add `--json` flag for JSON output\n- [ ] 19.7. Implement ATR analysis display\n- [ ] 19.8. Implement ICCID reading and display\n- [ ] 19.9. Implement SD status display\n- [ ] 19.10. Write CLI tests for info command\n\n### 20. CLI: PSK Command\n\n- [ ] 20.1. Implement `psk` command with reader argument\n- [ ] 20.2. Add `--identity` option for PSK identity\n- [ ] 20.3. Add `--key` option for hex key input\n- [ ] 20.4. Add `--generate` option with key size parameter\n- [ ] 20.5. Add `--export` flag to read current PSK identity\n- [ ] 20.6. Implement key generation and display\n- [ ] 20.7. Implement PSK configuration flow\n- [ ] 20.8. Add success/failure messages\n- [ ] 20.9. Write CLI tests for psk command\n\n### 21. CLI: URL Command\n\n- [ ] 21.1. Implement `url` command with reader and URL arguments\n- [ ] 21.2. Add `--read` flag to display current URL\n- [ ] 21.3. Implement URL validation before storage\n- [ ] 21.4. Implement URL configuration flow\n- [ ] 21.5. Add success/failure messages\n- [ ] 21.6. Write CLI tests for url command\n\n### 22. CLI: Trigger Command\n\n- [ ] 22.1. Implement `trigger` command with reader argument\n- [ ] 22.2. Add `--sms` flag for SMS-PP trigger setup\n- [ ] 22.3. Add `--poll` option with interval parameter\n- [ ] 22.4. Add `--tar` option for TAR configuration\n- [ ] 22.5. Add `--disable` option with trigger type\n- [ ] 22.6. Add `--list` flag to show configured triggers\n- [ ] 22.7. Implement interactive SMS trigger setup (KIc, KID prompts)\n- [ ] 22.8. Write CLI tests for trigger command\n\n### 23. CLI: BIP Command\n\n- [ ] 23.1. Implement `bip` command with reader argument\n- [ ] 23.2. Add `--bearer` option with type choices\n- [ ] 23.3. Add `--apn` option for APN string\n- [ ] 23.4. Add `--read` flag to display current config\n- [ ] 23.5. Implement BIP configuration flow\n- [ ] 23.6. Display terminal profile BIP support\n- [ ] 23.7. Write CLI tests for bip command\n\n### 24. CLI: APDU Command\n\n- [ ] 24.1. Implement `apdu` command with reader and hex arguments\n- [ ] 24.2. Add `--script` option for APDU script file\n- [ ] 24.3. Implement single APDU transmission and display\n- [ ] 24.4. Implement script execution with comment support (#)\n- [ ] 24.5. Display response data and decoded status\n- [ ] 24.6. Write CLI tests for apdu command\n\n### 25. CLI: Auth Command\n\n- [ ] 25.1. Implement `auth` command with reader argument\n- [ ] 25.2. Add `--pin` option for PIN authentication\n- [ ] 25.3. Add `--adm` option for ADM key (hex)\n- [ ] 25.4. Add `--scp02` flag for SCP02 secure channel\n- [ ] 25.5. Add `--scp03` flag for SCP03 secure channel\n- [ ] 25.6. Implement PIN verification with retry display\n- [ ] 25.7. Implement secure channel establishment\n- [ ] 25.8. Display authentication result and session info\n- [ ] 25.9. Write CLI tests for auth command\n\n### 26. CLI: Profile Commands\n\n- [ ] 26.1. Create `profile` command group\n- [ ] 26.2. Implement `profile save` with name and reader arguments\n- [ ] 26.3. Add `--with-keys` flag for PSK key inclusion\n- [ ] 26.4. Add `--output` option for file path\n- [ ] 26.5. Implement `profile load` with file argument\n- [ ] 26.6. Display diff between profile and current card\n- [ ] 26.7. Implement `profile apply` with reader and file arguments\n- [ ] 26.8. Add `--key` option for PSK key if not in profile\n- [ ] 26.9. Implement `profile compare` with two file arguments\n- [ ] 26.10. Display comparison results\n- [ ] 26.11. Write CLI tests for profile commands\n\n### 27. CLI Entry Point\n\n- [ ] 27.1. Register `cardlink-provision` entry point in pyproject.toml\n- [ ] 27.2. Add version option to CLI group\n- [ ] 27.3. Add global error handling with decorator\n- [ ] 27.4. Add verbose/debug output option\n- [ ] 27.5. Write integration tests for complete CLI workflows\n\n### 28. Integration Tests\n\n- [ ] 28.1. Create integration test fixtures with real reader detection\n- [ ] 28.2. Add pytest.mark.integration marker for hardware tests\n- [ ] 28.3. Write test for reader discovery\n- [ ] 28.4. Write test for card connection and ATR reading\n- [ ] 28.5. Write test for ICCID reading\n- [ ] 28.6. Write test for Security Domain selection\n- [ ] 28.7. Write test for profile save/load cycle\n- [ ] 28.8. Add skip conditions for missing hardware\n\n### 29. Documentation\n\n- [ ] 29.1. Write module docstrings for all classes\n- [ ] 29.2. Document PC/SC setup for Linux (pcscd installation)\n- [ ] 29.3. Document macOS native PC/SC usage\n- [ ] 29.4. Document Windows WinSCard requirements\n- [ ] 29.5. Create CLI usage examples in README\n- [ ] 29.6. Document supported card types and readers\n- [ ] 29.7. Add troubleshooting guide for common errors\n\n### 30. Event Integration\n\n- [ ] 30.1. Add event emission to PCSCClient (card_connected, card_disconnected)\n- [ ] 30.2. Add event emission to card monitoring (card_inserted, card_removed)\n- [ ] 30.3. Add event emission to provisioning operations (provisioning_started, provisioning_completed)\n- [ ] 30.4. Add event emission to APDU exchanges (apdu_exchange)\n- [ ] 30.5. Add event emission for errors (provisioning_error)\n- [ ] 30.6. Write tests for event emission\n\n## Task Dependencies\n\n```\n1 (Setup)\n├── 2 (PCSCClient)\n│   ├── 3 (ATR Parser)\n│   └── 4 (APDU Interface)\n│       ├── 5 (TLV Parser)\n│       ├── 6 (SD Manager)\n│       │   ├── 7 (SCP02)\n│       │   └── 8 (SCP03)\n│       ├── 9 (PSK Config)\n│       │   └── 10 (Key Manager)\n│       ├── 11 (URL Config)\n│       ├── 12 (Trigger Config)\n│       └── 13 (BIP Config)\n├── 14 (Profile Manager) ← depends on 9, 11, 12, 13\n├── 15 (Event Emitter)\n├── 16 (APDU Logger)\n└── 17 (Exceptions)\n\nCLI Tasks (18-27) ← depend on corresponding components\n28 (Integration Tests) ← depends on all components\n29 (Documentation) ← can start early, finalize after implementation\n30 (Event Integration) ← depends on 15 and all components\n```\n\n## Estimated Effort\n\n| Task Group | Tasks | Complexity |\n|------------|-------|------------|\n| Setup | 1.1-1.5 | Low |\n| PC/SC Client | 2.1-2.11 | Medium |\n| ATR Parser | 3.1-3.7 | Low |\n| APDU Interface | 4.1-4.15 | Medium |\n| TLV Parser | 5.1-5.6 | Low |\n| Security Domain | 6.1-6.13 | Medium |\n| SCP02 | 7.1-7.14 | High |\n| SCP03 | 8.1-8.10 | High |\n| PSK Config | 9.1-9.11 | Medium |\n| Key Manager | 10.1-10.6 | Low |\n| URL Config | 11.1-11.9 | Low |\n| Trigger Config | 12.1-12.11 | Medium |\n| BIP Config | 13.1-13.10 | Medium |\n| Profile Manager | 14.1-14.13 | Medium |\n| Event Emitter | 15.1-15.9 | Low |\n| APDU Logger | 16.1-16.11 | Low |\n| Error Handling | 17.1-17.10 | Low |\n| CLI Commands | 18-27 | Medium |\n| Integration Tests | 28.1-28.8 | Medium |\n| Documentation | 29.1-29.7 | Low |\n| Event Integration | 30.1-30.6 | Low |\n\n## Notes\n\n- SCP02 and SCP03 implementations are complex and require careful testing with test vectors\n- Hardware integration tests require actual PC/SC reader and test cards\n- PSK file locations (EF_PSK_ID, EF_PSK_KEY) are vendor-specific and may need configuration\n- Some operations require secure channel establishment before execution\n- PIN/ADM authentication should display remaining retries to prevent card lockout\n",
  "fileStats": {
    "size": 19117,
    "lines": 428,
    "lastModified": "2025-11-25T11:45:58.718Z"
  },
  "comments": []
}