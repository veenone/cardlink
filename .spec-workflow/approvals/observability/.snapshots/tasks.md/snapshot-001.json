{
  "id": "snapshot_1764072251024_asxearcnq",
  "approvalId": "approval_1764072251002_gc9y7p4wv",
  "approvalTitle": "Observability Tasks Document",
  "version": 1,
  "timestamp": "2025-11-25T12:04:11.024Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document: Observability\n\n## Task Overview\n\nThis document breaks down the Observability component implementation into actionable development tasks organized by component and functionality.\n\n## Tasks\n\n### 1. Project Setup and Dependencies\n\n- [ ] 1.1. Create `cardlink/observability/` package structure\n- [ ] 1.2. Add prometheus-client dependency to pyproject.toml (>=0.17.0)\n- [ ] 1.3. Add opentelemetry-api and opentelemetry-sdk dependencies (>=1.20.0)\n- [ ] 1.4. Add opentelemetry-exporter-otlp dependency\n- [ ] 1.5. Add psutil dependency for system metrics\n- [ ] 1.6. Add optional jaeger and zipkin exporter dependencies\n- [ ] 1.7. Create pytest fixtures for metrics and tracing testing\n\n### 2. Observability Configuration\n\n- [ ] 2.1. Create `config.py` with ObservabilityConfig dataclass\n- [ ] 2.2. Add metrics configuration (enabled, port, path, auth)\n- [ ] 2.3. Add tracing configuration (enabled, otlp_endpoint, protocol)\n- [ ] 2.4. Add health configuration (port, enabled)\n- [ ] 2.5. Add logging configuration (level, format, trace_correlation)\n- [ ] 2.6. Implement environment variable parsing for configuration\n- [ ] 2.7. Write unit tests for configuration\n\n### 3. Observability Manager Implementation\n\n- [ ] 3.1. Create `manager.py` with ObservabilityManager class\n- [ ] 3.2. Implement singleton pattern with thread-safe initialization\n- [ ] 3.3. Implement `initialize()` to start all components\n- [ ] 3.4. Implement `shutdown()` to stop all components\n- [ ] 3.5. Add `metrics` property for MetricsCollector access\n- [ ] 3.6. Add `tracer` property for TracingProvider access\n- [ ] 3.7. Add `health` property for HealthChecker access\n- [ ] 3.8. Add `logger` property for StructuredLogger access\n- [ ] 3.9. Implement `get_observability()` global accessor\n- [ ] 3.10. Write unit tests for ObservabilityManager\n\n### 4. Metrics Registry Implementation\n\n- [ ] 4.1. Create `metrics/registry.py` with MetricType enum\n- [ ] 4.2. Create MetricDefinition dataclass\n- [ ] 4.3. Define APDU metrics (commands_total, responses_total, duration, bytes)\n- [ ] 4.4. Define TLS metrics (handshakes_total, duration, connections_active)\n- [ ] 4.5. Define session metrics (active, total, duration, triggers)\n- [ ] 4.6. Define device metrics (connected, errors, at_duration, adb_duration)\n- [ ] 4.7. Define test metrics (total, duration)\n- [ ] 4.8. Define system metrics (cpu, memory, db_connections, uptime)\n- [ ] 4.9. Define build_info metric\n- [ ] 4.10. Write unit tests for registry definitions\n\n### 5. Metrics Collector Implementation\n\n- [ ] 5.1. Create `metrics/collector.py` with MetricsCollector class\n- [ ] 5.2. Implement `__init__` with CollectorRegistry setup\n- [ ] 5.3. Implement `_register_metrics()` to create all metrics from registry\n- [ ] 5.4. Implement `_create_metric()` for Counter, Histogram, Gauge, Info types\n- [ ] 5.5. Implement `get_metric(name)` accessor\n- [ ] 5.6. Implement APDU recording methods:\n  - [ ] 5.6.1. `record_apdu_command(command_type, device_type)`\n  - [ ] 5.6.2. `record_apdu_response(status_word, status_category)`\n  - [ ] 5.6.3. `record_apdu_duration(command_type, duration)`\n  - [ ] 5.6.4. `record_apdu_bytes(direction, byte_count)`\n- [ ] 5.7. Implement TLS recording methods:\n  - [ ] 5.7.1. `record_tls_handshake(result, cipher_suite, duration)`\n  - [ ] 5.7.2. `set_tls_connections(count)`\n  - [ ] 5.7.3. `inc_tls_connections()` / `dec_tls_connections()`\n- [ ] 5.8. Implement session recording methods:\n  - [ ] 5.8.1. `set_active_sessions(count, device_type)`\n  - [ ] 5.8.2. `record_session_complete(status, type, device_type, duration)`\n  - [ ] 5.8.3. `record_trigger_sent(trigger_type)`\n- [ ] 5.9. Implement device recording methods:\n  - [ ] 5.9.1. `set_devices_connected(count, device_type)`\n  - [ ] 5.9.2. `record_device_error(device_type, error_type)`\n  - [ ] 5.9.3. `record_at_command_duration(command, duration)`\n  - [ ] 5.9.4. `record_adb_operation_duration(operation, duration)`\n- [ ] 5.10. Implement test recording methods:\n  - [ ] 5.10.1. `record_test_result(suite_name, status, duration)`\n- [ ] 5.11. Implement system metrics:\n  - [ ] 5.11.1. `update_system_metrics()` using psutil\n  - [ ] 5.11.2. `set_build_info(version, python_version, platform)`\n- [ ] 5.12. Write unit tests for MetricsCollector\n\n### 6. Metrics HTTP Server Implementation\n\n- [ ] 6.1. Implement `start_server(port, path)` method\n- [ ] 6.2. Create MetricsHandler HTTP request handler\n- [ ] 6.3. Implement `/metrics` endpoint with Prometheus format\n- [ ] 6.4. Add optional HTTP Basic authentication\n- [ ] 6.5. Implement `stop_server()` method\n- [ ] 6.6. Implement `get_metrics_text()` for direct access\n- [ ] 6.7. Add request logging suppression\n- [ ] 6.8. Write integration tests for metrics endpoint\n\n### 7. Tracing Provider Implementation\n\n- [ ] 7.1. Create `tracing/provider.py` with TracingProvider class\n- [ ] 7.2. Implement `__init__` with service name, version, OTLP config\n- [ ] 7.3. Implement `initialize()` with Resource and TracerProvider setup\n- [ ] 7.4. Implement OTLP exporter configuration (gRPC and HTTP)\n- [ ] 7.5. Implement BatchSpanProcessor setup\n- [ ] 7.6. Implement `shutdown()` for clean shutdown\n- [ ] 7.7. Implement `get_tracer()` accessor\n- [ ] 7.8. Implement `start_span(name, kind, attributes)` context manager\n- [ ] 7.9. Implement `current_span()` accessor\n- [ ] 7.10. Implement `inject_context(carrier)` for propagation\n- [ ] 7.11. Implement `extract_context(carrier)` for propagation\n- [ ] 7.12. Implement `trace_decorator(name, kind)` function decorator\n- [ ] 7.13. Write unit tests for TracingProvider\n\n### 8. Span Manager Implementation\n\n- [ ] 8.1. Create `tracing/spans.py` with SpanManager class\n- [ ] 8.2. Implement `apdu_span(command_type, device_id)` context manager\n- [ ] 8.3. Implement `tls_handshake_span(client_address)` context manager\n- [ ] 8.4. Implement `session_span(session_id, session_type)` context manager\n- [ ] 8.5. Implement `db_span(operation, table)` context manager\n- [ ] 8.6. Implement `test_span(suite_name, test_name)` context manager\n- [ ] 8.7. Implement `add_apdu_response(span, status_word, duration_ms)`\n- [ ] 8.8. Add error status handling for spans\n- [ ] 8.9. Write unit tests for SpanManager\n\n### 9. Health Checker Implementation\n\n- [ ] 9.1. Create `health/checker.py` with HealthStatus enum\n- [ ] 9.2. Create HealthCheckResult dataclass\n- [ ] 9.3. Create OverallHealth dataclass\n- [ ] 9.4. Create HealthChecker class\n- [ ] 9.5. Implement `register_check(name, check_fn)` method\n- [ ] 9.6. Implement `unregister_check(name)` method\n- [ ] 9.7. Implement `run_check(name)` with timing and error handling\n- [ ] 9.8. Implement `run_all_checks()` with aggregated status\n- [ ] 9.9. Implement `check_liveness()` basic check\n- [ ] 9.10. Implement `check_readiness()` comprehensive check\n- [ ] 9.11. Write unit tests for HealthChecker\n\n### 10. Pre-defined Health Checks\n\n- [ ] 10.1. Create `health/checks.py` with check factories\n- [ ] 10.2. Implement `create_database_check(db_manager)` factory\n- [ ] 10.3. Implement `create_metrics_check(metrics_port)` factory\n- [ ] 10.4. Implement `create_disk_space_check(path, threshold)` factory\n- [ ] 10.5. Implement `create_memory_check(threshold)` factory\n- [ ] 10.6. Write unit tests for pre-defined checks\n\n### 11. Health HTTP Server Implementation\n\n- [ ] 11.1. Implement `start_server(port)` method\n- [ ] 11.2. Create HealthHandler HTTP request handler\n- [ ] 11.3. Implement `/health` endpoint (overall health)\n- [ ] 11.4. Implement `/health/live` endpoint (liveness)\n- [ ] 11.5. Implement `/health/ready` endpoint (readiness)\n- [ ] 11.6. Implement JSON response formatting\n- [ ] 11.7. Implement `stop_server()` method\n- [ ] 11.8. Write integration tests for health endpoints\n\n### 12. Structured Logger Implementation\n\n- [ ] 12.1. Create `logging/structured.py` with StructuredFormatter class\n- [ ] 12.2. Implement JSON formatting with all fields\n- [ ] 12.3. Implement trace context extraction (trace_id, span_id)\n- [ ] 12.4. Implement exception formatting\n- [ ] 12.5. Create StructuredLogger class\n- [ ] 12.6. Implement `_configure_root()` for root logger setup\n- [ ] 12.7. Implement `get_logger(name)` accessor\n- [ ] 12.8. Implement `set_level(name, level)` method\n- [ ] 12.9. Write unit tests for StructuredLogger\n\n### 13. Component Logger Implementation\n\n- [ ] 13.1. Create ComponentLogger class\n- [ ] 13.2. Implement `with_context(**kwargs)` for adding context\n- [ ] 13.3. Implement `_log(level, message, **kwargs)` internal method\n- [ ] 13.4. Implement `debug()`, `info()`, `warning()`, `error()` methods\n- [ ] 13.5. Implement `exception()` method with traceback\n- [ ] 13.6. Write unit tests for ComponentLogger\n\n### 14. Dashboard Templates Implementation\n\n- [ ] 14.1. Create `dashboards/templates.py` with DashboardTemplates class\n- [ ] 14.2. Implement `ota_overview()` dashboard definition\n- [ ] 14.3. Implement `apdu_analysis()` dashboard definition\n- [ ] 14.4. Implement `device_status()` dashboard definition\n- [ ] 14.5. Implement `test_results()` dashboard definition\n- [ ] 14.6. Implement `export_all(output_dir)` method\n- [ ] 14.7. Add proper Grafana panel configurations\n- [ ] 14.8. Write unit tests for dashboard generation\n\n### 15. Alerting Rules Implementation\n\n- [ ] 15.1. Create `alerting/rules.py` with AlertingRules class\n- [ ] 15.2. Define error alerting rules:\n  - [ ] 15.2.1. HighAPDUErrorRate alert\n  - [ ] 15.2.2. SessionTimeoutSpike alert\n  - [ ] 15.2.3. TLSHandshakeFailures alert\n  - [ ] 15.2.4. DeviceDisconnected alert\n  - [ ] 15.2.5. DatabaseConnectionFailure alert\n- [ ] 15.3. Define performance alerting rules:\n  - [ ] 15.3.1. HighAPDULatency alert\n  - [ ] 15.3.2. LongSessionDuration alert\n- [ ] 15.4. Implement `get_rules()` method\n- [ ] 15.5. Implement `export_yaml(output_path)` method\n- [ ] 15.6. Write unit tests for alerting rules\n\n### 16. CLI: Status Command\n\n- [ ] 16.1. Create `cardlink/cli/metrics.py` with Click group\n- [ ] 16.2. Implement `status` command\n- [ ] 16.3. Display current metric values summary\n- [ ] 16.4. Add `--json` flag for JSON output\n- [ ] 16.5. Write CLI tests for status command\n\n### 17. CLI: Export Command\n\n- [ ] 17.1. Implement `export` command\n- [ ] 17.2. Add `--format` option (prometheus, json)\n- [ ] 17.3. Add `--output` option for file path\n- [ ] 17.4. Default to stdout if no output specified\n- [ ] 17.5. Write CLI tests for export command\n\n### 18. CLI: Health Command\n\n- [ ] 18.1. Implement `health` command\n- [ ] 18.2. Display overall health status\n- [ ] 18.3. Add `--verbose` flag for detailed check results\n- [ ] 18.4. Display colored output based on status\n- [ ] 18.5. Write CLI tests for health command\n\n### 19. CLI: Config Command\n\n- [ ] 19.1. Implement `config` command group\n- [ ] 19.2. Implement `config show` subcommand\n- [ ] 19.3. Implement `config set <key> <value>` subcommand\n- [ ] 19.4. Display current configuration values\n- [ ] 19.5. Write CLI tests for config command\n\n### 20. CLI: Test Command\n\n- [ ] 20.1. Implement `test` command\n- [ ] 20.2. Add `--otlp` flag to test OTLP connectivity\n- [ ] 20.3. Add `--metrics` flag to test metrics endpoint\n- [ ] 20.4. Add `--health` flag to test health endpoint\n- [ ] 20.5. Display connectivity results\n- [ ] 20.6. Write CLI tests for test command\n\n### 21. CLI: Dashboards Command\n\n- [ ] 21.1. Implement `dashboards` command group\n- [ ] 21.2. Implement `dashboards export <dir>` subcommand\n- [ ] 21.3. Export all Grafana dashboard JSON files\n- [ ] 21.4. Display export summary\n- [ ] 21.5. Write CLI tests for dashboards command\n\n### 22. CLI Entry Point\n\n- [ ] 22.1. Register `cardlink-metrics` entry point in pyproject.toml\n- [ ] 22.2. Add version option to CLI group\n- [ ] 22.3. Add global error handling\n- [ ] 22.4. Write integration tests for complete CLI workflows\n\n### 23. Integration with PSK-TLS Server\n\n- [ ] 23.1. Add metrics recording to TLS handshake\n- [ ] 23.2. Add metrics recording to APDU exchanges\n- [ ] 23.3. Add tracing spans to session handling\n- [ ] 23.4. Add health check for server status\n- [ ] 23.5. Write integration tests\n\n### 24. Integration with Phone Controller\n\n- [ ] 24.1. Add metrics recording to ADB operations\n- [ ] 24.2. Add device connection metrics\n- [ ] 24.3. Add tracing spans to device operations\n- [ ] 24.4. Add health check for ADB availability\n- [ ] 24.5. Write integration tests\n\n### 25. Integration with Modem Controller\n\n- [ ] 25.1. Add metrics recording to AT commands\n- [ ] 25.2. Add device connection metrics for modems\n- [ ] 25.3. Add tracing spans to modem operations\n- [ ] 25.4. Add health check for serial port availability\n- [ ] 25.5. Write integration tests\n\n### 26. Integration with Database Layer\n\n- [ ] 26.1. Add metrics recording to database queries\n- [ ] 26.2. Add connection pool metrics\n- [ ] 26.3. Add tracing spans to database operations\n- [ ] 26.4. Add health check for database connectivity\n- [ ] 26.5. Write integration tests\n\n### 27. Integration with Test Runner\n\n- [ ] 27.1. Add metrics recording to test execution\n- [ ] 27.2. Add tracing spans to test cases\n- [ ] 27.3. Record test results metrics\n- [ ] 27.4. Write integration tests\n\n### 28. System Metrics Collection\n\n- [ ] 28.1. Implement background thread for system metrics collection\n- [ ] 28.2. Collect CPU usage at intervals\n- [ ] 28.3. Collect memory usage at intervals\n- [ ] 28.4. Collect open file descriptors\n- [ ] 28.5. Calculate and record uptime\n- [ ] 28.6. Write unit tests for system metrics\n\n### 29. Documentation\n\n- [ ] 29.1. Write module docstrings for all classes\n- [ ] 29.2. Document metrics endpoint configuration\n- [ ] 29.3. Document OTLP export configuration\n- [ ] 29.4. Document health check customization\n- [ ] 29.5. Create Grafana dashboard import guide\n- [ ] 29.6. Document alerting rules customization\n- [ ] 29.7. Add CLI usage examples\n\n### 30. Performance Testing\n\n- [ ] 30.1. Benchmark metrics collection overhead\n- [ ] 30.2. Benchmark tracing overhead\n- [ ] 30.3. Test high-cardinality label handling\n- [ ] 30.4. Test metrics endpoint response time under load\n- [ ] 30.5. Document performance characteristics\n\n## Task Dependencies\n\n```\n1 (Setup)\n├── 2 (Config)\n│   └── 3 (Manager)\n├── 4 (Registry)\n│   └── 5-6 (Collector + Server)\n├── 7-8 (Tracing Provider + Span Manager)\n├── 9-11 (Health Checker + Checks + Server)\n├── 12-13 (Structured Logger + Component Logger)\n├── 14 (Dashboard Templates)\n└── 15 (Alerting Rules)\n\nCLI Tasks (16-22) ← depend on corresponding components\nIntegration Tasks (23-27) ← depend on core implementation\n28 (System Metrics) ← depends on 5\n29 (Documentation) ← finalize after implementation\n30 (Performance) ← after core implementation\n```\n\n## Estimated Effort\n\n| Task Group | Tasks | Complexity |\n|------------|-------|------------|\n| Setup | 1.1-1.7 | Low |\n| Config | 2.1-2.7 | Low |\n| Manager | 3.1-3.10 | Medium |\n| Registry | 4.1-4.10 | Low |\n| Collector | 5.1-5.12 | Medium |\n| Metrics Server | 6.1-6.8 | Medium |\n| Tracing Provider | 7.1-7.13 | High |\n| Span Manager | 8.1-8.9 | Medium |\n| Health Checker | 9.1-9.11 | Medium |\n| Pre-defined Checks | 10.1-10.6 | Low |\n| Health Server | 11.1-11.8 | Medium |\n| Structured Logger | 12.1-12.9 | Medium |\n| Component Logger | 13.1-13.6 | Low |\n| Dashboards | 14.1-14.8 | Medium |\n| Alerting Rules | 15.1-15.6 | Low |\n| CLI Commands | 16-22 | Medium |\n| Integrations | 23-27 | Medium |\n| System Metrics | 28.1-28.6 | Low |\n| Documentation | 29.1-29.7 | Low |\n| Performance | 30.1-30.5 | Medium |\n\n## Notes\n\n- OpenTelemetry tracing is optional but recommended for debugging complex issues\n- Metrics collection should have minimal performance impact (<1% CPU overhead)\n- Health checks should complete within 5 seconds to avoid timeout issues\n- Dashboard templates are Grafana-compatible JSON exports\n- Alerting rules are Prometheus-compatible YAML format\n- Structured logging with trace correlation enables log-trace correlation in observability platforms\n- Label cardinality should be controlled to prevent memory issues (avoid high-cardinality device_id labels in production)\n",
  "fileStats": {
    "size": 16038,
    "lines": 385,
    "lastModified": "2025-11-25T12:04:05.538Z"
  },
  "comments": []
}