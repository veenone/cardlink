{
  "id": "snapshot_1764072164978_4fqoy89xj",
  "approvalId": "approval_1764072130405_64o424fyu",
  "approvalTitle": "Observability Design Document",
  "version": 2,
  "timestamp": "2025-11-25T12:02:44.978Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Observability\n\n## Introduction\n\nThis document describes the technical design for the Observability component of CardLink. The observability layer provides comprehensive monitoring through Prometheus metrics, OpenTelemetry tracing, structured logging, and health check endpoints.\n\n## System Architecture\n\n### High-Level Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                           CardLink Application                               │\n│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │\n│  │ PSK-TLS     │ │ Phone       │ │ Modem       │ │ Test        │           │\n│  │ Server      │ │ Controller  │ │ Controller  │ │ Runner      │           │\n│  └──────┬──────┘ └──────┬──────┘ └──────┬──────┘ └──────┬──────┘           │\n│         │               │               │               │                   │\n│         └───────────────┴───────────────┴───────────────┘                   │\n│                                   │                                          │\n│                                   ▼                                          │\n│  ┌───────────────────────────────────────────────────────────────────────┐  │\n│  │                      Observability Layer                               │  │\n│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐     │  │\n│  │  │MetricsCollector│ │TracingProvider│ │HealthChecker│ │StructuredLogger│ │  │\n│  │  └──────┬──────┘ └──────┬──────┘ └──────┬──────┘ └──────┬──────┘     │  │\n│  │         │               │               │               │             │  │\n│  │  ┌──────┴───────────────┴───────────────┴───────────────┴──────┐     │  │\n│  │  │                    ObservabilityManager                      │     │  │\n│  │  └──────────────────────────────────────────────────────────────┘     │  │\n│  └───────────────────────────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────────────────────┘\n                                    │\n                    ┌───────────────┼───────────────┐\n                    │               │               │\n                    ▼               ▼               ▼\n         ┌─────────────────┐ ┌───────────┐ ┌─────────────────┐\n         │ /metrics        │ │ /health   │ │ OTLP Exporter   │\n         │ (Prometheus)    │ │ endpoints │ │ (gRPC/HTTP)     │\n         └────────┬────────┘ └─────┬─────┘ └────────┬────────┘\n                  │                │                │\n                  ▼                ▼                ▼\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                        External Monitoring Systems                           │\n│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │\n│  │ Prometheus  │ │ Grafana     │ │ Grafana     │ │ Jaeger/     │           │\n│  │             │ │             │ │ Alloy       │ │ Zipkin      │           │\n│  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘           │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### Component Descriptions\n\n| Component | Responsibility |\n|-----------|----------------|\n| **ObservabilityManager** | Central coordinator for all observability features |\n| **MetricsCollector** | Collects and exposes Prometheus metrics |\n| **MetricsRegistry** | Manages metric definitions and instances |\n| **MetricsExporter** | HTTP endpoint for Prometheus scraping |\n| **TracingProvider** | OpenTelemetry tracer configuration |\n| **SpanManager** | Creates and manages trace spans |\n| **OTLPExporter** | Exports traces/metrics via OTLP |\n| **HealthChecker** | Performs health checks on components |\n| **HealthEndpoint** | HTTP endpoints for health status |\n| **StructuredLogger** | JSON logging with trace correlation |\n\n## Component Design\n\n### 1. ObservabilityManager\n\nCentral manager for all observability features.\n\n```python\nfrom typing import Optional, Dict, Any\nfrom dataclasses import dataclass\nimport threading\n\n@dataclass\nclass ObservabilityConfig:\n    \"\"\"Observability configuration.\"\"\"\n    # Metrics\n    metrics_enabled: bool = True\n    metrics_port: int = 9090\n    metrics_path: str = '/metrics'\n    metrics_auth_enabled: bool = False\n    metrics_username: Optional[str] = None\n    metrics_password: Optional[str] = None\n\n    # Tracing\n    tracing_enabled: bool = False\n    otlp_endpoint: Optional[str] = None\n    otlp_protocol: str = 'grpc'  # grpc or http\n    service_name: str = 'cardlink'\n    service_version: str = '1.0.0'\n\n    # Health\n    health_port: int = 8081\n    health_enabled: bool = True\n\n    # Logging\n    log_level: str = 'INFO'\n    log_format: str = 'json'\n    log_trace_correlation: bool = True\n\n\nclass ObservabilityManager:\n    \"\"\"Central manager for observability features.\"\"\"\n\n    _instance: Optional['ObservabilityManager'] = None\n    _lock = threading.Lock()\n\n    def __new__(cls, config: Optional[ObservabilityConfig] = None):\n        \"\"\"Singleton pattern.\"\"\"\n        with cls._lock:\n            if cls._instance is None:\n                cls._instance = super().__new__(cls)\n                cls._instance._initialized = False\n            return cls._instance\n\n    def __init__(self, config: Optional[ObservabilityConfig] = None):\n        if self._initialized:\n            return\n\n        self.config = config or ObservabilityConfig()\n        self._metrics_collector: Optional[MetricsCollector] = None\n        self._tracing_provider: Optional[TracingProvider] = None\n        self._health_checker: Optional[HealthChecker] = None\n        self._logger: Optional[StructuredLogger] = None\n        self._initialized = True\n\n    def initialize(self) -> None:\n        \"\"\"Initialize all observability components.\"\"\"\n        # Initialize metrics\n        if self.config.metrics_enabled:\n            self._metrics_collector = MetricsCollector()\n            self._metrics_collector.start_server(\n                port=self.config.metrics_port,\n                path=self.config.metrics_path\n            )\n\n        # Initialize tracing\n        if self.config.tracing_enabled:\n            self._tracing_provider = TracingProvider(\n                service_name=self.config.service_name,\n                service_version=self.config.service_version,\n                otlp_endpoint=self.config.otlp_endpoint,\n                otlp_protocol=self.config.otlp_protocol\n            )\n            self._tracing_provider.initialize()\n\n        # Initialize health checker\n        if self.config.health_enabled:\n            self._health_checker = HealthChecker()\n            self._health_checker.start_server(port=self.config.health_port)\n\n        # Initialize structured logger\n        self._logger = StructuredLogger(\n            level=self.config.log_level,\n            format=self.config.log_format,\n            trace_correlation=self.config.log_trace_correlation\n        )\n\n    def shutdown(self) -> None:\n        \"\"\"Shutdown all observability components.\"\"\"\n        if self._metrics_collector:\n            self._metrics_collector.stop_server()\n        if self._tracing_provider:\n            self._tracing_provider.shutdown()\n        if self._health_checker:\n            self._health_checker.stop_server()\n\n    @property\n    def metrics(self) -> 'MetricsCollector':\n        \"\"\"Get metrics collector.\"\"\"\n        if not self._metrics_collector:\n            raise RuntimeError(\"Metrics not initialized\")\n        return self._metrics_collector\n\n    @property\n    def tracer(self) -> 'TracingProvider':\n        \"\"\"Get tracing provider.\"\"\"\n        if not self._tracing_provider:\n            raise RuntimeError(\"Tracing not initialized\")\n        return self._tracing_provider\n\n    @property\n    def health(self) -> 'HealthChecker':\n        \"\"\"Get health checker.\"\"\"\n        if not self._health_checker:\n            raise RuntimeError(\"Health checker not initialized\")\n        return self._health_checker\n\n    @property\n    def logger(self) -> 'StructuredLogger':\n        \"\"\"Get structured logger.\"\"\"\n        return self._logger\n\n\n# Global accessor\ndef get_observability() -> ObservabilityManager:\n    \"\"\"Get the global observability manager.\"\"\"\n    return ObservabilityManager()\n```\n\n### 2. MetricsCollector\n\nCollects and manages Prometheus metrics.\n\n```python\nfrom prometheus_client import (\n    Counter, Histogram, Gauge, Info,\n    CollectorRegistry, generate_latest, CONTENT_TYPE_LATEST,\n    start_http_server\n)\nfrom typing import Dict, Optional, List\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport threading\n\nclass MetricType(Enum):\n    COUNTER = 'counter'\n    HISTOGRAM = 'histogram'\n    GAUGE = 'gauge'\n    INFO = 'info'\n\n\n@dataclass\nclass MetricDefinition:\n    \"\"\"Metric definition.\"\"\"\n    name: str\n    description: str\n    metric_type: MetricType\n    labels: List[str]\n    buckets: Optional[List[float]] = None  # For histograms\n\n\nclass MetricsRegistry:\n    \"\"\"Registry for metric definitions.\"\"\"\n\n    # APDU Metrics\n    APDU_COMMANDS_TOTAL = MetricDefinition(\n        name='cardlink_apdu_commands_total',\n        description='Total APDU commands sent',\n        metric_type=MetricType.COUNTER,\n        labels=['command_type', 'device_type']\n    )\n\n    APDU_RESPONSES_TOTAL = MetricDefinition(\n        name='cardlink_apdu_responses_total',\n        description='Total APDU responses received',\n        metric_type=MetricType.COUNTER,\n        labels=['status_word', 'status_category']\n    )\n\n    APDU_DURATION_SECONDS = MetricDefinition(\n        name='cardlink_apdu_duration_seconds',\n        description='APDU command/response duration',\n        metric_type=MetricType.HISTOGRAM,\n        labels=['command_type'],\n        buckets=[0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5]\n    )\n\n    APDU_BYTES_TOTAL = MetricDefinition(\n        name='cardlink_apdu_bytes_total',\n        description='Total APDU bytes transferred',\n        metric_type=MetricType.COUNTER,\n        labels=['direction']  # sent, received\n    )\n\n    # TLS Metrics\n    TLS_HANDSHAKES_TOTAL = MetricDefinition(\n        name='cardlink_tls_handshakes_total',\n        description='Total TLS handshakes',\n        metric_type=MetricType.COUNTER,\n        labels=['result', 'cipher_suite']\n    )\n\n    TLS_HANDSHAKE_DURATION_SECONDS = MetricDefinition(\n        name='cardlink_tls_handshake_duration_seconds',\n        description='TLS handshake duration',\n        metric_type=MetricType.HISTOGRAM,\n        labels=['result'],\n        buckets=[0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0]\n    )\n\n    TLS_CONNECTIONS_ACTIVE = MetricDefinition(\n        name='cardlink_tls_connections_active',\n        description='Currently active TLS connections',\n        metric_type=MetricType.GAUGE,\n        labels=[]\n    )\n\n    # Session Metrics\n    SESSIONS_ACTIVE = MetricDefinition(\n        name='cardlink_sessions_active',\n        description='Currently active OTA sessions',\n        metric_type=MetricType.GAUGE,\n        labels=['device_type']\n    )\n\n    SESSIONS_TOTAL = MetricDefinition(\n        name='cardlink_sessions_total',\n        description='Total OTA sessions',\n        metric_type=MetricType.COUNTER,\n        labels=['status', 'session_type', 'device_type']\n    )\n\n    SESSION_DURATION_SECONDS = MetricDefinition(\n        name='cardlink_session_duration_seconds',\n        description='OTA session duration',\n        metric_type=MetricType.HISTOGRAM,\n        labels=['status'],\n        buckets=[0.1, 0.5, 1.0, 2.5, 5.0, 10.0, 30.0, 60.0, 120.0]\n    )\n\n    TRIGGERS_SENT_TOTAL = MetricDefinition(\n        name='cardlink_triggers_sent_total',\n        description='Total OTA triggers sent',\n        metric_type=MetricType.COUNTER,\n        labels=['trigger_type']  # sms, poll\n    )\n\n    # Device Metrics\n    DEVICES_CONNECTED = MetricDefinition(\n        name='cardlink_devices_connected',\n        description='Currently connected devices',\n        metric_type=MetricType.GAUGE,\n        labels=['device_type']\n    )\n\n    DEVICE_ERRORS_TOTAL = MetricDefinition(\n        name='cardlink_device_errors_total',\n        description='Total device errors',\n        metric_type=MetricType.COUNTER,\n        labels=['device_type', 'error_type']\n    )\n\n    AT_COMMAND_DURATION_SECONDS = MetricDefinition(\n        name='cardlink_at_command_duration_seconds',\n        description='AT command duration',\n        metric_type=MetricType.HISTOGRAM,\n        labels=['command'],\n        buckets=[0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0]\n    )\n\n    ADB_OPERATION_DURATION_SECONDS = MetricDefinition(\n        name='cardlink_adb_operation_duration_seconds',\n        description='ADB operation duration',\n        metric_type=MetricType.HISTOGRAM,\n        labels=['operation'],\n        buckets=[0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0]\n    )\n\n    # Test Metrics\n    TESTS_TOTAL = MetricDefinition(\n        name='cardlink_tests_total',\n        description='Total tests executed',\n        metric_type=MetricType.COUNTER,\n        labels=['suite_name', 'status']\n    )\n\n    TEST_DURATION_SECONDS = MetricDefinition(\n        name='cardlink_test_duration_seconds',\n        description='Test duration',\n        metric_type=MetricType.HISTOGRAM,\n        labels=['suite_name'],\n        buckets=[0.1, 0.5, 1.0, 5.0, 10.0, 30.0, 60.0, 300.0]\n    )\n\n    # System Metrics\n    PROCESS_CPU_SECONDS = MetricDefinition(\n        name='cardlink_process_cpu_seconds_total',\n        description='Total CPU time used',\n        metric_type=MetricType.COUNTER,\n        labels=[]\n    )\n\n    PROCESS_MEMORY_BYTES = MetricDefinition(\n        name='cardlink_process_memory_bytes',\n        description='Process memory usage',\n        metric_type=MetricType.GAUGE,\n        labels=['type']  # rss, vms\n    )\n\n    DB_CONNECTIONS_ACTIVE = MetricDefinition(\n        name='cardlink_db_connections_active',\n        description='Active database connections',\n        metric_type=MetricType.GAUGE,\n        labels=[]\n    )\n\n    DB_QUERY_DURATION_SECONDS = MetricDefinition(\n        name='cardlink_db_query_duration_seconds',\n        description='Database query duration',\n        metric_type=MetricType.HISTOGRAM,\n        labels=['query_type'],\n        buckets=[0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5]\n    )\n\n    UPTIME_SECONDS = MetricDefinition(\n        name='cardlink_uptime_seconds',\n        description='Application uptime',\n        metric_type=MetricType.GAUGE,\n        labels=[]\n    )\n\n    BUILD_INFO = MetricDefinition(\n        name='cardlink_build_info',\n        description='Build information',\n        metric_type=MetricType.INFO,\n        labels=['version', 'python_version', 'platform']\n    )\n\n\nclass MetricsCollector:\n    \"\"\"Collects and exposes Prometheus metrics.\"\"\"\n\n    def __init__(self, registry: Optional[CollectorRegistry] = None):\n        self._registry = registry or CollectorRegistry()\n        self._metrics: Dict[str, Any] = {}\n        self._server_thread: Optional[threading.Thread] = None\n        self._server_port: Optional[int] = None\n        self._lock = threading.Lock()\n\n        # Register all metrics\n        self._register_metrics()\n\n    def _register_metrics(self) -> None:\n        \"\"\"Register all metric definitions.\"\"\"\n        definitions = [\n            attr for attr in dir(MetricsRegistry)\n            if isinstance(getattr(MetricsRegistry, attr), MetricDefinition)\n        ]\n\n        for def_name in definitions:\n            definition = getattr(MetricsRegistry, def_name)\n            self._create_metric(definition)\n\n    def _create_metric(self, definition: MetricDefinition) -> None:\n        \"\"\"Create metric from definition.\"\"\"\n        if definition.metric_type == MetricType.COUNTER:\n            metric = Counter(\n                definition.name,\n                definition.description,\n                definition.labels,\n                registry=self._registry\n            )\n        elif definition.metric_type == MetricType.HISTOGRAM:\n            metric = Histogram(\n                definition.name,\n                definition.description,\n                definition.labels,\n                buckets=definition.buckets or Histogram.DEFAULT_BUCKETS,\n                registry=self._registry\n            )\n        elif definition.metric_type == MetricType.GAUGE:\n            metric = Gauge(\n                definition.name,\n                definition.description,\n                definition.labels,\n                registry=self._registry\n            )\n        elif definition.metric_type == MetricType.INFO:\n            metric = Info(\n                definition.name,\n                definition.description,\n                registry=self._registry\n            )\n        else:\n            raise ValueError(f\"Unknown metric type: {definition.metric_type}\")\n\n        self._metrics[definition.name] = metric\n\n    def get_metric(self, name: str) -> Any:\n        \"\"\"Get metric by name.\"\"\"\n        return self._metrics.get(name)\n\n    # APDU Metrics\n    def record_apdu_command(self, command_type: str, device_type: str) -> None:\n        \"\"\"Record APDU command sent.\"\"\"\n        self._metrics['cardlink_apdu_commands_total'].labels(\n            command_type=command_type,\n            device_type=device_type\n        ).inc()\n\n    def record_apdu_response(self, status_word: str, status_category: str) -> None:\n        \"\"\"Record APDU response received.\"\"\"\n        self._metrics['cardlink_apdu_responses_total'].labels(\n            status_word=status_word,\n            status_category=status_category\n        ).inc()\n\n    def record_apdu_duration(self, command_type: str, duration: float) -> None:\n        \"\"\"Record APDU command duration.\"\"\"\n        self._metrics['cardlink_apdu_duration_seconds'].labels(\n            command_type=command_type\n        ).observe(duration)\n\n    def record_apdu_bytes(self, direction: str, byte_count: int) -> None:\n        \"\"\"Record APDU bytes transferred.\"\"\"\n        self._metrics['cardlink_apdu_bytes_total'].labels(\n            direction=direction\n        ).inc(byte_count)\n\n    # TLS Metrics\n    def record_tls_handshake(self, result: str, cipher_suite: str,\n                            duration: float) -> None:\n        \"\"\"Record TLS handshake.\"\"\"\n        self._metrics['cardlink_tls_handshakes_total'].labels(\n            result=result,\n            cipher_suite=cipher_suite\n        ).inc()\n        self._metrics['cardlink_tls_handshake_duration_seconds'].labels(\n            result=result\n        ).observe(duration)\n\n    def set_tls_connections(self, count: int) -> None:\n        \"\"\"Set active TLS connection count.\"\"\"\n        self._metrics['cardlink_tls_connections_active'].set(count)\n\n    def inc_tls_connections(self) -> None:\n        \"\"\"Increment TLS connections.\"\"\"\n        self._metrics['cardlink_tls_connections_active'].inc()\n\n    def dec_tls_connections(self) -> None:\n        \"\"\"Decrement TLS connections.\"\"\"\n        self._metrics['cardlink_tls_connections_active'].dec()\n\n    # Session Metrics\n    def set_active_sessions(self, count: int, device_type: str) -> None:\n        \"\"\"Set active session count.\"\"\"\n        self._metrics['cardlink_sessions_active'].labels(\n            device_type=device_type\n        ).set(count)\n\n    def record_session_complete(self, status: str, session_type: str,\n                                device_type: str, duration: float) -> None:\n        \"\"\"Record session completion.\"\"\"\n        self._metrics['cardlink_sessions_total'].labels(\n            status=status,\n            session_type=session_type,\n            device_type=device_type\n        ).inc()\n        self._metrics['cardlink_session_duration_seconds'].labels(\n            status=status\n        ).observe(duration)\n\n    def record_trigger_sent(self, trigger_type: str) -> None:\n        \"\"\"Record trigger sent.\"\"\"\n        self._metrics['cardlink_triggers_sent_total'].labels(\n            trigger_type=trigger_type\n        ).inc()\n\n    # Device Metrics\n    def set_devices_connected(self, count: int, device_type: str) -> None:\n        \"\"\"Set connected device count.\"\"\"\n        self._metrics['cardlink_devices_connected'].labels(\n            device_type=device_type\n        ).set(count)\n\n    def record_device_error(self, device_type: str, error_type: str) -> None:\n        \"\"\"Record device error.\"\"\"\n        self._metrics['cardlink_device_errors_total'].labels(\n            device_type=device_type,\n            error_type=error_type\n        ).inc()\n\n    def record_at_command_duration(self, command: str, duration: float) -> None:\n        \"\"\"Record AT command duration.\"\"\"\n        self._metrics['cardlink_at_command_duration_seconds'].labels(\n            command=command\n        ).observe(duration)\n\n    def record_adb_operation_duration(self, operation: str,\n                                      duration: float) -> None:\n        \"\"\"Record ADB operation duration.\"\"\"\n        self._metrics['cardlink_adb_operation_duration_seconds'].labels(\n            operation=operation\n        ).observe(duration)\n\n    # Test Metrics\n    def record_test_result(self, suite_name: str, status: str,\n                          duration: float) -> None:\n        \"\"\"Record test result.\"\"\"\n        self._metrics['cardlink_tests_total'].labels(\n            suite_name=suite_name,\n            status=status\n        ).inc()\n        self._metrics['cardlink_test_duration_seconds'].labels(\n            suite_name=suite_name\n        ).observe(duration)\n\n    # System Metrics\n    def update_system_metrics(self) -> None:\n        \"\"\"Update system resource metrics.\"\"\"\n        import psutil\n        import time\n\n        process = psutil.Process()\n\n        # CPU\n        cpu_times = process.cpu_times()\n        # Note: This should be set, not inc, for total CPU time\n        # Using a custom approach for CPU counter\n\n        # Memory\n        memory_info = process.memory_info()\n        self._metrics['cardlink_process_memory_bytes'].labels(\n            type='rss'\n        ).set(memory_info.rss)\n        self._metrics['cardlink_process_memory_bytes'].labels(\n            type='vms'\n        ).set(memory_info.vms)\n\n    def set_build_info(self, version: str, python_version: str,\n                      platform: str) -> None:\n        \"\"\"Set build information.\"\"\"\n        self._metrics['cardlink_build_info'].info({\n            'version': version,\n            'python_version': python_version,\n            'platform': platform\n        })\n\n    def start_server(self, port: int = 9090, path: str = '/metrics') -> None:\n        \"\"\"Start metrics HTTP server.\"\"\"\n        from http.server import HTTPServer, BaseHTTPRequestHandler\n\n        registry = self._registry\n\n        class MetricsHandler(BaseHTTPRequestHandler):\n            def do_GET(self):\n                if self.path == path or self.path == path + '/':\n                    output = generate_latest(registry)\n                    self.send_response(200)\n                    self.send_header('Content-Type', CONTENT_TYPE_LATEST)\n                    self.end_headers()\n                    self.wfile.write(output)\n                else:\n                    self.send_response(404)\n                    self.end_headers()\n\n            def log_message(self, format, *args):\n                pass  # Suppress logging\n\n        def serve():\n            server = HTTPServer(('', port), MetricsHandler)\n            server.serve_forever()\n\n        self._server_port = port\n        self._server_thread = threading.Thread(target=serve, daemon=True)\n        self._server_thread.start()\n\n    def stop_server(self) -> None:\n        \"\"\"Stop metrics server.\"\"\"\n        # Note: Simple implementation - thread is daemon so will stop with app\n        pass\n\n    def get_metrics_text(self) -> str:\n        \"\"\"Get metrics in Prometheus text format.\"\"\"\n        return generate_latest(self._registry).decode('utf-8')\n```\n\n### 3. TracingProvider\n\nOpenTelemetry tracing integration.\n\n```python\nfrom opentelemetry import trace\nfrom opentelemetry.sdk.trace import TracerProvider\nfrom opentelemetry.sdk.trace.export import BatchSpanProcessor\nfrom opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter as GrpcExporter\nfrom opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter as HttpExporter\nfrom opentelemetry.sdk.resources import Resource, SERVICE_NAME, SERVICE_VERSION\nfrom opentelemetry.trace import Span, SpanKind, Status, StatusCode\nfrom opentelemetry.trace.propagation.tracecontext import TraceContextTextMapPropagator\nfrom typing import Optional, Dict, Any, Callable\nfrom contextlib import contextmanager\nfrom functools import wraps\nimport threading\n\nclass TracingProvider:\n    \"\"\"OpenTelemetry tracing provider.\"\"\"\n\n    def __init__(self,\n                 service_name: str = 'cardlink',\n                 service_version: str = '1.0.0',\n                 otlp_endpoint: Optional[str] = None,\n                 otlp_protocol: str = 'grpc'):\n        self.service_name = service_name\n        self.service_version = service_version\n        self.otlp_endpoint = otlp_endpoint\n        self.otlp_protocol = otlp_protocol\n        self._provider: Optional[TracerProvider] = None\n        self._tracer: Optional[trace.Tracer] = None\n        self._propagator = TraceContextTextMapPropagator()\n\n    def initialize(self) -> None:\n        \"\"\"Initialize tracing provider.\"\"\"\n        resource = Resource.create({\n            SERVICE_NAME: self.service_name,\n            SERVICE_VERSION: self.service_version\n        })\n\n        self._provider = TracerProvider(resource=resource)\n\n        if self.otlp_endpoint:\n            if self.otlp_protocol == 'grpc':\n                exporter = GrpcExporter(endpoint=self.otlp_endpoint)\n            else:\n                exporter = HttpExporter(endpoint=self.otlp_endpoint)\n\n            processor = BatchSpanProcessor(exporter)\n            self._provider.add_span_processor(processor)\n\n        trace.set_tracer_provider(self._provider)\n        self._tracer = trace.get_tracer(self.service_name, self.service_version)\n\n    def shutdown(self) -> None:\n        \"\"\"Shutdown tracing provider.\"\"\"\n        if self._provider:\n            self._provider.shutdown()\n\n    def get_tracer(self) -> trace.Tracer:\n        \"\"\"Get tracer instance.\"\"\"\n        if not self._tracer:\n            raise RuntimeError(\"Tracing not initialized\")\n        return self._tracer\n\n    @contextmanager\n    def start_span(self, name: str, kind: SpanKind = SpanKind.INTERNAL,\n                   attributes: Optional[Dict[str, Any]] = None):\n        \"\"\"Start a new span.\"\"\"\n        with self._tracer.start_as_current_span(\n            name,\n            kind=kind,\n            attributes=attributes or {}\n        ) as span:\n            yield span\n\n    def current_span(self) -> Optional[Span]:\n        \"\"\"Get current span.\"\"\"\n        return trace.get_current_span()\n\n    def inject_context(self, carrier: Dict[str, str]) -> None:\n        \"\"\"Inject trace context into carrier.\"\"\"\n        self._propagator.inject(carrier)\n\n    def extract_context(self, carrier: Dict[str, str]):\n        \"\"\"Extract trace context from carrier.\"\"\"\n        return self._propagator.extract(carrier)\n\n    def trace_decorator(self, name: Optional[str] = None,\n                       kind: SpanKind = SpanKind.INTERNAL):\n        \"\"\"Decorator to trace a function.\"\"\"\n        def decorator(func: Callable):\n            span_name = name or func.__name__\n\n            @wraps(func)\n            def wrapper(*args, **kwargs):\n                with self.start_span(span_name, kind=kind) as span:\n                    try:\n                        result = func(*args, **kwargs)\n                        span.set_status(Status(StatusCode.OK))\n                        return result\n                    except Exception as e:\n                        span.set_status(Status(StatusCode.ERROR, str(e)))\n                        span.record_exception(e)\n                        raise\n\n            return wrapper\n        return decorator\n\n\nclass SpanManager:\n    \"\"\"Manages trace spans for CardLink operations.\"\"\"\n\n    def __init__(self, tracing_provider: TracingProvider):\n        self._provider = tracing_provider\n\n    @contextmanager\n    def apdu_span(self, command_type: str, device_id: str):\n        \"\"\"Create span for APDU operation.\"\"\"\n        attributes = {\n            'apdu.command_type': command_type,\n            'device.id': device_id\n        }\n        with self._provider.start_span(\n            f'apdu.{command_type}',\n            kind=SpanKind.CLIENT,\n            attributes=attributes\n        ) as span:\n            yield span\n\n    @contextmanager\n    def tls_handshake_span(self, client_address: str):\n        \"\"\"Create span for TLS handshake.\"\"\"\n        attributes = {\n            'tls.client_address': client_address\n        }\n        with self._provider.start_span(\n            'tls.handshake',\n            kind=SpanKind.SERVER,\n            attributes=attributes\n        ) as span:\n            yield span\n\n    @contextmanager\n    def session_span(self, session_id: str, session_type: str):\n        \"\"\"Create span for OTA session.\"\"\"\n        attributes = {\n            'session.id': session_id,\n            'session.type': session_type\n        }\n        with self._provider.start_span(\n            'ota.session',\n            kind=SpanKind.INTERNAL,\n            attributes=attributes\n        ) as span:\n            yield span\n\n    @contextmanager\n    def db_span(self, operation: str, table: str):\n        \"\"\"Create span for database operation.\"\"\"\n        attributes = {\n            'db.operation': operation,\n            'db.table': table\n        }\n        with self._provider.start_span(\n            f'db.{operation}',\n            kind=SpanKind.CLIENT,\n            attributes=attributes\n        ) as span:\n            yield span\n\n    @contextmanager\n    def test_span(self, suite_name: str, test_name: str):\n        \"\"\"Create span for test execution.\"\"\"\n        attributes = {\n            'test.suite': suite_name,\n            'test.name': test_name\n        }\n        with self._provider.start_span(\n            f'test.{test_name}',\n            kind=SpanKind.INTERNAL,\n            attributes=attributes\n        ) as span:\n            yield span\n\n    def add_apdu_response(self, span: Span, status_word: str,\n                         duration_ms: float) -> None:\n        \"\"\"Add APDU response attributes to span.\"\"\"\n        span.set_attribute('apdu.status_word', status_word)\n        span.set_attribute('apdu.duration_ms', duration_ms)\n\n        if not status_word.startswith('90'):\n            span.set_status(Status(StatusCode.ERROR, f\"APDU error: {status_word}\"))\n```\n\n### 4. HealthChecker\n\nHealth check implementation.\n\n```python\nfrom dataclasses import dataclass, asdict\nfrom typing import Dict, List, Callable, Optional, Any\nfrom enum import Enum\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nimport threading\nimport json\nimport time\n\nclass HealthStatus(Enum):\n    HEALTHY = 'healthy'\n    UNHEALTHY = 'unhealthy'\n    DEGRADED = 'degraded'\n\n\n@dataclass\nclass HealthCheckResult:\n    \"\"\"Result of a health check.\"\"\"\n    name: str\n    status: HealthStatus\n    message: Optional[str] = None\n    duration_ms: Optional[float] = None\n    details: Optional[Dict[str, Any]] = None\n\n\n@dataclass\nclass OverallHealth:\n    \"\"\"Overall health status.\"\"\"\n    status: HealthStatus\n    checks: List[HealthCheckResult]\n    timestamp: str\n\n\nclass HealthChecker:\n    \"\"\"Performs health checks on components.\"\"\"\n\n    def __init__(self):\n        self._checks: Dict[str, Callable[[], HealthCheckResult]] = {}\n        self._server_thread: Optional[threading.Thread] = None\n        self._server: Optional[HTTPServer] = None\n\n    def register_check(self, name: str,\n                      check_fn: Callable[[], HealthCheckResult]) -> None:\n        \"\"\"Register a health check.\"\"\"\n        self._checks[name] = check_fn\n\n    def unregister_check(self, name: str) -> None:\n        \"\"\"Unregister a health check.\"\"\"\n        self._checks.pop(name, None)\n\n    def run_check(self, name: str) -> HealthCheckResult:\n        \"\"\"Run a specific health check.\"\"\"\n        if name not in self._checks:\n            return HealthCheckResult(\n                name=name,\n                status=HealthStatus.UNHEALTHY,\n                message='Check not found'\n            )\n\n        start_time = time.time()\n        try:\n            result = self._checks[name]()\n            result.duration_ms = (time.time() - start_time) * 1000\n            return result\n        except Exception as e:\n            return HealthCheckResult(\n                name=name,\n                status=HealthStatus.UNHEALTHY,\n                message=str(e),\n                duration_ms=(time.time() - start_time) * 1000\n            )\n\n    def run_all_checks(self) -> OverallHealth:\n        \"\"\"Run all health checks.\"\"\"\n        results = []\n        overall_status = HealthStatus.HEALTHY\n\n        for name in self._checks:\n            result = self.run_check(name)\n            results.append(result)\n\n            if result.status == HealthStatus.UNHEALTHY:\n                overall_status = HealthStatus.UNHEALTHY\n            elif result.status == HealthStatus.DEGRADED and overall_status == HealthStatus.HEALTHY:\n                overall_status = HealthStatus.DEGRADED\n\n        return OverallHealth(\n            status=overall_status,\n            checks=results,\n            timestamp=time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())\n        )\n\n    def check_liveness(self) -> HealthCheckResult:\n        \"\"\"Basic liveness check.\"\"\"\n        return HealthCheckResult(\n            name='liveness',\n            status=HealthStatus.HEALTHY,\n            message='Application is running'\n        )\n\n    def check_readiness(self) -> OverallHealth:\n        \"\"\"Readiness check (all components).\"\"\"\n        return self.run_all_checks()\n\n    def start_server(self, port: int = 8081) -> None:\n        \"\"\"Start health check HTTP server.\"\"\"\n        checker = self\n\n        class HealthHandler(BaseHTTPRequestHandler):\n            def do_GET(self):\n                if self.path == '/health' or self.path == '/health/':\n                    self._handle_health()\n                elif self.path == '/health/live':\n                    self._handle_live()\n                elif self.path == '/health/ready':\n                    self._handle_ready()\n                else:\n                    self.send_response(404)\n                    self.end_headers()\n\n            def _handle_health(self):\n                health = checker.run_all_checks()\n                status_code = 200 if health.status == HealthStatus.HEALTHY else 503\n                self._send_json(status_code, self._health_to_dict(health))\n\n            def _handle_live(self):\n                result = checker.check_liveness()\n                status_code = 200 if result.status == HealthStatus.HEALTHY else 503\n                self._send_json(status_code, asdict(result))\n\n            def _handle_ready(self):\n                health = checker.check_readiness()\n                status_code = 200 if health.status == HealthStatus.HEALTHY else 503\n                self._send_json(status_code, self._health_to_dict(health))\n\n            def _send_json(self, status_code: int, data: dict):\n                self.send_response(status_code)\n                self.send_header('Content-Type', 'application/json')\n                self.end_headers()\n                self.wfile.write(json.dumps(data).encode())\n\n            def _health_to_dict(self, health: OverallHealth) -> dict:\n                return {\n                    'status': health.status.value,\n                    'timestamp': health.timestamp,\n                    'checks': [asdict(c) for c in health.checks]\n                }\n\n            def log_message(self, format, *args):\n                pass\n\n        def serve():\n            self._server = HTTPServer(('', port), HealthHandler)\n            self._server.serve_forever()\n\n        self._server_thread = threading.Thread(target=serve, daemon=True)\n        self._server_thread.start()\n\n    def stop_server(self) -> None:\n        \"\"\"Stop health check server.\"\"\"\n        if self._server:\n            self._server.shutdown()\n\n\n# Pre-defined health checks\ndef create_database_check(db_manager) -> Callable[[], HealthCheckResult]:\n    \"\"\"Create database health check.\"\"\"\n    def check() -> HealthCheckResult:\n        try:\n            health = db_manager.health_check()\n            if health['status'] == 'healthy':\n                return HealthCheckResult(\n                    name='database',\n                    status=HealthStatus.HEALTHY,\n                    message='Database connection OK',\n                    details=health\n                )\n            else:\n                return HealthCheckResult(\n                    name='database',\n                    status=HealthStatus.UNHEALTHY,\n                    message=health.get('error', 'Unknown error'),\n                    details=health\n                )\n        except Exception as e:\n            return HealthCheckResult(\n                name='database',\n                status=HealthStatus.UNHEALTHY,\n                message=str(e)\n            )\n    return check\n\n\ndef create_metrics_check(metrics_port: int) -> Callable[[], HealthCheckResult]:\n    \"\"\"Create metrics endpoint health check.\"\"\"\n    def check() -> HealthCheckResult:\n        import urllib.request\n        try:\n            url = f'http://localhost:{metrics_port}/metrics'\n            with urllib.request.urlopen(url, timeout=5) as response:\n                if response.status == 200:\n                    return HealthCheckResult(\n                        name='metrics',\n                        status=HealthStatus.HEALTHY,\n                        message='Metrics endpoint responding'\n                    )\n        except Exception as e:\n            return HealthCheckResult(\n                name='metrics',\n                status=HealthStatus.UNHEALTHY,\n                message=str(e)\n            )\n    return check\n```\n\n### 5. StructuredLogger\n\nStructured logging with trace correlation.\n\n```python\nimport logging\nimport json\nimport sys\nfrom typing import Optional, Dict, Any\nfrom datetime import datetime\nfrom opentelemetry import trace\n\nclass StructuredFormatter(logging.Formatter):\n    \"\"\"JSON formatter with trace correlation.\"\"\"\n\n    def __init__(self, include_trace: bool = True):\n        super().__init__()\n        self.include_trace = include_trace\n\n    def format(self, record: logging.LogRecord) -> str:\n        log_data = {\n            'timestamp': datetime.utcnow().isoformat() + 'Z',\n            'level': record.levelname,\n            'logger': record.name,\n            'message': record.getMessage(),\n            'module': record.module,\n            'function': record.funcName,\n            'line': record.lineno\n        }\n\n        # Add trace context if available\n        if self.include_trace:\n            span = trace.get_current_span()\n            if span and span.is_recording():\n                ctx = span.get_span_context()\n                log_data['trace_id'] = format(ctx.trace_id, '032x')\n                log_data['span_id'] = format(ctx.span_id, '016x')\n\n        # Add extra fields\n        if hasattr(record, 'extra_fields'):\n            log_data.update(record.extra_fields)\n\n        # Add exception info\n        if record.exc_info:\n            log_data['exception'] = self.formatException(record.exc_info)\n\n        return json.dumps(log_data)\n\n\nclass StructuredLogger:\n    \"\"\"Structured logger with trace correlation.\"\"\"\n\n    def __init__(self,\n                 level: str = 'INFO',\n                 format: str = 'json',\n                 trace_correlation: bool = True):\n        self.level = getattr(logging, level.upper())\n        self.format = format\n        self.trace_correlation = trace_correlation\n        self._loggers: Dict[str, logging.Logger] = {}\n\n        # Configure root logger\n        self._configure_root()\n\n    def _configure_root(self) -> None:\n        \"\"\"Configure root logger.\"\"\"\n        root = logging.getLogger()\n        root.setLevel(self.level)\n\n        # Remove existing handlers\n        for handler in root.handlers[:]:\n            root.removeHandler(handler)\n\n        # Add structured handler\n        handler = logging.StreamHandler(sys.stdout)\n        handler.setLevel(self.level)\n\n        if self.format == 'json':\n            handler.setFormatter(StructuredFormatter(\n                include_trace=self.trace_correlation\n            ))\n        else:\n            handler.setFormatter(logging.Formatter(\n                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n            ))\n\n        root.addHandler(handler)\n\n    def get_logger(self, name: str) -> logging.Logger:\n        \"\"\"Get logger for component.\"\"\"\n        if name not in self._loggers:\n            logger = logging.getLogger(name)\n            self._loggers[name] = logger\n        return self._loggers[name]\n\n    def set_level(self, name: str, level: str) -> None:\n        \"\"\"Set log level for component.\"\"\"\n        logger = self.get_logger(name)\n        logger.setLevel(getattr(logging, level.upper()))\n\n\nclass ComponentLogger:\n    \"\"\"Logger for a specific component with context.\"\"\"\n\n    def __init__(self, name: str, structured_logger: StructuredLogger):\n        self._logger = structured_logger.get_logger(name)\n        self._context: Dict[str, Any] = {}\n\n    def with_context(self, **kwargs) -> 'ComponentLogger':\n        \"\"\"Create logger with additional context.\"\"\"\n        new_logger = ComponentLogger.__new__(ComponentLogger)\n        new_logger._logger = self._logger\n        new_logger._context = {**self._context, **kwargs}\n        return new_logger\n\n    def _log(self, level: int, message: str, **kwargs) -> None:\n        \"\"\"Internal log method.\"\"\"\n        extra = {'extra_fields': {**self._context, **kwargs}}\n        self._logger.log(level, message, extra=extra)\n\n    def debug(self, message: str, **kwargs) -> None:\n        self._log(logging.DEBUG, message, **kwargs)\n\n    def info(self, message: str, **kwargs) -> None:\n        self._log(logging.INFO, message, **kwargs)\n\n    def warning(self, message: str, **kwargs) -> None:\n        self._log(logging.WARNING, message, **kwargs)\n\n    def error(self, message: str, **kwargs) -> None:\n        self._log(logging.ERROR, message, **kwargs)\n\n    def exception(self, message: str, **kwargs) -> None:\n        self._logger.exception(message, extra={'extra_fields': {**self._context, **kwargs}})\n```\n\n### 6. Grafana Dashboard Templates\n\nDashboard JSON templates.\n\n```python\nfrom typing import Dict, Any\nimport json\n\nclass DashboardTemplates:\n    \"\"\"Grafana dashboard templates.\"\"\"\n\n    @staticmethod\n    def ota_overview() -> Dict[str, Any]:\n        \"\"\"OTA Overview dashboard.\"\"\"\n        return {\n            \"title\": \"CardLink - OTA Overview\",\n            \"uid\": \"cardlink-ota-overview\",\n            \"panels\": [\n                {\n                    \"title\": \"Active Sessions\",\n                    \"type\": \"gauge\",\n                    \"targets\": [{\n                        \"expr\": \"sum(cardlink_sessions_active)\"\n                    }],\n                    \"gridPos\": {\"x\": 0, \"y\": 0, \"w\": 6, \"h\": 6}\n                },\n                {\n                    \"title\": \"Session Success Rate\",\n                    \"type\": \"gauge\",\n                    \"targets\": [{\n                        \"expr\": \"sum(rate(cardlink_sessions_total{status='completed'}[5m])) / sum(rate(cardlink_sessions_total[5m])) * 100\"\n                    }],\n                    \"gridPos\": {\"x\": 6, \"y\": 0, \"w\": 6, \"h\": 6}\n                },\n                {\n                    \"title\": \"Sessions Over Time\",\n                    \"type\": \"timeseries\",\n                    \"targets\": [{\n                        \"expr\": \"sum by (status) (rate(cardlink_sessions_total[5m]))\",\n                        \"legendFormat\": \"{{status}}\"\n                    }],\n                    \"gridPos\": {\"x\": 0, \"y\": 6, \"w\": 12, \"h\": 8}\n                },\n                {\n                    \"title\": \"Session Duration (p95)\",\n                    \"type\": \"timeseries\",\n                    \"targets\": [{\n                        \"expr\": \"histogram_quantile(0.95, sum(rate(cardlink_session_duration_seconds_bucket[5m])) by (le))\"\n                    }],\n                    \"gridPos\": {\"x\": 12, \"y\": 0, \"w\": 12, \"h\": 8}\n                },\n                {\n                    \"title\": \"Triggers Sent\",\n                    \"type\": \"stat\",\n                    \"targets\": [{\n                        \"expr\": \"sum(increase(cardlink_triggers_sent_total[1h]))\"\n                    }],\n                    \"gridPos\": {\"x\": 12, \"y\": 8, \"w\": 6, \"h\": 6}\n                }\n            ]\n        }\n\n    @staticmethod\n    def apdu_analysis() -> Dict[str, Any]:\n        \"\"\"APDU Analysis dashboard.\"\"\"\n        return {\n            \"title\": \"CardLink - APDU Analysis\",\n            \"uid\": \"cardlink-apdu-analysis\",\n            \"panels\": [\n                {\n                    \"title\": \"Command Distribution\",\n                    \"type\": \"piechart\",\n                    \"targets\": [{\n                        \"expr\": \"sum by (command_type) (increase(cardlink_apdu_commands_total[1h]))\",\n                        \"legendFormat\": \"{{command_type}}\"\n                    }],\n                    \"gridPos\": {\"x\": 0, \"y\": 0, \"w\": 8, \"h\": 8}\n                },\n                {\n                    \"title\": \"Response Status\",\n                    \"type\": \"piechart\",\n                    \"targets\": [{\n                        \"expr\": \"sum by (status_category) (increase(cardlink_apdu_responses_total[1h]))\",\n                        \"legendFormat\": \"{{status_category}}\"\n                    }],\n                    \"gridPos\": {\"x\": 8, \"y\": 0, \"w\": 8, \"h\": 8}\n                },\n                {\n                    \"title\": \"APDU Latency Percentiles\",\n                    \"type\": \"timeseries\",\n                    \"targets\": [\n                        {\n                            \"expr\": \"histogram_quantile(0.50, sum(rate(cardlink_apdu_duration_seconds_bucket[5m])) by (le))\",\n                            \"legendFormat\": \"p50\"\n                        },\n                        {\n                            \"expr\": \"histogram_quantile(0.95, sum(rate(cardlink_apdu_duration_seconds_bucket[5m])) by (le))\",\n                            \"legendFormat\": \"p95\"\n                        },\n                        {\n                            \"expr\": \"histogram_quantile(0.99, sum(rate(cardlink_apdu_duration_seconds_bucket[5m])) by (le))\",\n                            \"legendFormat\": \"p99\"\n                        }\n                    ],\n                    \"gridPos\": {\"x\": 0, \"y\": 8, \"w\": 12, \"h\": 8}\n                },\n                {\n                    \"title\": \"Error Rate\",\n                    \"type\": \"timeseries\",\n                    \"targets\": [{\n                        \"expr\": \"sum(rate(cardlink_apdu_responses_total{status_category='error'}[5m])) / sum(rate(cardlink_apdu_responses_total[5m])) * 100\"\n                    }],\n                    \"gridPos\": {\"x\": 12, \"y\": 8, \"w\": 12, \"h\": 8}\n                }\n            ]\n        }\n\n    @staticmethod\n    def device_status() -> Dict[str, Any]:\n        \"\"\"Device Status dashboard.\"\"\"\n        return {\n            \"title\": \"CardLink - Device Status\",\n            \"uid\": \"cardlink-device-status\",\n            \"panels\": [\n                {\n                    \"title\": \"Connected Devices\",\n                    \"type\": \"stat\",\n                    \"targets\": [{\n                        \"expr\": \"sum(cardlink_devices_connected)\"\n                    }],\n                    \"gridPos\": {\"x\": 0, \"y\": 0, \"w\": 6, \"h\": 4}\n                },\n                {\n                    \"title\": \"Phones Connected\",\n                    \"type\": \"stat\",\n                    \"targets\": [{\n                        \"expr\": \"cardlink_devices_connected{device_type='phone'}\"\n                    }],\n                    \"gridPos\": {\"x\": 6, \"y\": 0, \"w\": 6, \"h\": 4}\n                },\n                {\n                    \"title\": \"Modems Connected\",\n                    \"type\": \"stat\",\n                    \"targets\": [{\n                        \"expr\": \"cardlink_devices_connected{device_type='modem'}\"\n                    }],\n                    \"gridPos\": {\"x\": 12, \"y\": 0, \"w\": 6, \"h\": 4}\n                },\n                {\n                    \"title\": \"Device Errors\",\n                    \"type\": \"timeseries\",\n                    \"targets\": [{\n                        \"expr\": \"sum by (device_type, error_type) (rate(cardlink_device_errors_total[5m]))\",\n                        \"legendFormat\": \"{{device_type}} - {{error_type}}\"\n                    }],\n                    \"gridPos\": {\"x\": 0, \"y\": 4, \"w\": 12, \"h\": 8}\n                },\n                {\n                    \"title\": \"AT Command Latency\",\n                    \"type\": \"timeseries\",\n                    \"targets\": [{\n                        \"expr\": \"histogram_quantile(0.95, sum(rate(cardlink_at_command_duration_seconds_bucket[5m])) by (le, command))\",\n                        \"legendFormat\": \"{{command}}\"\n                    }],\n                    \"gridPos\": {\"x\": 12, \"y\": 4, \"w\": 12, \"h\": 8}\n                }\n            ]\n        }\n\n    @staticmethod\n    def test_results() -> Dict[str, Any]:\n        \"\"\"Test Results dashboard.\"\"\"\n        return {\n            \"title\": \"CardLink - Test Results\",\n            \"uid\": \"cardlink-test-results\",\n            \"panels\": [\n                {\n                    \"title\": \"Test Pass Rate\",\n                    \"type\": \"gauge\",\n                    \"targets\": [{\n                        \"expr\": \"sum(rate(cardlink_tests_total{status='passed'}[1h])) / sum(rate(cardlink_tests_total[1h])) * 100\"\n                    }],\n                    \"gridPos\": {\"x\": 0, \"y\": 0, \"w\": 8, \"h\": 6}\n                },\n                {\n                    \"title\": \"Tests by Status\",\n                    \"type\": \"piechart\",\n                    \"targets\": [{\n                        \"expr\": \"sum by (status) (increase(cardlink_tests_total[1h]))\",\n                        \"legendFormat\": \"{{status}}\"\n                    }],\n                    \"gridPos\": {\"x\": 8, \"y\": 0, \"w\": 8, \"h\": 6}\n                },\n                {\n                    \"title\": \"Test Duration Trend\",\n                    \"type\": \"timeseries\",\n                    \"targets\": [{\n                        \"expr\": \"histogram_quantile(0.95, sum(rate(cardlink_test_duration_seconds_bucket[5m])) by (le, suite_name))\",\n                        \"legendFormat\": \"{{suite_name}}\"\n                    }],\n                    \"gridPos\": {\"x\": 0, \"y\": 6, \"w\": 24, \"h\": 8}\n                }\n            ]\n        }\n\n    @staticmethod\n    def export_all(output_dir: str) -> None:\n        \"\"\"Export all dashboards to files.\"\"\"\n        import os\n\n        os.makedirs(output_dir, exist_ok=True)\n\n        dashboards = {\n            'ota-overview.json': DashboardTemplates.ota_overview(),\n            'apdu-analysis.json': DashboardTemplates.apdu_analysis(),\n            'device-status.json': DashboardTemplates.device_status(),\n            'test-results.json': DashboardTemplates.test_results()\n        }\n\n        for filename, dashboard in dashboards.items():\n            path = os.path.join(output_dir, filename)\n            with open(path, 'w') as f:\n                json.dump(dashboard, f, indent=2)\n```\n\n### 7. Alerting Rules\n\nPrometheus alerting rules.\n\n```python\nfrom typing import Dict, Any, List\nimport yaml\n\nclass AlertingRules:\n    \"\"\"Prometheus alerting rule definitions.\"\"\"\n\n    @staticmethod\n    def get_rules() -> Dict[str, Any]:\n        \"\"\"Get all alerting rules.\"\"\"\n        return {\n            'groups': [\n                {\n                    'name': 'cardlink.errors',\n                    'rules': [\n                        {\n                            'alert': 'HighAPDUErrorRate',\n                            'expr': 'sum(rate(cardlink_apdu_responses_total{status_category=\"error\"}[5m])) / sum(rate(cardlink_apdu_responses_total[5m])) > 0.05',\n                            'for': '5m',\n                            'labels': {'severity': 'warning'},\n                            'annotations': {\n                                'summary': 'High APDU error rate',\n                                'description': 'APDU error rate is above 5% for the last 5 minutes'\n                            }\n                        },\n                        {\n                            'alert': 'SessionTimeoutSpike',\n                            'expr': 'sum(rate(cardlink_sessions_total{status=\"timeout\"}[5m])) > 0.1',\n                            'for': '5m',\n                            'labels': {'severity': 'warning'},\n                            'annotations': {\n                                'summary': 'Session timeout spike',\n                                'description': 'Session timeout rate has increased significantly'\n                            }\n                        },\n                        {\n                            'alert': 'TLSHandshakeFailures',\n                            'expr': 'sum(rate(cardlink_tls_handshakes_total{result=\"failed\"}[5m])) > 0',\n                            'for': '2m',\n                            'labels': {'severity': 'critical'},\n                            'annotations': {\n                                'summary': 'TLS handshake failures detected',\n                                'description': 'TLS handshakes are failing'\n                            }\n                        },\n                        {\n                            'alert': 'DeviceDisconnected',\n                            'expr': 'cardlink_devices_connected == 0',\n                            'for': '1m',\n                            'labels': {'severity': 'warning'},\n                            'annotations': {\n                                'summary': 'No devices connected',\n                                'description': 'No test devices are currently connected'\n                            }\n                        },\n                        {\n                            'alert': 'DatabaseConnectionFailure',\n                            'expr': 'cardlink_db_connections_active == 0',\n                            'for': '1m',\n                            'labels': {'severity': 'critical'},\n                            'annotations': {\n                                'summary': 'Database connection failure',\n                                'description': 'Unable to connect to database'\n                            }\n                        }\n                    ]\n                },\n                {\n                    'name': 'cardlink.performance',\n                    'rules': [\n                        {\n                            'alert': 'HighAPDULatency',\n                            'expr': 'histogram_quantile(0.95, sum(rate(cardlink_apdu_duration_seconds_bucket[5m])) by (le)) > 1',\n                            'for': '5m',\n                            'labels': {'severity': 'warning'},\n                            'annotations': {\n                                'summary': 'High APDU latency',\n                                'description': 'P95 APDU latency is above 1 second'\n                            }\n                        },\n                        {\n                            'alert': 'LongSessionDuration',\n                            'expr': 'histogram_quantile(0.95, sum(rate(cardlink_session_duration_seconds_bucket[5m])) by (le)) > 60',\n                            'for': '10m',\n                            'labels': {'severity': 'warning'},\n                            'annotations': {\n                                'summary': 'Long session duration',\n                                'description': 'P95 session duration exceeds 60 seconds'\n                            }\n                        }\n                    ]\n                }\n            ]\n        }\n\n    @staticmethod\n    def export_yaml(output_path: str) -> None:\n        \"\"\"Export rules as YAML file.\"\"\"\n        rules = AlertingRules.get_rules()\n        with open(output_path, 'w') as f:\n            yaml.dump(rules, f, default_flow_style=False)\n```\n\n## CLI Design\n\n### Command Structure\n\n```\ncardlink-metrics\n├── status                  # Show metrics summary\n│   └── --json             # JSON output\n├── export                  # Export all metrics\n│   ├── --format <fmt>     # prometheus or json\n│   └── --output <file>    # Output file\n├── health                  # Show health status\n│   └── --verbose          # Include all check details\n├── config                  # View/update config\n│   ├── show               # Show current config\n│   └── set <key> <value>  # Update config\n├── test                    # Test connectivity\n│   └── --otlp             # Test OTLP endpoint\n└── dashboards             # Dashboard management\n    └── export <dir>       # Export Grafana dashboards\n```\n\n## Dependencies\n\n### Required Packages\n\n```\nprometheus-client>=0.17.0      # Prometheus metrics\nopentelemetry-api>=1.20.0      # OpenTelemetry API\nopentelemetry-sdk>=1.20.0      # OpenTelemetry SDK\nopentelemetry-exporter-otlp>=1.20.0  # OTLP exporter\npsutil>=5.9.0                  # System metrics\npyyaml>=6.0                    # YAML export\n```\n\n### Optional Packages\n\n```\nopentelemetry-exporter-jaeger  # Jaeger export\nopentelemetry-exporter-zipkin  # Zipkin export\n```\n",
  "fileStats": {
    "size": 59838,
    "lines": 1587,
    "lastModified": "2025-11-25T12:02:04.153Z"
  },
  "comments": []
}