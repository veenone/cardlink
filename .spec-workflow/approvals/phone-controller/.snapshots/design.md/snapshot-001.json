{
  "id": "snapshot_1764068974096_fyg0zrgsm",
  "approvalId": "approval_1764068974085_2zokcmwg4",
  "approvalTitle": "Phone Controller Design Document",
  "version": 1,
  "timestamp": "2025-11-25T11:09:34.096Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document: Phone Controller\n\n## Technical Approach\n\n### Overview\n\nThe Phone Controller is implemented as a Python module that interfaces with Android devices via ADB (Android Debug Bridge). It provides device management, AT command execution, BIP event monitoring, and SMS-PP trigger capabilities through a layered architecture that separates low-level ADB communication from high-level device operations.\n\n### Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                            Phone Controller                                  │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                                                                              │\n│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐         │\n│  │   CLI Entry     │───▶│ PhoneController │───▶│  EventEmitter   │         │\n│  │   (Click)       │    │   (Main Class)  │    │  (Pub/Sub)      │         │\n│  └─────────────────┘    └────────┬────────┘    └─────────────────┘         │\n│                                  │                                          │\n│              ┌───────────────────┼───────────────────┐                     │\n│              │                   │                   │                     │\n│              ▼                   ▼                   ▼                     │\n│   ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐             │\n│   │  DeviceManager  │ │   ATInterface   │ │  BIPMonitor     │             │\n│   │  (Discovery)    │ │  (AT Commands)  │ │  (Logcat)       │             │\n│   └────────┬────────┘ └────────┬────────┘ └────────┬────────┘             │\n│            │                   │                   │                       │\n│            │                   │                   │                       │\n│            ▼                   ▼                   ▼                       │\n│   ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐             │\n│   │  DeviceInfo     │ │  SMSTrigger     │ │  LogcatParser   │             │\n│   │  (Profiling)    │ │  (PDU Encode)   │ │  (Event Parse)  │             │\n│   └─────────────────┘ └─────────────────┘ └─────────────────┘             │\n│                                                                              │\n│   ┌─────────────────────────────────────────────────────────────────────┐   │\n│   │                         ADBClient                                    │   │\n│   │              (Low-level ADB Communication)                           │   │\n│   └─────────────────────────────────────────────────────────────────────┘   │\n│                                                                              │\n└─────────────────────────────────────────────────────────────────────────────┘\n                                      │\n                                      ▼\n                            ┌─────────────────┐\n                            │  Android Device │\n                            │   (via USB)     │\n                            └─────────────────┘\n```\n\n### Key Design Decisions\n\n1. **ADB as Primary Interface**: Use ADB for all device communication as it's the standard Android debugging interface, available without root for most operations.\n\n2. **Subprocess-Based ADB**: Execute ADB commands via subprocess rather than using adb libraries to maintain compatibility and simplicity.\n\n3. **Logcat Streaming**: Use continuous logcat streaming with filtering for real-time BIP event monitoring.\n\n4. **AT Command Routing**: Route AT commands through multiple methods (service call, dialer codes, direct device node) based on device capabilities.\n\n5. **Event-Driven Architecture**: All device events emit through EventEmitter for dashboard and test orchestrator integration.\n\n6. **Profile-Based Configuration**: Store device profiles as JSON for reproducible test setups.\n\n## Component Design\n\n### Component 1: PhoneController\n\n**Purpose**: Main orchestrator class that coordinates all phone control operations.\n\n**Interface**:\n```python\nclass PhoneController:\n    \"\"\"Main phone controller for Android device management.\"\"\"\n\n    def __init__(\n        self,\n        adb_path: str = \"adb\",\n        event_emitter: Optional[EventEmitter] = None\n    ):\n        \"\"\"Initialize controller with ADB path and optional event emitter.\"\"\"\n\n    async def discover_devices(self) -> List[DeviceInfo]:\n        \"\"\"Scan for connected ADB devices.\"\"\"\n\n    def get_device(self, serial: str) -> Optional[Device]:\n        \"\"\"Get device instance by serial number.\"\"\"\n\n    async def refresh_devices(self) -> None:\n        \"\"\"Refresh device list and status.\"\"\"\n\n    def on_device_connected(self, callback: Callable) -> None:\n        \"\"\"Register callback for device connection events.\"\"\"\n\n    def on_device_disconnected(self, callback: Callable) -> None:\n        \"\"\"Register callback for device disconnection events.\"\"\"\n```\n\n**Key Behaviors**:\n- Maintains registry of discovered devices\n- Polls for device changes every 5 seconds\n- Creates Device instances for each connected device\n- Emits device_connected/disconnected events\n\n### Component 2: ADBClient\n\n**Purpose**: Low-level ADB command execution wrapper.\n\n**Interface**:\n```python\nclass ADBClient:\n    \"\"\"Low-level ADB command execution.\"\"\"\n\n    def __init__(self, adb_path: str = \"adb\"):\n        \"\"\"Initialize with path to ADB executable.\"\"\"\n\n    async def execute(\n        self,\n        command: List[str],\n        serial: Optional[str] = None,\n        timeout: float = 30.0\n    ) -> ADBResult:\n        \"\"\"Execute ADB command and return result.\"\"\"\n\n    async def shell(\n        self,\n        command: str,\n        serial: str,\n        timeout: float = 30.0\n    ) -> str:\n        \"\"\"Execute shell command on device.\"\"\"\n\n    async def get_devices(self) -> List[Dict[str, str]]:\n        \"\"\"List connected devices with status.\"\"\"\n\n    async def start_logcat(\n        self,\n        serial: str,\n        filters: List[str]\n    ) -> AsyncIterator[str]:\n        \"\"\"Start streaming logcat with filters.\"\"\"\n\n    def is_available(self) -> bool:\n        \"\"\"Check if ADB is available in PATH.\"\"\"\n```\n\n**ADB Command Patterns**:\n```python\n# Device listing\nadb devices -l\n\n# Shell command\nadb -s <serial> shell <command>\n\n# Get property\nadb -s <serial> shell getprop <property>\n\n# Logcat streaming\nadb -s <serial> logcat -v time <filters>\n\n# Push/pull files\nadb -s <serial> push <local> <remote>\nadb -s <serial> pull <remote> <local>\n```\n\n**Key Behaviors**:\n- Validates ADB availability on initialization\n- Handles command timeouts\n- Parses device list output\n- Manages async subprocess execution\n\n### Component 3: DeviceManager\n\n**Purpose**: Manages device discovery, connection monitoring, and device lifecycle.\n\n**Interface**:\n```python\nclass DeviceManager:\n    \"\"\"Manages device discovery and connection state.\"\"\"\n\n    def __init__(\n        self,\n        adb_client: ADBClient,\n        event_emitter: EventEmitter,\n        poll_interval: float = 5.0\n    ):\n        \"\"\"Initialize with ADB client and polling interval.\"\"\"\n\n    async def start_monitoring(self) -> None:\n        \"\"\"Start background device monitoring.\"\"\"\n\n    async def stop_monitoring(self) -> None:\n        \"\"\"Stop background device monitoring.\"\"\"\n\n    async def scan_devices(self) -> List[DeviceInfo]:\n        \"\"\"Perform one-time device scan.\"\"\"\n\n    def get_connected_devices(self) -> List[str]:\n        \"\"\"Get list of connected device serials.\"\"\"\n\n    def is_device_connected(self, serial: str) -> bool:\n        \"\"\"Check if specific device is connected.\"\"\"\n```\n\n**Device States**:\n```python\nclass DeviceState(Enum):\n    DISCONNECTED = \"disconnected\"\n    UNAUTHORIZED = \"unauthorized\"  # USB debugging not authorized\n    OFFLINE = \"offline\"            # Device not responding\n    CONNECTED = \"connected\"        # Ready for commands\n```\n\n**Key Behaviors**:\n- Background polling thread for device changes\n- Detects new connections within 5 seconds\n- Detects disconnections within 5 seconds\n- Emits events on state changes\n\n### Component 4: DeviceInfo\n\n**Purpose**: Retrieves and stores comprehensive device and UICC information.\n\n**Interface**:\n```python\nclass DeviceInfo:\n    \"\"\"Device information retrieval and profiling.\"\"\"\n\n    def __init__(self, adb_client: ADBClient, serial: str):\n        \"\"\"Initialize for specific device.\"\"\"\n\n    async def get_device_info(self) -> DeviceProfile:\n        \"\"\"Get device hardware/software information.\"\"\"\n\n    async def get_sim_info(self) -> SIMProfile:\n        \"\"\"Get UICC/SIM card information.\"\"\"\n\n    async def get_network_info(self) -> NetworkProfile:\n        \"\"\"Get network connection information.\"\"\"\n\n    async def get_full_profile(self) -> FullProfile:\n        \"\"\"Get complete device profile.\"\"\"\n\n    async def refresh(self) -> None:\n        \"\"\"Force refresh all cached information.\"\"\"\n\n    def export_json(self) -> str:\n        \"\"\"Export profile as JSON string.\"\"\"\n\n    @staticmethod\n    def compare(profile1: FullProfile, profile2: FullProfile) -> ProfileDiff:\n        \"\"\"Compare two profiles and return differences.\"\"\"\n```\n\n**Property Retrieval**:\n```python\n# Device properties (via getprop)\nDEVICE_PROPS = {\n    'model': 'ro.product.model',\n    'manufacturer': 'ro.product.manufacturer',\n    'android_version': 'ro.build.version.release',\n    'api_level': 'ro.build.version.sdk',\n    'build_number': 'ro.build.display.id',\n    'serial': 'ro.serialno',\n    'baseband': 'gsm.version.baseband',\n    'kernel': 'ro.kernel.version',\n}\n\n# SIM properties (via service call or getprop)\nSIM_PROPS = {\n    'iccid': 'gsm.sim.iccid',\n    'imsi': 'gsm.sim.imsi',  # May require root\n    'operator': 'gsm.sim.operator.alpha',\n    'mcc': 'gsm.sim.operator.numeric',  # MCCMNC combined\n    'state': 'gsm.sim.state',\n}\n\n# IMEI retrieval methods\n# Method 1: service call (most reliable)\n# adb shell service call iphonesubinfo 1\n# Method 2: dumpsys\n# adb shell dumpsys telephony.registry | grep mDeviceId\n```\n\n**Data Models**:\n```python\n@dataclass\nclass DeviceProfile:\n    model: str\n    manufacturer: str\n    android_version: str\n    api_level: int\n    build_number: str\n    serial: str\n    imei: str\n    baseband_version: str\n    kernel_version: str\n\n@dataclass\nclass SIMProfile:\n    status: str  # absent, locked, ready\n    iccid: Optional[str]\n    imsi: Optional[str]\n    msisdn: Optional[str]\n    spn: Optional[str]\n    mcc: Optional[str]\n    mnc: Optional[str]\n    slot: int  # 0 or 1 for dual-SIM\n\n@dataclass\nclass NetworkProfile:\n    operator_name: str\n    network_type: str  # LTE, 5G, etc.\n    signal_strength: int  # dBm\n    data_state: str  # connected, disconnected\n    apn: str\n\n@dataclass\nclass FullProfile:\n    device: DeviceProfile\n    sim: SIMProfile\n    network: NetworkProfile\n    timestamp: datetime\n```\n\n### Component 5: ATInterface\n\n**Purpose**: Sends AT commands to the phone's modem and parses responses.\n\n**Interface**:\n```python\nclass ATInterface:\n    \"\"\"AT command interface for modem communication.\"\"\"\n\n    def __init__(self, adb_client: ADBClient, serial: str):\n        \"\"\"Initialize for specific device.\"\"\"\n\n    async def send_command(\n        self,\n        command: str,\n        timeout: float = 5.0\n    ) -> ATResponse:\n        \"\"\"Send AT command and return response.\"\"\"\n\n    async def check_sim_status(self) -> str:\n        \"\"\"Send AT+CPIN? and return status.\"\"\"\n\n    async def get_imsi(self) -> Optional[str]:\n        \"\"\"Send AT+CIMI and return IMSI.\"\"\"\n\n    async def get_iccid(self) -> Optional[str]:\n        \"\"\"Send AT+CCID and return ICCID.\"\"\"\n\n    async def send_csim(self, apdu_hex: str) -> str:\n        \"\"\"Send AT+CSIM command with APDU.\"\"\"\n\n    def is_available(self) -> bool:\n        \"\"\"Check if AT interface is accessible.\"\"\"\n\n    def requires_root(self) -> bool:\n        \"\"\"Check if AT access requires root.\"\"\"\n```\n\n**AT Command Methods**:\n```python\n# Method 1: Via service call (requires permissions)\n# adb shell service call phone 27 s16 \"AT+CPIN?\"\n\n# Method 2: Via dialer code broadcast\n# adb shell am broadcast -a android.provider.Telephony.SECRET_CODE -d android_secret_code://...\n\n# Method 3: Direct device node (requires root)\n# adb shell cat /dev/smd0\n# adb shell echo \"AT+CPIN?\" > /dev/smd0\n\n# Method 4: Via ril daemon\n# adb shell radiooptions ...\n```\n\n**Response Parsing**:\n```python\n@dataclass\nclass ATResponse:\n    command: str\n    raw_response: str\n    result: str  # OK, ERROR, +CME ERROR: xx\n    data: Optional[str]  # Parsed response data\n    success: bool\n```\n\n**Key Behaviors**:\n- Tries multiple methods to find working AT interface\n- Caches working method for subsequent calls\n- Parses responses into structured data\n- Handles timeouts and errors gracefully\n\n### Component 6: BIPMonitor\n\n**Purpose**: Monitors logcat for Bearer Independent Protocol events.\n\n**Interface**:\n```python\nclass BIPMonitor:\n    \"\"\"Monitors BIP (Bearer Independent Protocol) events via logcat.\"\"\"\n\n    def __init__(\n        self,\n        adb_client: ADBClient,\n        serial: str,\n        event_emitter: EventEmitter\n    ):\n        \"\"\"Initialize monitor for specific device.\"\"\"\n\n    async def start(self) -> None:\n        \"\"\"Start BIP event monitoring.\"\"\"\n\n    async def stop(self) -> None:\n        \"\"\"Stop BIP event monitoring.\"\"\"\n\n    def is_running(self) -> bool:\n        \"\"\"Check if monitor is active.\"\"\"\n\n    def on_event(self, callback: Callable[[BIPEvent], None]) -> None:\n        \"\"\"Register callback for BIP events.\"\"\"\n```\n\n**Logcat Filters**:\n```python\nLOGCAT_FILTERS = [\n    'CatService:V',      # CAT/STK events\n    'StkAppService:V',   # STK application\n    'BipChannel:V',      # BIP channel events\n    'RIL:V',             # Radio interface layer\n    'Telephony:V',       # General telephony\n    'GsmCatHandler:V',   # GSM CAT handling\n]\n\n# Logcat command\n# adb logcat -v time CatService:V BipChannel:V *:S\n```\n\n**BIP Event Types**:\n```python\nclass BIPEventType(Enum):\n    OPEN_CHANNEL = \"open_channel\"\n    CLOSE_CHANNEL = \"close_channel\"\n    SEND_DATA = \"send_data\"\n    RECEIVE_DATA = \"receive_data\"\n    GET_CHANNEL_STATUS = \"get_channel_status\"\n\n@dataclass\nclass BIPEvent:\n    type: BIPEventType\n    timestamp: datetime\n    channel_id: Optional[int]\n    data: Optional[bytes]\n    status: Optional[str]\n    raw_log: str\n```\n\n**Key Behaviors**:\n- Continuous logcat streaming with filtering\n- Pattern matching to extract BIP events\n- Emits parsed events to EventEmitter\n- Handles logcat buffer overflow\n\n### Component 7: LogcatParser\n\n**Purpose**: Parses logcat lines into structured events.\n\n**Interface**:\n```python\nclass LogcatParser:\n    \"\"\"Parses logcat output into structured events.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize parser with pattern matchers.\"\"\"\n\n    def parse_line(self, line: str) -> Optional[LogcatEvent]:\n        \"\"\"Parse single logcat line.\"\"\"\n\n    def is_bip_event(self, event: LogcatEvent) -> bool:\n        \"\"\"Check if event is BIP-related.\"\"\"\n\n    def extract_bip_event(self, event: LogcatEvent) -> Optional[BIPEvent]:\n        \"\"\"Extract BIP event details from logcat event.\"\"\"\n```\n\n**Parsing Patterns**:\n```python\n# Logcat line format: MM-DD HH:MM:SS.mmm PID TID LEVEL TAG: MESSAGE\nLOGCAT_PATTERN = r'^(\\d{2}-\\d{2})\\s+(\\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\s+(\\d+)\\s+(\\d+)\\s+([VDIWEF])\\s+(\\S+)\\s*:\\s*(.*)$'\n\n# BIP event patterns\nBIP_PATTERNS = {\n    'open_channel': r'OPEN CHANNEL.*bearer:(.*?)(?:,|$)',\n    'close_channel': r'CLOSE CHANNEL.*channel:(\\d+)',\n    'send_data': r'SEND DATA.*channel:(\\d+).*length:(\\d+)',\n    'receive_data': r'RECEIVE DATA.*channel:(\\d+)',\n}\n```\n\n### Component 8: SMSTrigger\n\n**Purpose**: Sends SMS-PP trigger messages to initiate OTA sessions.\n\n**Interface**:\n```python\nclass SMSTrigger:\n    \"\"\"SMS-PP OTA trigger message sender.\"\"\"\n\n    def __init__(self, adb_client: ADBClient, serial: str):\n        \"\"\"Initialize for specific device.\"\"\"\n\n    async def send_trigger(\n        self,\n        template: TriggerTemplate,\n        params: Dict[str, Any]\n    ) -> TriggerResult:\n        \"\"\"Send OTA trigger using template.\"\"\"\n\n    async def send_raw_pdu(self, pdu: bytes) -> TriggerResult:\n        \"\"\"Send raw PDU bytes as SMS-PP.\"\"\"\n\n    def build_pdu(\n        self,\n        template: TriggerTemplate,\n        params: Dict[str, Any]\n    ) -> bytes:\n        \"\"\"Build PDU from template and parameters.\"\"\"\n\n    def get_templates(self) -> List[TriggerTemplate]:\n        \"\"\"List available trigger templates.\"\"\"\n```\n\n**PDU Encoding**:\n```python\n@dataclass\nclass TriggerTemplate:\n    name: str\n    description: str\n    pdu_template: bytes\n    params: List[TemplateParam]\n\n# SMS-PP PDU structure for OTA\n# See 3GPP TS 23.040 and ETSI TS 102 225\nPDU_STRUCTURE = {\n    'smsc_length': 1,      # SMSC info length\n    'pdu_type': 1,         # SMS-DELIVER or SMS-SUBMIT\n    'oa_length': 1,        # Originating address length\n    'oa_type': 1,          # Address type\n    'oa_number': 'var',    # Address digits\n    'pid': 1,              # Protocol identifier (0x7F for SIM Data Download)\n    'dcs': 1,              # Data coding scheme\n    'scts': 7,             # Service center timestamp\n    'udl': 1,              # User data length\n    'udh': 'var',          # User data header\n    'ud': 'var',           # User data (command packet)\n}\n```\n\n**Trigger Methods**:\n```python\n# Method 1: Via AT+CMGS (if AT interface available)\n# AT+CMGS=<length>\n# <PDU bytes>\n\n# Method 2: Via content provider injection (requires root)\n# adb shell content insert --uri content://sms/inbox ...\n\n# Method 3: Via broadcast intent (limited)\n# adb shell am broadcast -a android.intent.action.DATA_SMS_RECEIVED ...\n```\n\n**Key Behaviors**:\n- Encodes OTA trigger as SMS-PP PDU\n- Tries multiple injection methods\n- Logs PDU bytes for debugging\n- Returns delivery status\n\n### Component 9: NetworkManager\n\n**Purpose**: Manages phone network configuration.\n\n**Interface**:\n```python\nclass NetworkManager:\n    \"\"\"Manages phone network configuration.\"\"\"\n\n    def __init__(self, adb_client: ADBClient, serial: str):\n        \"\"\"Initialize for specific device.\"\"\"\n\n    async def enable_wifi(self) -> bool:\n        \"\"\"Enable WiFi radio.\"\"\"\n\n    async def disable_wifi(self) -> bool:\n        \"\"\"Disable WiFi radio.\"\"\"\n\n    async def connect_wifi(self, ssid: str, password: Optional[str] = None) -> bool:\n        \"\"\"Connect to WiFi network.\"\"\"\n\n    async def enable_mobile_data(self) -> bool:\n        \"\"\"Enable mobile data.\"\"\"\n\n    async def disable_mobile_data(self) -> bool:\n        \"\"\"Disable mobile data.\"\"\"\n\n    async def set_apn(self, apn_config: APNConfig) -> bool:\n        \"\"\"Configure APN settings.\"\"\"\n\n    async def set_proxy(self, host: str, port: int) -> bool:\n        \"\"\"Set HTTP proxy.\"\"\"\n\n    async def test_connectivity(self, url: str) -> ConnectivityResult:\n        \"\"\"Test connectivity to URL.\"\"\"\n```\n\n**ADB Commands**:\n```python\n# WiFi control\n# adb shell svc wifi enable\n# adb shell svc wifi disable\n\n# Mobile data control\n# adb shell svc data enable\n# adb shell svc data disable\n\n# WiFi connection (requires WifiManager)\n# adb shell cmd wifi connect-network <ssid> <security> <password>\n\n# APN configuration\n# adb shell content insert --uri content://telephony/carriers ...\n```\n\n### Component 10: ProfileManager\n\n**Purpose**: Manages device configuration profiles.\n\n**Interface**:\n```python\nclass ProfileManager:\n    \"\"\"Manages device configuration profiles.\"\"\"\n\n    def __init__(self, storage_path: Path):\n        \"\"\"Initialize with profile storage location.\"\"\"\n\n    def save_profile(self, name: str, profile: FullProfile) -> None:\n        \"\"\"Save device profile to storage.\"\"\"\n\n    def load_profile(self, name: str) -> Optional[FullProfile]:\n        \"\"\"Load device profile from storage.\"\"\"\n\n    def list_profiles(self) -> List[str]:\n        \"\"\"List available profile names.\"\"\"\n\n    def delete_profile(self, name: str) -> bool:\n        \"\"\"Delete profile by name.\"\"\"\n\n    def compare_profiles(\n        self,\n        profile1: FullProfile,\n        profile2: FullProfile\n    ) -> ProfileDiff:\n        \"\"\"Compare two profiles and return differences.\"\"\"\n\n    def export_profile(self, name: str, format: str = 'json') -> str:\n        \"\"\"Export profile as JSON string.\"\"\"\n\n    def import_profile(self, name: str, data: str) -> None:\n        \"\"\"Import profile from JSON string.\"\"\"\n```\n\n**Profile Storage Format**:\n```json\n{\n    \"name\": \"test-device-01\",\n    \"created_at\": \"2024-01-15T10:30:00Z\",\n    \"device\": {\n        \"model\": \"Pixel 6\",\n        \"manufacturer\": \"Google\",\n        \"android_version\": \"14\",\n        \"api_level\": 34,\n        \"serial\": \"ABC123\",\n        \"imei\": \"123456789012345\"\n    },\n    \"sim\": {\n        \"status\": \"ready\",\n        \"iccid\": \"89012345678901234567\",\n        \"imsi\": \"310260123456789\",\n        \"spn\": \"Test Operator\"\n    },\n    \"network\": {\n        \"operator_name\": \"Test Network\",\n        \"network_type\": \"LTE\",\n        \"apn\": \"test.apn\"\n    }\n}\n```\n\n## File Structure\n\n```\nsrc/cardlink/phone/\n├── __init__.py                 # Public API exports\n├── controller.py               # PhoneController main class\n├── adb_client.py               # ADBClient low-level ADB wrapper\n├── device_manager.py           # DeviceManager discovery/monitoring\n├── device_info.py              # DeviceInfo profiling\n├── at_interface.py             # ATInterface AT command handling\n├── bip_monitor.py              # BIPMonitor logcat monitoring\n├── logcat_parser.py            # LogcatParser event parsing\n├── sms_trigger.py              # SMSTrigger PDU encoding/sending\n├── network_manager.py          # NetworkManager network config\n├── profile_manager.py          # ProfileManager profile storage\n├── models.py                   # Data models and enums\n└── exceptions.py               # Custom exceptions\n```\n\n## Dependencies\n\n### Internal Dependencies\n\n| Module | Depends On |\n|--------|------------|\n| `controller` | `device_manager`, `at_interface`, `bip_monitor`, `sms_trigger`, `network_manager` |\n| `device_manager` | `adb_client`, `device_info` |\n| `at_interface` | `adb_client` |\n| `bip_monitor` | `adb_client`, `logcat_parser` |\n| `sms_trigger` | `adb_client`, `at_interface` |\n| `network_manager` | `adb_client` |\n\n### External Dependencies\n\n| Library | Purpose |\n|---------|---------|\n| `asyncio` | Async subprocess execution |\n| `click` | CLI framework |\n\n### System Dependencies\n\n| Dependency | Purpose |\n|------------|---------|\n| ADB | Android Debug Bridge executable |\n| USB drivers | Device connection |\n\n## Error Handling\n\n### Error Types\n\n```python\nclass PhoneControllerError(Exception):\n    \"\"\"Base exception for phone controller errors.\"\"\"\n\nclass ADBNotFoundError(PhoneControllerError):\n    \"\"\"ADB executable not found.\"\"\"\n\nclass DeviceNotFoundError(PhoneControllerError):\n    \"\"\"Specified device not connected.\"\"\"\n\nclass DeviceUnauthorizedError(PhoneControllerError):\n    \"\"\"Device requires USB debugging authorization.\"\"\"\n\nclass ATCommandError(PhoneControllerError):\n    \"\"\"AT command execution failed.\"\"\"\n\nclass RootRequiredError(PhoneControllerError):\n    \"\"\"Operation requires root access.\"\"\"\n\nclass TimeoutError(PhoneControllerError):\n    \"\"\"Operation timed out.\"\"\"\n```\n\n### Error Handling Strategy\n\n```\nDevice Operation\n       │\n       ▼\n┌──────────────┐\n│ Check device │\n│  connected   │\n└──────┬───────┘\n       │ No\n       ├────────▶ Raise DeviceNotFoundError\n       │ Yes\n       ▼\n┌──────────────┐\n│Execute with  │\n│   timeout    │\n└──────┬───────┘\n       │ Timeout\n       ├────────▶ Raise TimeoutError\n       │ Success\n       ▼\n┌──────────────┐\n│Parse result  │\n│              │\n└──────┬───────┘\n       │ Error\n       ├────────▶ Raise appropriate error\n       │ Success\n       ▼\n   Return result\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n| Component | Test Focus |\n|-----------|------------|\n| `ADBClient` | Command execution, output parsing |\n| `DeviceInfo` | Property retrieval, profile building |\n| `ATInterface` | Command formatting, response parsing |\n| `LogcatParser` | Pattern matching, event extraction |\n| `SMSTrigger` | PDU encoding |\n| `ProfileManager` | Save/load, comparison |\n\n### Integration Tests\n\n| Test | Description |\n|------|-------------|\n| Device discovery | Detect real connected device |\n| AT command | Send AT+CPIN? and parse response |\n| BIP monitoring | Capture BIP event from triggered session |\n| Profile round-trip | Save profile, reload, verify identical |\n\n### Mock Strategy\n\n```python\nclass MockADBClient(ADBClient):\n    \"\"\"Mock ADB client for testing.\"\"\"\n\n    def __init__(self, responses: Dict[str, str]):\n        self.responses = responses\n        self.commands_executed = []\n\n    async def execute(self, command, serial=None, timeout=30.0):\n        self.commands_executed.append(command)\n        key = ' '.join(command)\n        return ADBResult(\n            stdout=self.responses.get(key, ''),\n            stderr='',\n            return_code=0\n        )\n```\n\n## Performance Considerations\n\n1. **Async ADB Execution**: Use asyncio subprocess for non-blocking ADB commands.\n\n2. **Logcat Buffering**: Buffer logcat lines and process in batches to reduce CPU usage.\n\n3. **Property Caching**: Cache device properties with configurable TTL.\n\n4. **Connection Pooling**: Reuse ADB connections where possible.\n\n5. **Efficient Polling**: Use exponential backoff for device discovery when no devices connected.\n\n## Security Considerations\n\n1. **No Credential Storage**: Never store device PINs, passwords, or unlock patterns.\n\n2. **Sensitive Data Logging**: Mask IMSI, IMEI in logs (show only last 4 digits).\n\n3. **USB Authorization**: Require user to authorize USB debugging on device.\n\n4. **Root Operations**: Clearly document which operations require root; don't escalate privileges silently.\n",
  "fileStats": {
    "size": 27818,
    "lines": 868,
    "lastModified": "2025-11-25T11:09:27.766Z"
  },
  "comments": []
}