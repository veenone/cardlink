{
  "id": "snapshot_1764067317078_nn19rqkz4",
  "approvalId": "approval_1764066473337_2jideg24s",
  "approvalTitle": "PSK-TLS Server Design Document",
  "version": 2,
  "timestamp": "2025-11-25T10:41:57.078Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: PSK-TLS Admin Server\n\n## Technical Approach\n\n### Overview\n\nThe PSK-TLS Admin Server is implemented as a multi-threaded Python server that handles TLS 1.2 connections using Pre-Shared Key (PSK) authentication. The server implements the GlobalPlatform Amendment B HTTP Admin protocol for Remote Application Management (RAM) over HTTPS.\n\n### Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                              PSK-TLS Admin Server                            │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                                                                              │\n│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐         │\n│  │   CLI Entry     │───▶│   AdminServer   │───▶│  EventEmitter   │         │\n│  │   (Click)       │    │   (Main Class)  │    │  (Pub/Sub)      │         │\n│  └─────────────────┘    └────────┬────────┘    └─────────────────┘         │\n│                                  │                                          │\n│                    ┌─────────────┴─────────────┐                           │\n│                    ▼                           ▼                           │\n│         ┌─────────────────┐         ┌─────────────────┐                    │\n│         │  TLSHandler     │         │ SessionManager  │                    │\n│         │  (PSK-TLS 1.2)  │         │ (State Mgmt)    │                    │\n│         └────────┬────────┘         └────────┬────────┘                    │\n│                  │                           │                              │\n│                  ▼                           ▼                              │\n│         ┌─────────────────┐         ┌─────────────────┐                    │\n│         │  HTTPHandler    │         │  KeyStore       │                    │\n│         │  (GP Admin)     │         │  (PSK Keys)     │                    │\n│         └────────┬────────┘         └─────────────────┘                    │\n│                  │                                                          │\n│                  ▼                                                          │\n│         ┌─────────────────┐                                                │\n│         │  GPCommandProc  │                                                │\n│         │  (APDU Handler) │                                                │\n│         └─────────────────┘                                                │\n│                                                                              │\n└─────────────────────────────────────────────────────────────────────────────┘\n                                      │\n                    ┌─────────────────┴─────────────────┐\n                    ▼                                   ▼\n          ┌─────────────────┐                 ┌─────────────────┐\n          │  Error Handler  │                 │ Metrics Collector│\n          │  (Negative Cases)│                 │ (Observability)  │\n          └─────────────────┘                 └─────────────────┘\n```\n\n### Key Design Decisions\n\n1. **Multi-threaded Connection Handling**: Each incoming TLS connection is handled in a separate thread to support concurrent connections (up to 10). ThreadPoolExecutor manages the thread pool.\n\n2. **PSK Callback Architecture**: The sslpsk3 library requires a callback function to resolve PSK identities to keys. This callback is registered during SSL context creation.\n\n3. **Configurable Cipher Suites**: Cipher suites are configured via YAML or CLI flags, with production-grade suites enabled by default and NULL suites disabled by default (require explicit opt-in).\n\n4. **Session State Machine**: Sessions progress through states: `HANDSHAKING` → `CONNECTED` → `ACTIVE` → `CLOSED`. State transitions emit events for dashboard integration.\n\n5. **Error Handler Chain**: Dedicated error handlers for connection interruption, PSK mismatch, and handshake failures. Each handler logs, emits events, and performs cleanup.\n\n## Component Design\n\n### Component 1: AdminServer\n\n**Purpose**: Main server class that orchestrates all components and manages the server lifecycle.\n\n**Interface**:\n```python\nclass AdminServer:\n    \"\"\"PSK-TLS Admin Server for GP Amendment B RAM over HTTP.\"\"\"\n\n    def __init__(\n        self,\n        config: ServerConfig,\n        key_store: KeyStore,\n        event_emitter: EventEmitter,\n        metrics_collector: Optional[MetricsCollector] = None\n    ):\n        \"\"\"Initialize server with dependencies.\"\"\"\n\n    def start(self) -> None:\n        \"\"\"Start the server and begin accepting connections.\"\"\"\n\n    def stop(self, timeout: float = 5.0) -> None:\n        \"\"\"Gracefully stop the server, closing all sessions.\"\"\"\n\n    def get_active_sessions(self) -> List[Session]:\n        \"\"\"Return list of currently active sessions.\"\"\"\n\n    @property\n    def is_running(self) -> bool:\n        \"\"\"Check if server is currently running.\"\"\"\n```\n\n**Key Behaviors**:\n- Creates SSL context with PSK support on initialization\n- Binds to configured port and accepts connections in main thread\n- Delegates connection handling to ThreadPoolExecutor\n- Graceful shutdown closes all sessions within timeout\n- Emits `server_started` and `server_stopped` events\n\n### Component 2: TLSHandler\n\n**Purpose**: Manages PSK-TLS connection establishment, cipher suite negotiation, and TLS-level error handling.\n\n**Interface**:\n```python\nclass TLSHandler:\n    \"\"\"Handles PSK-TLS 1.2 connection establishment.\"\"\"\n\n    def __init__(\n        self,\n        key_store: KeyStore,\n        allowed_ciphers: List[str],\n        handshake_timeout: float = 30.0\n    ):\n        \"\"\"Initialize TLS handler with key store and cipher config.\"\"\"\n\n    def create_ssl_context(self) -> ssl.SSLContext:\n        \"\"\"Create configured SSL context with PSK support.\"\"\"\n\n    def wrap_socket(\n        self,\n        sock: socket.socket,\n        client_addr: Tuple[str, int]\n    ) -> Tuple[ssl.SSLSocket, TLSSessionInfo]:\n        \"\"\"Wrap socket with TLS, return wrapped socket and session info.\"\"\"\n\n    def handle_handshake_error(\n        self,\n        error: Exception,\n        client_addr: Tuple[str, int],\n        partial_state: Optional[HandshakeState]\n    ) -> TLSAlert:\n        \"\"\"Process handshake error and return appropriate TLS alert.\"\"\"\n```\n\n**Cipher Suite Configuration**:\n```python\n@dataclass\nclass CipherConfig:\n    \"\"\"Cipher suite configuration.\"\"\"\n\n    # Production-grade (enabled by default)\n    production: List[str] = field(default_factory=lambda: [\n        \"TLS_PSK_WITH_AES_128_CBC_SHA256\",\n        \"TLS_PSK_WITH_AES_256_CBC_SHA384\"\n    ])\n\n    # Legacy compatibility (optional)\n    legacy: List[str] = field(default_factory=lambda: [\n        \"TLS_PSK_WITH_AES_128_CBC_SHA\",\n        \"TLS_PSK_WITH_AES_256_CBC_SHA\"\n    ])\n\n    # Testing only - no encryption (disabled by default)\n    testing: List[str] = field(default_factory=lambda: [\n        \"TLS_PSK_WITH_NULL_SHA\",\n        \"TLS_PSK_WITH_NULL_SHA256\"\n    ])\n\n    enable_legacy: bool = False\n    enable_null_ciphers: bool = False  # DANGER: No encryption\n```\n\n**Key Behaviors**:\n- PSK callback resolves identity to key via KeyStore\n- Logs warning when NULL cipher suites are enabled\n- Tracks partial handshake state for debugging interrupted handshakes\n- Sends appropriate TLS alerts on errors before closing\n\n### Component 3: HTTPHandler\n\n**Purpose**: Parses HTTP requests according to GP Amendment B Admin protocol and routes to command processor.\n\n**Interface**:\n```python\nclass HTTPHandler:\n    \"\"\"Handles GP Amendment B HTTP Admin protocol.\"\"\"\n\n    CONTENT_TYPE = \"application/vnd.globalplatform.card-content-mgt;version=1.0\"\n\n    def __init__(self, command_processor: GPCommandProcessor):\n        \"\"\"Initialize with GP command processor.\"\"\"\n\n    def handle_request(\n        self,\n        ssl_socket: ssl.SSLSocket,\n        session: Session\n    ) -> HTTPResponse:\n        \"\"\"Read HTTP request, process, and return response.\"\"\"\n\n    def parse_admin_request(\n        self,\n        raw_request: bytes\n    ) -> AdminRequest:\n        \"\"\"Parse raw HTTP bytes into AdminRequest.\"\"\"\n\n    def build_admin_response(\n        self,\n        apdu_responses: List[APDUResponse]\n    ) -> bytes:\n        \"\"\"Build GP Admin format response body.\"\"\"\n```\n\n**Key Behaviors**:\n- Validates Content-Type header (returns 415 if invalid)\n- Extracts APDU commands from GP Admin request body\n- Wraps APDU responses in GP Admin response format\n- Handles HTTP keep-alive for session continuity\n\n### Component 4: GPCommandProcessor\n\n**Purpose**: Processes GlobalPlatform APDU commands and generates responses.\n\n**Interface**:\n```python\nclass GPCommandProcessor:\n    \"\"\"Processes GlobalPlatform card management commands.\"\"\"\n\n    def __init__(\n        self,\n        response_handlers: Dict[int, ResponseHandler],\n        event_emitter: EventEmitter\n    ):\n        \"\"\"Initialize with command-specific handlers.\"\"\"\n\n    def process_command(\n        self,\n        apdu: APDUCommand,\n        session: Session\n    ) -> APDUResponse:\n        \"\"\"Process APDU command and return response.\"\"\"\n\n    def register_handler(\n        self,\n        ins_code: int,\n        handler: ResponseHandler\n    ) -> None:\n        \"\"\"Register handler for specific INS code.\"\"\"\n```\n\n**Supported Commands**:\n| INS | Command | Handler |\n|-----|---------|---------|\n| 0xA4 | SELECT | SelectHandler |\n| 0xE6 | INSTALL | InstallHandler |\n| 0xE4 | DELETE | DeleteHandler |\n| 0xF2 | GET STATUS | GetStatusHandler |\n| 0x50 | INITIALIZE UPDATE | InitUpdateHandler |\n| 0x82 | EXTERNAL AUTHENTICATE | ExtAuthHandler |\n\n**Key Behaviors**:\n- Logs command bytes, response bytes, status word, and timing\n- Emits `apdu_received` and `apdu_sent` events\n- Delegates to registered handlers by INS code\n- Returns appropriate SW for unknown commands (6D00)\n\n### Component 5: SessionManager\n\n**Purpose**: Manages OTA session lifecycle, state tracking, and resource cleanup.\n\n**Interface**:\n```python\nclass SessionManager:\n    \"\"\"Manages OTA session lifecycle.\"\"\"\n\n    def __init__(\n        self,\n        session_timeout: float = 300.0,\n        event_emitter: EventEmitter\n    ):\n        \"\"\"Initialize with timeout configuration.\"\"\"\n\n    def create_session(\n        self,\n        psk_identity: str,\n        client_addr: Tuple[str, int],\n        cipher_suite: str\n    ) -> Session:\n        \"\"\"Create new session with unique ID.\"\"\"\n\n    def get_session(self, session_id: str) -> Optional[Session]:\n        \"\"\"Retrieve session by ID.\"\"\"\n\n    def close_session(\n        self,\n        session_id: str,\n        reason: CloseReason\n    ) -> SessionSummary:\n        \"\"\"Close session and return summary.\"\"\"\n\n    def cleanup_expired(self) -> List[str]:\n        \"\"\"Close all expired sessions, return list of closed IDs.\"\"\"\n```\n\n**Session State Machine**:\n```\n    ┌──────────────┐\n    │  HANDSHAKING │\n    └──────┬───────┘\n           │ TLS handshake complete\n           ▼\n    ┌──────────────┐\n    │  CONNECTED   │\n    └──────┬───────┘\n           │ First HTTP request\n           ▼\n    ┌──────────────┐\n    │   ACTIVE     │◀──────┐\n    └──────┬───────┘       │\n           │               │ APDU exchange\n           │               │\n           └───────────────┘\n           │\n           │ Timeout / Close / Error\n           ▼\n    ┌──────────────┐\n    │   CLOSED     │\n    └──────────────┘\n```\n\n**Key Behaviors**:\n- Generates UUID-based session IDs\n- Background timer checks for expired sessions every 30s\n- Tracks all APDU exchanges within session\n- Emits `session_created`, `session_active`, `session_ended` events\n- Cleanup releases all resources within 5 seconds\n\n### Component 6: KeyStore\n\n**Purpose**: Abstract interface for PSK key storage and retrieval.\n\n**Interface**:\n```python\nclass KeyStore(ABC):\n    \"\"\"Abstract interface for PSK key storage.\"\"\"\n\n    @abstractmethod\n    def get_key(self, identity: str) -> Optional[bytes]:\n        \"\"\"Retrieve PSK key for given identity, None if not found.\"\"\"\n\n    @abstractmethod\n    def identity_exists(self, identity: str) -> bool:\n        \"\"\"Check if PSK identity exists in store.\"\"\"\n\n\nclass FileKeyStore(KeyStore):\n    \"\"\"File-based PSK key storage (YAML format).\"\"\"\n\n    def __init__(self, key_file: Path):\n        \"\"\"Load keys from YAML file.\"\"\"\n\n\nclass DatabaseKeyStore(KeyStore):\n    \"\"\"Database-backed PSK key storage.\"\"\"\n\n    def __init__(self, db_session: Session):\n        \"\"\"Initialize with database session.\"\"\"\n```\n\n**Key File Format**:\n```yaml\n# psk_keys.yaml\nkeys:\n  - identity: \"UICC_001\"\n    key: \"0123456789ABCDEF0123456789ABCDEF\"  # Hex encoded\n  - identity: \"UICC_002\"\n    key: \"FEDCBA9876543210FEDCBA9876543210\"\n```\n\n**Key Behaviors**:\n- Keys stored as hex strings, converted to bytes on load\n- Database implementation uses Card repository\n- Never logs key values in plaintext\n- Supports hot-reload of key file (optional)\n\n### Component 7: ErrorHandler\n\n**Purpose**: Handles negative cases including connection interruption, PSK mismatch, and handshake failures.\n\n**Interface**:\n```python\nclass ErrorHandler:\n    \"\"\"Handles error conditions and negative cases.\"\"\"\n\n    def __init__(\n        self,\n        event_emitter: EventEmitter,\n        metrics_collector: MetricsCollector,\n        mismatch_threshold: int = 3,\n        mismatch_window: float = 60.0\n    ):\n        \"\"\"Initialize with event and metrics dependencies.\"\"\"\n\n    def handle_connection_interrupted(\n        self,\n        session: Session,\n        last_command: Optional[APDUCommand]\n    ) -> None:\n        \"\"\"Handle TCP connection interruption.\"\"\"\n\n    def handle_psk_mismatch(\n        self,\n        identity: str,\n        client_addr: Tuple[str, int]\n    ) -> TLSAlert:\n        \"\"\"Handle PSK key mismatch, return TLS alert to send.\"\"\"\n\n    def handle_handshake_interrupted(\n        self,\n        client_addr: Tuple[str, int],\n        partial_state: HandshakeState,\n        reason: str\n    ) -> None:\n        \"\"\"Handle TLS handshake interruption.\"\"\"\n\n    def check_error_rate(self) -> bool:\n        \"\"\"Check if error rate exceeds threshold, emit alert if so.\"\"\"\n```\n\n**PSK Mismatch Tracking**:\n```python\n@dataclass\nclass MismatchTracker:\n    \"\"\"Tracks PSK mismatches by source IP.\"\"\"\n\n    counts: Dict[str, List[float]] = field(default_factory=dict)\n\n    def record(self, client_ip: str, timestamp: float) -> int:\n        \"\"\"Record mismatch, return count in window.\"\"\"\n\n    def check_threshold(\n        self,\n        client_ip: str,\n        threshold: int,\n        window: float\n    ) -> bool:\n        \"\"\"Check if mismatches exceed threshold in window.\"\"\"\n```\n\n**Key Behaviors**:\n- Connection interruption detected via socket exception or timeout\n- PSK mismatch triggers TLS alert 51 (decrypt_error)\n- Tracks mismatch frequency per source IP for misconfiguration detection\n- Handshake timeout logs partial state (last message type received)\n- Error rate monitoring emits `high_error_rate` event when threshold exceeded\n\n### Component 8: EventEmitter\n\n**Purpose**: Pub/sub event system for dashboard integration and monitoring.\n\n**Interface**:\n```python\nclass EventEmitter:\n    \"\"\"Event publication for real-time updates.\"\"\"\n\n    def emit(self, event_type: str, data: Dict[str, Any]) -> None:\n        \"\"\"Emit event to all subscribers.\"\"\"\n\n    def subscribe(\n        self,\n        event_type: str,\n        callback: Callable[[Dict[str, Any]], None]\n    ) -> str:\n        \"\"\"Subscribe to event type, return subscription ID.\"\"\"\n\n    def unsubscribe(self, subscription_id: str) -> None:\n        \"\"\"Remove subscription.\"\"\"\n```\n\n**Event Types**:\n| Event | Data Fields |\n|-------|-------------|\n| `server_started` | port, ciphers, timestamp |\n| `server_stopped` | reason, timestamp |\n| `tls_handshake_start` | client_addr, timestamp |\n| `tls_handshake_complete` | session_id, psk_identity, cipher_suite, timestamp |\n| `handshake_interrupted` | client_addr, reason, partial_state, timestamp |\n| `apdu_received` | session_id, command_hex, timestamp |\n| `apdu_sent` | session_id, response_hex, sw, timing_ms, timestamp |\n| `session_ended` | session_id, duration, command_count, status, timestamp |\n| `connection_interrupted` | session_id, last_command, timestamp |\n| `psk_mismatch` | identity, client_addr, timestamp |\n| `high_error_rate` | error_type, rate, threshold, timestamp |\n\n## Data Models\n\n### Configuration\n\n```python\n@dataclass\nclass ServerConfig:\n    \"\"\"Server configuration.\"\"\"\n\n    host: str = \"0.0.0.0\"\n    port: int = 8443\n\n    # TLS configuration\n    cipher_config: CipherConfig = field(default_factory=CipherConfig)\n    handshake_timeout: float = 30.0\n\n    # Session configuration\n    session_timeout: float = 300.0\n    socket_timeout: float = 60.0\n\n    # Key store configuration\n    key_store_type: str = \"file\"  # \"file\" or \"database\"\n    key_file_path: Optional[Path] = None\n\n    # Threading\n    max_connections: int = 10\n\n    # Error handling\n    psk_mismatch_threshold: int = 3\n    psk_mismatch_window: float = 60.0\n    error_rate_threshold: float = 0.5  # 50% error rate triggers alert\n\n\n@dataclass\nclass TLSSessionInfo:\n    \"\"\"TLS session information.\"\"\"\n\n    psk_identity: str\n    cipher_suite: str\n    tls_version: str\n    client_addr: Tuple[str, int]\n    handshake_duration_ms: float\n\n\n@dataclass\nclass Session:\n    \"\"\"OTA session state.\"\"\"\n\n    id: str\n    psk_identity: str\n    client_addr: Tuple[str, int]\n    cipher_suite: str\n    state: SessionState\n    created_at: datetime\n    last_activity: datetime\n    command_count: int = 0\n    commands: List[APDUExchange] = field(default_factory=list)\n\n\n@dataclass\nclass APDUExchange:\n    \"\"\"Single APDU command/response exchange.\"\"\"\n\n    command: APDUCommand\n    response: APDUResponse\n    timestamp: datetime\n    duration_ms: float\n\n\n@dataclass\nclass SessionSummary:\n    \"\"\"Session summary for logging and events.\"\"\"\n\n    session_id: str\n    psk_identity: str\n    duration_seconds: float\n    command_count: int\n    final_status: str\n    close_reason: CloseReason\n\n\nclass SessionState(Enum):\n    \"\"\"Session state machine states.\"\"\"\n\n    HANDSHAKING = \"handshaking\"\n    CONNECTED = \"connected\"\n    ACTIVE = \"active\"\n    CLOSED = \"closed\"\n\n\nclass CloseReason(Enum):\n    \"\"\"Reason for session closure.\"\"\"\n\n    NORMAL = \"normal\"\n    TIMEOUT = \"timeout\"\n    ERROR = \"error\"\n    INTERRUPTED = \"interrupted\"\n    SERVER_SHUTDOWN = \"server_shutdown\"\n\n\n@dataclass\nclass HandshakeState:\n    \"\"\"Partial handshake state for debugging.\"\"\"\n\n    client_hello_received: bool = False\n    server_hello_sent: bool = False\n    client_key_exchange_received: bool = False\n    finished_received: bool = False\n    last_message_type: Optional[str] = None\n    started_at: datetime = field(default_factory=datetime.utcnow)\n```\n\n### TLS Alerts\n\n```python\nclass TLSAlert(Enum):\n    \"\"\"TLS Alert codes.\"\"\"\n\n    CLOSE_NOTIFY = 0\n    UNEXPECTED_MESSAGE = 10\n    BAD_RECORD_MAC = 20\n    HANDSHAKE_FAILURE = 40\n    DECRYPT_ERROR = 51  # Used for PSK mismatch\n    PROTOCOL_VERSION = 70\n    INSUFFICIENT_SECURITY = 71\n    INTERNAL_ERROR = 80\n    USER_CANCELED = 90\n```\n\n## Error Handling Strategy\n\n### Connection Interruption\n\n```\nTCP Connection Lost\n        │\n        ▼\n┌───────────────────┐\n│ Detect via socket │\n│ exception/timeout │\n└────────┬──────────┘\n         │\n         ▼\n┌───────────────────┐\n│ Log: session_id,  │\n│ last_cmd, timestamp│\n└────────┬──────────┘\n         │\n         ▼\n┌───────────────────┐\n│ Emit: connection_ │\n│ interrupted event │\n└────────┬──────────┘\n         │\n         ▼\n┌───────────────────┐\n│ Cleanup session   │\n│ resources (<5s)   │\n└───────────────────┘\n```\n\n### PSK Mismatch\n\n```\nPSK Callback Returns Wrong Key\n              │\n              ▼\n    ┌───────────────────┐\n    │ TLS MAC validation│\n    │ fails             │\n    └────────┬──────────┘\n             │\n             ▼\n    ┌───────────────────┐\n    │ Log: identity,    │\n    │ client_addr (NO   │\n    │ key values!)      │\n    └────────┬──────────┘\n             │\n             ▼\n    ┌───────────────────┐\n    │ Track mismatch    │\n    │ for this source   │\n    └────────┬──────────┘\n             │\n    ┌────────┴────────┐\n    │ Multiple in 60s?│\n    └────────┬────────┘\n       Yes   │   No\n    ┌────────┴────────┐\n    ▼                 ▼\n┌─────────┐     ┌─────────┐\n│Log warn:│     │ Normal  │\n│misconfig│     │ handling│\n└────┬────┘     └────┬────┘\n     │               │\n     └───────┬───────┘\n             ▼\n    ┌───────────────────┐\n    │ Emit: psk_mismatch│\n    │ event             │\n    └────────┬──────────┘\n             │\n             ▼\n    ┌───────────────────┐\n    │ Send TLS Alert 51 │\n    │ (decrypt_error)   │\n    └────────┬──────────┘\n             │\n             ▼\n    ┌───────────────────┐\n    │ Close connection  │\n    └───────────────────┘\n```\n\n### Handshake Interruption\n\n```\nHandshake Message Timeout/Lost\n              │\n              ▼\n    ┌───────────────────┐\n    │ Wait handshake    │\n    │ timeout (30s)     │\n    └────────┬──────────┘\n             │\n             ▼\n    ┌───────────────────┐\n    │ Log: client_addr, │\n    │ partial state,    │\n    │ last msg type     │\n    └────────┬──────────┘\n             │\n    ┌────────┴────────┐\n    │ ClientHello only?│\n    └────────┬────────┘\n       Yes   │   No\n    ┌────────┴────────┐\n    ▼                 ▼\n┌─────────┐     ┌─────────┐\n│Log: pot-│     │Log: hand│\n│ential   │     │shake    │\n│network  │     │failure  │\n│issue    │     │         │\n└────┬────┘     └────┬────┘\n     │               │\n     └───────┬───────┘\n             ▼\n    ┌───────────────────┐\n    │ Emit: handshake_  │\n    │ interrupted event │\n    └────────┬──────────┘\n             │\n             ▼\n    ┌───────────────────┐\n    │ Close socket      │\n    │ (no TLS alert -   │\n    │  handshake failed)│\n    └───────────────────┘\n```\n\n## File Structure\n\n```\nsrc/cardlink/server/\n├── __init__.py                 # Public API exports\n├── admin_server.py             # AdminServer main class\n├── tls_handler.py              # TLSHandler, CipherConfig\n├── http_handler.py             # HTTPHandler, AdminRequest/Response\n├── gp_command_processor.py     # GPCommandProcessor, handlers\n├── session_manager.py          # SessionManager, Session, SessionState\n├── key_store.py                # KeyStore ABC, FileKeyStore, DatabaseKeyStore\n├── error_handler.py            # ErrorHandler, MismatchTracker\n├── event_emitter.py            # EventEmitter\n├── config.py                   # ServerConfig, all config dataclasses\n└── models.py                   # Data models (TLSSessionInfo, APDUExchange, etc.)\n```\n\n## Dependencies\n\n### Internal Dependencies\n\n| Module | Depends On |\n|--------|------------|\n| `admin_server` | `tls_handler`, `http_handler`, `session_manager`, `key_store`, `event_emitter`, `error_handler` |\n| `tls_handler` | `key_store`, `config` |\n| `http_handler` | `gp_command_processor`, `session_manager` |\n| `gp_command_processor` | `event_emitter`, protocol layer (`cardlink.protocol.apdu`) |\n| `session_manager` | `event_emitter`, `config` |\n| `error_handler` | `event_emitter`, observability layer (`cardlink.observability.metrics`) |\n\n### External Dependencies\n\n| Library | Purpose |\n|---------|---------|\n| `sslpsk3` | PSK-TLS support |\n| `pyyaml` | YAML configuration parsing |\n| `click` | CLI framework |\n\n### Optional Dependencies\n\n| Library | Purpose |\n|---------|---------|\n| `sqlalchemy` | Database key store backend |\n| `prometheus-client` | Metrics export |\n\n## Testing Strategy\n\n### Unit Tests\n\n| Component | Test Focus |\n|-----------|------------|\n| `TLSHandler` | Cipher configuration, PSK callback, error handling |\n| `HTTPHandler` | Request parsing, content-type validation, response formatting |\n| `GPCommandProcessor` | Command routing, handler dispatch, timing |\n| `SessionManager` | State transitions, timeout handling, cleanup |\n| `KeyStore` | Key retrieval, identity validation |\n| `ErrorHandler` | Alert generation, mismatch tracking, rate detection |\n\n### Integration Tests\n\n| Test | Description |\n|------|-------------|\n| `test_psk_handshake` | Full PSK-TLS handshake with valid key |\n| `test_psk_mismatch` | Handshake failure with wrong key |\n| `test_null_cipher` | Handshake with NULL cipher suite (when enabled) |\n| `test_session_timeout` | Session expiration after timeout |\n| `test_connection_interrupt` | Handling of TCP disconnect mid-session |\n| `test_concurrent_sessions` | Multiple simultaneous connections |\n\n### Mock Strategy\n\n```python\n# Mock key store for testing\nclass MockKeyStore(KeyStore):\n    def __init__(self, keys: Dict[str, bytes]):\n        self._keys = keys\n\n    def get_key(self, identity: str) -> Optional[bytes]:\n        return self._keys.get(identity)\n\n    def identity_exists(self, identity: str) -> bool:\n        return identity in self._keys\n\n\n# Mock event emitter for testing\nclass MockEventEmitter(EventEmitter):\n    def __init__(self):\n        self.events: List[Tuple[str, Dict]] = []\n\n    def emit(self, event_type: str, data: Dict[str, Any]) -> None:\n        self.events.append((event_type, data))\n```\n\n## Performance Considerations\n\n1. **Thread Pool Sizing**: Default 10 threads matches max concurrent connection requirement. Configurable for different workloads.\n\n2. **PSK Key Caching**: FileKeyStore caches keys in memory after initial load. Hot-reload support uses file modification time check.\n\n3. **Session Cleanup Timer**: Background timer runs every 30 seconds to avoid constant expiration checking on every request.\n\n4. **Event Queue**: EventEmitter uses asyncio queue for non-blocking event distribution to multiple subscribers.\n\n5. **Socket Timeouts**: Configured socket timeout (60s) prevents indefinite blocking on slow clients.\n\n## Security Considerations\n\n1. **Key Protection**: PSK keys never logged in plaintext. Only identity logged on mismatch.\n\n2. **NULL Cipher Warning**: Server logs prominent warning at startup when NULL ciphers enabled. Each NULL cipher connection logged.\n\n3. **Session Isolation**: Each session has isolated state. No cross-session data access.\n\n4. **Input Validation**: All HTTP input validated before processing. Invalid requests rejected immediately.\n\n5. **TLS Alerts**: Proper TLS alerts sent before closing connections to indicate failure reason without exposing sensitive details.\n",
  "fileStats": {
    "size": 30070,
    "lines": 865,
    "lastModified": "2025-11-25T10:27:47.628Z"
  },
  "comments": []
}