{
  "id": "snapshot_1764073660589_i1x5jil9i",
  "approvalId": "approval_1764073648900_f67xdtczn",
  "approvalTitle": "Network Simulator Integration Design Document",
  "version": 2,
  "timestamp": "2025-11-25T12:27:40.589Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Network Simulator Integration\n\n## Introduction\n\nThis document describes the technical design for the Network Simulator Integration component of CardLink. The component provides connectivity to network simulators like Amarisoft Callbox via WebSocket/TCP APIs, enabling controlled network environment testing for SCP81 OTA validation.\n\n## System Architecture\n\n### High-Level Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                           CardLink Application                               │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                        Test Orchestrator                             │   │\n│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐                   │   │\n│  │  │ScenarioRunner│ │ StepExecutor│ │EventCorrelator│                   │   │\n│  │  └─────────────┘ └─────────────┘ └─────────────┘                   │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n│                                    │                                        │\n│  ┌─────────────────────────────────┼─────────────────────────────────────┐ │\n│  │                    Network Simulator Manager                          │ │\n│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐    │ │\n│  │  │ UEManager   │ │SessionManager│ │ SMSManager  │ │EventManager │    │ │\n│  │  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘    │ │\n│  │  ┌─────────────┐ ┌─────────────┐                                     │ │\n│  │  │ CellManager │ │ConfigManager│                                     │ │\n│  │  └─────────────┘ └─────────────┘                                     │ │\n│  └─────────────────────────────────┬─────────────────────────────────────┘ │\n│                                    │                                        │\n│  ┌─────────────────────────────────┼─────────────────────────────────────┐ │\n│  │                    Simulator Abstraction Layer                        │ │\n│  │  ┌───────────────────────────────────────────────────────────────┐   │ │\n│  │  │                    SimulatorInterface                          │   │ │\n│  │  └───────────────────────────────────────────────────────────────┘   │ │\n│  │          │                              │                             │ │\n│  │  ┌───────┴───────┐              ┌───────┴───────┐                    │ │\n│  │  │AmarisoftAdapter│              │ GenericAdapter │                    │ │\n│  │  └───────────────┘              └───────────────┘                    │ │\n│  └─────────────────────────────────┬─────────────────────────────────────┘ │\n│                                    │                                        │\n│  ┌─────────────────────────────────┼─────────────────────────────────────┐ │\n│  │                      Connection Layer                                 │ │\n│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐                     │ │\n│  │  │WSConnection │ │TCPConnection│ │ReconnectMgr │                     │ │\n│  │  └─────────────┘ └─────────────┘ └─────────────┘                     │ │\n│  └─────────────────────────────────┬─────────────────────────────────────┘ │\n└─────────────────────────────────────┼───────────────────────────────────────┘\n                                      │\n                                      ▼\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                         Network Simulator                                    │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                    Amarisoft Callbox                                 │   │\n│  │  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐           │   │\n│  │  │   eNB     │ │   gNB     │ │   MME     │ │   AMF     │           │   │\n│  │  │  (LTE)    │ │  (5G NR)  │ │   EPC     │ │   5GC     │           │   │\n│  │  └───────────┘ └───────────┘ └───────────┘ └───────────┘           │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### Component Descriptions\n\n| Component | Responsibility |\n|-----------|----------------|\n| **SimulatorManager** | Central coordinator for all simulator operations |\n| **SimulatorInterface** | Abstract interface for simulator adapters |\n| **AmarisoftAdapter** | Amarisoft-specific API implementation |\n| **WSConnection** | WebSocket connection management |\n| **TCPConnection** | TCP fallback connection |\n| **ReconnectManager** | Connection recovery with backoff |\n| **UEManager** | UE registration tracking |\n| **SessionManager** | Data session management |\n| **SMSManager** | SMS injection and monitoring |\n| **CellManager** | Cell control operations |\n| **ConfigManager** | Network configuration management |\n| **EventManager** | Event subscription and distribution |\n| **ScenarioRunner** | Test scenario execution |\n| **EventCorrelator** | Cross-component event correlation |\n\n## Component Design\n\n### 1. SimulatorManager\n\nCentral manager for network simulator operations.\n\n```python\nfrom typing import Optional, Dict, Any, List\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport asyncio\n\nclass SimulatorType(Enum):\n    AMARISOFT = 'amarisoft'\n    GENERIC = 'generic'\n\n@dataclass\nclass SimulatorConfig:\n    \"\"\"Network simulator configuration.\"\"\"\n    url: str\n    simulator_type: SimulatorType = SimulatorType.AMARISOFT\n    protocol: str = 'websocket'  # websocket or tcp\n    api_key: Optional[str] = None\n    tls_enabled: bool = False\n    reconnect_enabled: bool = True\n    reconnect_max_attempts: int = 10\n    reconnect_base_delay: float = 1.0\n    reconnect_max_delay: float = 60.0\n    command_timeout: float = 5.0\n\nclass SimulatorManager:\n    \"\"\"Central manager for network simulator integration.\"\"\"\n\n    def __init__(self, config: SimulatorConfig,\n                 event_emitter: Optional['EventEmitter'] = None):\n        self.config = config\n        self._event_emitter = event_emitter\n        self._adapter: Optional['SimulatorInterface'] = None\n        self._connection: Optional['BaseConnection'] = None\n        self._reconnect_manager: Optional['ReconnectManager'] = None\n        self._connected = False\n\n        # Sub-managers\n        self._ue_manager: Optional['UEManager'] = None\n        self._session_manager: Optional['SessionManager'] = None\n        self._sms_manager: Optional['SMSManager'] = None\n        self._cell_manager: Optional['CellManager'] = None\n        self._config_manager: Optional['ConfigManager'] = None\n        self._event_manager: Optional['EventManager'] = None\n\n    async def connect(self) -> bool:\n        \"\"\"Connect to network simulator.\"\"\"\n        # Create connection based on protocol\n        if self.config.protocol == 'websocket':\n            self._connection = WSConnection(\n                url=self.config.url,\n                tls_enabled=self.config.tls_enabled\n            )\n        else:\n            self._connection = TCPConnection(\n                url=self.config.url,\n                tls_enabled=self.config.tls_enabled\n            )\n\n        # Setup reconnection\n        if self.config.reconnect_enabled:\n            self._reconnect_manager = ReconnectManager(\n                connection=self._connection,\n                max_attempts=self.config.reconnect_max_attempts,\n                base_delay=self.config.reconnect_base_delay,\n                max_delay=self.config.reconnect_max_delay\n            )\n\n        # Connect\n        try:\n            await self._connection.connect()\n\n            # Create adapter\n            self._adapter = self._create_adapter()\n\n            # Authenticate if required\n            if self.config.api_key:\n                await self._adapter.authenticate(self.config.api_key)\n\n            # Initialize sub-managers\n            self._init_managers()\n\n            self._connected = True\n\n            if self._event_emitter:\n                self._event_emitter.emit('simulator_connected', {\n                    'url': self.config.url,\n                    'type': self.config.simulator_type.value\n                })\n\n            return True\n\n        except Exception as e:\n            if self._event_emitter:\n                self._event_emitter.emit('simulator_error', {\n                    'error': str(e),\n                    'phase': 'connect'\n                })\n            return False\n\n    async def disconnect(self) -> None:\n        \"\"\"Disconnect from network simulator.\"\"\"\n        if self._connection:\n            await self._connection.disconnect()\n            self._connected = False\n\n            if self._event_emitter:\n                self._event_emitter.emit('simulator_disconnected', {\n                    'url': self.config.url\n                })\n\n    def _create_adapter(self) -> 'SimulatorInterface':\n        \"\"\"Create simulator adapter based on type.\"\"\"\n        if self.config.simulator_type == SimulatorType.AMARISOFT:\n            return AmarisoftAdapter(self._connection)\n        else:\n            return GenericAdapter(self._connection)\n\n    def _init_managers(self) -> None:\n        \"\"\"Initialize sub-managers.\"\"\"\n        self._ue_manager = UEManager(self._adapter, self._event_emitter)\n        self._session_manager = SessionManager(self._adapter, self._event_emitter)\n        self._sms_manager = SMSManager(self._adapter, self._event_emitter)\n        self._cell_manager = CellManager(self._adapter, self._event_emitter)\n        self._config_manager = ConfigManager(self._adapter)\n        self._event_manager = EventManager(self._adapter, self._event_emitter)\n\n        # Start event monitoring\n        asyncio.create_task(self._event_manager.start_monitoring())\n\n    @property\n    def is_connected(self) -> bool:\n        return self._connected\n\n    @property\n    def ue(self) -> 'UEManager':\n        return self._ue_manager\n\n    @property\n    def sessions(self) -> 'SessionManager':\n        return self._session_manager\n\n    @property\n    def sms(self) -> 'SMSManager':\n        return self._sms_manager\n\n    @property\n    def cell(self) -> 'CellManager':\n        return self._cell_manager\n\n    @property\n    def config(self) -> 'ConfigManager':\n        return self._config_manager\n\n    @property\n    def events(self) -> 'EventManager':\n        return self._event_manager\n\n    async def get_status(self) -> Dict[str, Any]:\n        \"\"\"Get overall simulator status.\"\"\"\n        if not self._connected:\n            return {'connected': False}\n\n        status = {\n            'connected': True,\n            'url': self.config.url,\n            'type': self.config.simulator_type.value\n        }\n\n        try:\n            status['cell'] = await self._cell_manager.get_status()\n            status['ue_count'] = len(await self._ue_manager.list_ues())\n            status['session_count'] = len(await self._session_manager.list_sessions())\n        except Exception as e:\n            status['error'] = str(e)\n\n        return status\n```\n\n### 2. Connection Layer\n\nWebSocket and TCP connection implementations.\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Optional, Callable, Any\nimport asyncio\nimport json\nimport websockets\nimport ssl\n\nclass BaseConnection(ABC):\n    \"\"\"Abstract base connection.\"\"\"\n\n    @abstractmethod\n    async def connect(self) -> None:\n        pass\n\n    @abstractmethod\n    async def disconnect(self) -> None:\n        pass\n\n    @abstractmethod\n    async def send(self, message: dict) -> None:\n        pass\n\n    @abstractmethod\n    async def receive(self) -> dict:\n        pass\n\n    @abstractmethod\n    def on_message(self, callback: Callable[[dict], None]) -> None:\n        pass\n\n    @abstractmethod\n    def is_connected(self) -> bool:\n        pass\n\n\nclass WSConnection(BaseConnection):\n    \"\"\"WebSocket connection implementation.\"\"\"\n\n    def __init__(self, url: str, tls_enabled: bool = False):\n        self.url = url\n        self.tls_enabled = tls_enabled\n        self._ws: Optional[websockets.WebSocketClientProtocol] = None\n        self._message_callbacks: list = []\n        self._receive_task: Optional[asyncio.Task] = None\n\n    async def connect(self) -> None:\n        \"\"\"Establish WebSocket connection.\"\"\"\n        ssl_context = None\n        if self.tls_enabled:\n            ssl_context = ssl.create_default_context()\n\n        self._ws = await websockets.connect(\n            self.url,\n            ssl=ssl_context,\n            ping_interval=30,\n            ping_timeout=10\n        )\n\n        # Start message receiver\n        self._receive_task = asyncio.create_task(self._receive_loop())\n\n    async def disconnect(self) -> None:\n        \"\"\"Close WebSocket connection.\"\"\"\n        if self._receive_task:\n            self._receive_task.cancel()\n            try:\n                await self._receive_task\n            except asyncio.CancelledError:\n                pass\n\n        if self._ws:\n            await self._ws.close()\n            self._ws = None\n\n    async def send(self, message: dict) -> None:\n        \"\"\"Send message over WebSocket.\"\"\"\n        if not self._ws:\n            raise ConnectionError(\"Not connected\")\n\n        await self._ws.send(json.dumps(message))\n\n    async def receive(self) -> dict:\n        \"\"\"Receive single message.\"\"\"\n        if not self._ws:\n            raise ConnectionError(\"Not connected\")\n\n        data = await self._ws.recv()\n        return json.loads(data)\n\n    def on_message(self, callback: Callable[[dict], None]) -> None:\n        \"\"\"Register message callback.\"\"\"\n        self._message_callbacks.append(callback)\n\n    def is_connected(self) -> bool:\n        return self._ws is not None and self._ws.open\n\n    async def _receive_loop(self) -> None:\n        \"\"\"Background message receiver.\"\"\"\n        try:\n            async for message in self._ws:\n                data = json.loads(message)\n                for callback in self._message_callbacks:\n                    try:\n                        callback(data)\n                    except Exception:\n                        pass\n        except websockets.ConnectionClosed:\n            pass\n\n\nclass TCPConnection(BaseConnection):\n    \"\"\"TCP connection implementation.\"\"\"\n\n    def __init__(self, url: str, tls_enabled: bool = False):\n        self.url = url\n        self.tls_enabled = tls_enabled\n        self._reader: Optional[asyncio.StreamReader] = None\n        self._writer: Optional[asyncio.StreamWriter] = None\n        self._message_callbacks: list = []\n        self._receive_task: Optional[asyncio.Task] = None\n\n    async def connect(self) -> None:\n        \"\"\"Establish TCP connection.\"\"\"\n        # Parse URL for host and port\n        parts = self.url.replace('tcp://', '').split(':')\n        host = parts[0]\n        port = int(parts[1]) if len(parts) > 1 else 9000\n\n        ssl_context = None\n        if self.tls_enabled:\n            ssl_context = ssl.create_default_context()\n\n        self._reader, self._writer = await asyncio.open_connection(\n            host, port, ssl=ssl_context\n        )\n\n        self._receive_task = asyncio.create_task(self._receive_loop())\n\n    async def disconnect(self) -> None:\n        \"\"\"Close TCP connection.\"\"\"\n        if self._receive_task:\n            self._receive_task.cancel()\n\n        if self._writer:\n            self._writer.close()\n            await self._writer.wait_closed()\n            self._writer = None\n            self._reader = None\n\n    async def send(self, message: dict) -> None:\n        \"\"\"Send message over TCP.\"\"\"\n        if not self._writer:\n            raise ConnectionError(\"Not connected\")\n\n        data = json.dumps(message).encode() + b'\\n'\n        self._writer.write(data)\n        await self._writer.drain()\n\n    async def receive(self) -> dict:\n        \"\"\"Receive single message.\"\"\"\n        if not self._reader:\n            raise ConnectionError(\"Not connected\")\n\n        line = await self._reader.readline()\n        return json.loads(line.decode())\n\n    def on_message(self, callback: Callable[[dict], None]) -> None:\n        \"\"\"Register message callback.\"\"\"\n        self._message_callbacks.append(callback)\n\n    def is_connected(self) -> bool:\n        return self._writer is not None and not self._writer.is_closing()\n\n    async def _receive_loop(self) -> None:\n        \"\"\"Background message receiver.\"\"\"\n        try:\n            while True:\n                line = await self._reader.readline()\n                if not line:\n                    break\n                data = json.loads(line.decode())\n                for callback in self._message_callbacks:\n                    try:\n                        callback(data)\n                    except Exception:\n                        pass\n        except Exception:\n            pass\n\n\nclass ReconnectManager:\n    \"\"\"Manages connection recovery with exponential backoff.\"\"\"\n\n    def __init__(self,\n                 connection: BaseConnection,\n                 max_attempts: int = 10,\n                 base_delay: float = 1.0,\n                 max_delay: float = 60.0):\n        self._connection = connection\n        self._max_attempts = max_attempts\n        self._base_delay = base_delay\n        self._max_delay = max_delay\n        self._attempts = 0\n        self._reconnecting = False\n\n    async def reconnect(self) -> bool:\n        \"\"\"Attempt reconnection with backoff.\"\"\"\n        if self._reconnecting:\n            return False\n\n        self._reconnecting = True\n        self._attempts = 0\n\n        while self._attempts < self._max_attempts:\n            self._attempts += 1\n\n            try:\n                await self._connection.connect()\n                self._reconnecting = False\n                self._attempts = 0\n                return True\n            except Exception:\n                delay = min(\n                    self._base_delay * (2 ** (self._attempts - 1)),\n                    self._max_delay\n                )\n                await asyncio.sleep(delay)\n\n        self._reconnecting = False\n        return False\n\n    def reset(self) -> None:\n        \"\"\"Reset reconnection state.\"\"\"\n        self._attempts = 0\n        self._reconnecting = False\n```\n\n### 3. Simulator Interface and Amarisoft Adapter\n\nAbstract interface and Amarisoft implementation.\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any, List, Optional\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass CellStatus(Enum):\n    INACTIVE = 'inactive'\n    ACTIVE = 'active'\n    STARTING = 'starting'\n    STOPPING = 'stopping'\n\n@dataclass\nclass UEInfo:\n    \"\"\"UE information.\"\"\"\n    imsi: str\n    imei: Optional[str] = None\n    msisdn: Optional[str] = None\n    cell_id: Optional[int] = None\n    registration_status: str = 'unknown'\n    ip_address: Optional[str] = None\n    last_activity: Optional[str] = None\n\n@dataclass\nclass DataSession:\n    \"\"\"Data session information.\"\"\"\n    session_id: str\n    imsi: str\n    apn: str\n    ip_address: str\n    qos_class: Optional[int] = None\n    bearer_id: Optional[int] = None\n    status: str = 'active'\n\n@dataclass\nclass CellInfo:\n    \"\"\"Cell information.\"\"\"\n    cell_id: int\n    status: CellStatus\n    plmn: str  # MCC-MNC\n    tac: int\n    earfcn: int\n    bandwidth: int\n    tx_power: float\n    connected_ues: int = 0\n\n\nclass SimulatorInterface(ABC):\n    \"\"\"Abstract interface for network simulators.\"\"\"\n\n    @abstractmethod\n    async def authenticate(self, api_key: str) -> bool:\n        pass\n\n    # Cell operations\n    @abstractmethod\n    async def get_cell_status(self) -> CellInfo:\n        pass\n\n    @abstractmethod\n    async def start_cell(self) -> bool:\n        pass\n\n    @abstractmethod\n    async def stop_cell(self) -> bool:\n        pass\n\n    @abstractmethod\n    async def configure_cell(self, config: Dict[str, Any]) -> bool:\n        pass\n\n    # UE operations\n    @abstractmethod\n    async def list_ues(self) -> List[UEInfo]:\n        pass\n\n    @abstractmethod\n    async def get_ue(self, imsi: str) -> Optional[UEInfo]:\n        pass\n\n    @abstractmethod\n    async def detach_ue(self, imsi: str) -> bool:\n        pass\n\n    # Data session operations\n    @abstractmethod\n    async def list_sessions(self) -> List[DataSession]:\n        pass\n\n    @abstractmethod\n    async def release_session(self, session_id: str) -> bool:\n        pass\n\n    # SMS operations\n    @abstractmethod\n    async def send_sms(self, imsi: str, pdu: bytes) -> bool:\n        pass\n\n    # Event operations\n    @abstractmethod\n    async def trigger_event(self, event_type: str, params: Dict[str, Any]) -> bool:\n        pass\n\n    # Configuration\n    @abstractmethod\n    async def get_config(self) -> Dict[str, Any]:\n        pass\n\n    @abstractmethod\n    async def set_config(self, config: Dict[str, Any]) -> bool:\n        pass\n\n    # Event subscription\n    @abstractmethod\n    def subscribe_events(self, callback: callable) -> None:\n        pass\n\n\nclass AmarisoftAdapter(SimulatorInterface):\n    \"\"\"Amarisoft Callbox adapter.\"\"\"\n\n    def __init__(self, connection: BaseConnection):\n        self._connection = connection\n        self._request_id = 0\n        self._pending_requests: Dict[int, asyncio.Future] = {}\n        self._event_callbacks: List[callable] = []\n\n        # Register message handler\n        self._connection.on_message(self._handle_message)\n\n    def _handle_message(self, message: dict) -> None:\n        \"\"\"Handle incoming message.\"\"\"\n        if 'id' in message and message['id'] in self._pending_requests:\n            # Response to request\n            future = self._pending_requests.pop(message['id'])\n            if 'error' in message:\n                future.set_exception(Exception(message['error']))\n            else:\n                future.set_result(message.get('result'))\n        elif 'event' in message:\n            # Event notification\n            for callback in self._event_callbacks:\n                try:\n                    callback(message)\n                except Exception:\n                    pass\n\n    async def _send_request(self, method: str, params: Dict[str, Any] = None) -> Any:\n        \"\"\"Send request and wait for response.\"\"\"\n        self._request_id += 1\n        request_id = self._request_id\n\n        request = {\n            'jsonrpc': '2.0',\n            'id': request_id,\n            'method': method\n        }\n        if params:\n            request['params'] = params\n\n        future = asyncio.Future()\n        self._pending_requests[request_id] = future\n\n        await self._connection.send(request)\n\n        try:\n            result = await asyncio.wait_for(future, timeout=5.0)\n            return result\n        except asyncio.TimeoutError:\n            self._pending_requests.pop(request_id, None)\n            raise TimeoutError(f\"Request {method} timed out\")\n\n    async def authenticate(self, api_key: str) -> bool:\n        \"\"\"Authenticate with API key.\"\"\"\n        result = await self._send_request('auth', {'api_key': api_key})\n        return result.get('success', False)\n\n    async def get_cell_status(self) -> CellInfo:\n        \"\"\"Get cell status.\"\"\"\n        result = await self._send_request('enb.get_status')\n\n        return CellInfo(\n            cell_id=result.get('cell_id', 0),\n            status=CellStatus(result.get('status', 'inactive')),\n            plmn=f\"{result.get('mcc', '001')}-{result.get('mnc', '01')}\",\n            tac=result.get('tac', 0),\n            earfcn=result.get('earfcn', 0),\n            bandwidth=result.get('bandwidth', 20),\n            tx_power=result.get('tx_power', 0),\n            connected_ues=result.get('ue_count', 0)\n        )\n\n    async def start_cell(self) -> bool:\n        \"\"\"Start cell.\"\"\"\n        result = await self._send_request('enb.start')\n        return result.get('success', False)\n\n    async def stop_cell(self) -> bool:\n        \"\"\"Stop cell.\"\"\"\n        result = await self._send_request('enb.stop')\n        return result.get('success', False)\n\n    async def configure_cell(self, config: Dict[str, Any]) -> bool:\n        \"\"\"Configure cell parameters.\"\"\"\n        result = await self._send_request('enb.configure', config)\n        return result.get('success', False)\n\n    async def list_ues(self) -> List[UEInfo]:\n        \"\"\"List connected UEs.\"\"\"\n        result = await self._send_request('ue.list')\n\n        return [\n            UEInfo(\n                imsi=ue.get('imsi', ''),\n                imei=ue.get('imei'),\n                msisdn=ue.get('msisdn'),\n                cell_id=ue.get('cell_id'),\n                registration_status=ue.get('status', 'unknown'),\n                ip_address=ue.get('ip_address'),\n                last_activity=ue.get('last_activity')\n            )\n            for ue in result.get('ues', [])\n        ]\n\n    async def get_ue(self, imsi: str) -> Optional[UEInfo]:\n        \"\"\"Get specific UE info.\"\"\"\n        result = await self._send_request('ue.get', {'imsi': imsi})\n\n        if not result:\n            return None\n\n        return UEInfo(\n            imsi=result.get('imsi', ''),\n            imei=result.get('imei'),\n            msisdn=result.get('msisdn'),\n            cell_id=result.get('cell_id'),\n            registration_status=result.get('status', 'unknown'),\n            ip_address=result.get('ip_address'),\n            last_activity=result.get('last_activity')\n        )\n\n    async def detach_ue(self, imsi: str) -> bool:\n        \"\"\"Detach UE from network.\"\"\"\n        result = await self._send_request('ue.detach', {'imsi': imsi})\n        return result.get('success', False)\n\n    async def list_sessions(self) -> List[DataSession]:\n        \"\"\"List active data sessions.\"\"\"\n        result = await self._send_request('session.list')\n\n        return [\n            DataSession(\n                session_id=s.get('id', ''),\n                imsi=s.get('imsi', ''),\n                apn=s.get('apn', ''),\n                ip_address=s.get('ip_address', ''),\n                qos_class=s.get('qci'),\n                bearer_id=s.get('bearer_id'),\n                status=s.get('status', 'active')\n            )\n            for s in result.get('sessions', [])\n        ]\n\n    async def release_session(self, session_id: str) -> bool:\n        \"\"\"Release data session.\"\"\"\n        result = await self._send_request('session.release', {'id': session_id})\n        return result.get('success', False)\n\n    async def send_sms(self, imsi: str, pdu: bytes) -> bool:\n        \"\"\"Send MT-SMS.\"\"\"\n        result = await self._send_request('sms.send', {\n            'imsi': imsi,\n            'pdu': pdu.hex()\n        })\n        return result.get('success', False)\n\n    async def trigger_event(self, event_type: str, params: Dict[str, Any]) -> bool:\n        \"\"\"Trigger network event.\"\"\"\n        result = await self._send_request(f'event.{event_type}', params)\n        return result.get('success', False)\n\n    async def get_config(self) -> Dict[str, Any]:\n        \"\"\"Get current configuration.\"\"\"\n        return await self._send_request('config.get')\n\n    async def set_config(self, config: Dict[str, Any]) -> bool:\n        \"\"\"Set configuration.\"\"\"\n        result = await self._send_request('config.set', config)\n        return result.get('success', False)\n\n    def subscribe_events(self, callback: callable) -> None:\n        \"\"\"Subscribe to events.\"\"\"\n        self._event_callbacks.append(callback)\n```\n\n### 4. UE Manager\n\nUE registration tracking.\n\n```python\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport asyncio\n\nclass UEManager:\n    \"\"\"Manages UE registration tracking.\"\"\"\n\n    def __init__(self, adapter: SimulatorInterface,\n                 event_emitter: Optional['EventEmitter'] = None):\n        self._adapter = adapter\n        self._event_emitter = event_emitter\n        self._ue_cache: Dict[str, UEInfo] = {}\n        self._waiters: Dict[str, List[asyncio.Event]] = {}\n\n        # Subscribe to UE events\n        self._adapter.subscribe_events(self._handle_event)\n\n    def _handle_event(self, event: dict) -> None:\n        \"\"\"Handle UE-related events.\"\"\"\n        event_type = event.get('event')\n\n        if event_type == 'ue_attached':\n            imsi = event.get('imsi')\n            ue_info = UEInfo(\n                imsi=imsi,\n                imei=event.get('imei'),\n                registration_status='attached',\n                cell_id=event.get('cell_id')\n            )\n            self._ue_cache[imsi] = ue_info\n\n            # Notify waiters\n            if imsi in self._waiters:\n                for waiter in self._waiters[imsi]:\n                    waiter.set()\n\n            if self._event_emitter:\n                self._event_emitter.emit('ue_registered', {\n                    'imsi': imsi,\n                    'imei': event.get('imei'),\n                    'cell_id': event.get('cell_id')\n                })\n\n        elif event_type == 'ue_detached':\n            imsi = event.get('imsi')\n            self._ue_cache.pop(imsi, None)\n\n            if self._event_emitter:\n                self._event_emitter.emit('ue_deregistered', {\n                    'imsi': imsi,\n                    'cause': event.get('cause')\n                })\n\n    async def list_ues(self) -> List[UEInfo]:\n        \"\"\"List all connected UEs.\"\"\"\n        ues = await self._adapter.list_ues()\n        # Update cache\n        self._ue_cache = {ue.imsi: ue for ue in ues}\n        return ues\n\n    async def get_ue(self, imsi: str) -> Optional[UEInfo]:\n        \"\"\"Get specific UE info.\"\"\"\n        # Try cache first\n        if imsi in self._ue_cache:\n            return self._ue_cache[imsi]\n\n        # Fetch from simulator\n        return await self._adapter.get_ue(imsi)\n\n    async def wait_for_registration(self, imsi: str,\n                                    timeout: float = 60.0) -> bool:\n        \"\"\"Wait for specific IMSI to register.\"\"\"\n        # Check if already registered\n        ue = await self.get_ue(imsi)\n        if ue and ue.registration_status == 'attached':\n            return True\n\n        # Create waiter\n        event = asyncio.Event()\n        if imsi not in self._waiters:\n            self._waiters[imsi] = []\n        self._waiters[imsi].append(event)\n\n        try:\n            await asyncio.wait_for(event.wait(), timeout=timeout)\n            return True\n        except asyncio.TimeoutError:\n            return False\n        finally:\n            self._waiters[imsi].remove(event)\n            if not self._waiters[imsi]:\n                del self._waiters[imsi]\n\n    async def detach_ue(self, imsi: str) -> bool:\n        \"\"\"Detach UE from network.\"\"\"\n        return await self._adapter.detach_ue(imsi)\n\n    def get_cached_ues(self) -> List[UEInfo]:\n        \"\"\"Get cached UE list without fetching.\"\"\"\n        return list(self._ue_cache.values())\n```\n\n### 5. SMS Manager\n\nSMS injection and monitoring.\n\n```python\nfrom typing import Optional, List\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass SMSMessage:\n    \"\"\"SMS message information.\"\"\"\n    message_id: str\n    direction: str  # mt or mo\n    imsi: str\n    pdu: bytes\n    timestamp: datetime\n    status: str  # pending, delivered, failed\n\nclass SMSManager:\n    \"\"\"Manages SMS injection and monitoring.\"\"\"\n\n    def __init__(self, adapter: SimulatorInterface,\n                 event_emitter: Optional['EventEmitter'] = None):\n        self._adapter = adapter\n        self._event_emitter = event_emitter\n        self._message_history: List[SMSMessage] = []\n        self._message_id = 0\n\n        # Subscribe to SMS events\n        self._adapter.subscribe_events(self._handle_event)\n\n    def _handle_event(self, event: dict) -> None:\n        \"\"\"Handle SMS-related events.\"\"\"\n        event_type = event.get('event')\n\n        if event_type == 'sms_delivered':\n            message_id = event.get('message_id')\n            for msg in self._message_history:\n                if msg.message_id == message_id:\n                    msg.status = 'delivered'\n                    break\n\n            if self._event_emitter:\n                self._event_emitter.emit('sms_delivered', {\n                    'message_id': message_id,\n                    'imsi': event.get('imsi')\n                })\n\n        elif event_type == 'sms_failed':\n            message_id = event.get('message_id')\n            for msg in self._message_history:\n                if msg.message_id == message_id:\n                    msg.status = 'failed'\n                    break\n\n            if self._event_emitter:\n                self._event_emitter.emit('sms_failed', {\n                    'message_id': message_id,\n                    'cause': event.get('cause')\n                })\n\n        elif event_type == 'sms_received':\n            # MO-SMS\n            msg = SMSMessage(\n                message_id=event.get('message_id', ''),\n                direction='mo',\n                imsi=event.get('imsi', ''),\n                pdu=bytes.fromhex(event.get('pdu', '')),\n                timestamp=datetime.utcnow(),\n                status='received'\n            )\n            self._message_history.append(msg)\n\n            if self._event_emitter:\n                self._event_emitter.emit('sms_event', {\n                    'direction': 'mo',\n                    'imsi': event.get('imsi'),\n                    'pdu': event.get('pdu')\n                })\n\n    async def send_mt_sms(self, imsi: str, pdu: bytes) -> str:\n        \"\"\"Send MT-SMS.\"\"\"\n        self._message_id += 1\n        message_id = f\"msg_{self._message_id}\"\n\n        # Record message\n        msg = SMSMessage(\n            message_id=message_id,\n            direction='mt',\n            imsi=imsi,\n            pdu=pdu,\n            timestamp=datetime.utcnow(),\n            status='pending'\n        )\n        self._message_history.append(msg)\n\n        # Send via adapter\n        success = await self._adapter.send_sms(imsi, pdu)\n\n        if not success:\n            msg.status = 'failed'\n            raise Exception(\"SMS send failed\")\n\n        if self._event_emitter:\n            self._event_emitter.emit('sms_event', {\n                'direction': 'mt',\n                'imsi': imsi,\n                'pdu': pdu.hex(),\n                'message_id': message_id\n            })\n\n        return message_id\n\n    async def send_sms_pp_trigger(self, imsi: str, tar: bytes,\n                                  originating_address: str = None) -> str:\n        \"\"\"Send SMS-PP OTA trigger.\"\"\"\n        # Build SMS-PP PDU\n        pdu = self._build_sms_pp_pdu(tar, originating_address)\n        return await self.send_mt_sms(imsi, pdu)\n\n    def _build_sms_pp_pdu(self, tar: bytes,\n                         originating_address: str = None) -> bytes:\n        \"\"\"Build SMS-PP PDU for OTA trigger.\"\"\"\n        # Simplified SMS-PP PDU construction\n        # In production, use proper PDU encoding\n        pdu = bytearray()\n\n        # SCA (Service Center Address) - empty\n        pdu.append(0x00)\n\n        # PDU Type: SMS-DELIVER\n        pdu.append(0x04)\n\n        # Originating Address\n        if originating_address:\n            oa_bytes = self._encode_address(originating_address)\n            pdu.extend(oa_bytes)\n        else:\n            pdu.extend([0x00, 0x00])\n\n        # Protocol Identifier - SIM Data Download\n        pdu.append(0x7F)\n\n        # Data Coding Scheme - 8-bit\n        pdu.append(0xF6)\n\n        # Timestamp (dummy)\n        pdu.extend([0x00] * 7)\n\n        # User Data Length\n        ud = self._build_ota_command_packet(tar)\n        pdu.append(len(ud))\n\n        # User Data\n        pdu.extend(ud)\n\n        return bytes(pdu)\n\n    def _encode_address(self, address: str) -> bytes:\n        \"\"\"Encode phone number for SMS PDU.\"\"\"\n        # Simplified address encoding\n        digits = address.replace('+', '')\n        length = len(digits)\n        type_byte = 0x91 if address.startswith('+') else 0x81\n\n        # BCD encode\n        bcd = bytearray()\n        for i in range(0, len(digits), 2):\n            d1 = int(digits[i])\n            d2 = int(digits[i+1]) if i+1 < len(digits) else 0x0F\n            bcd.append((d2 << 4) | d1)\n\n        return bytes([length, type_byte]) + bytes(bcd)\n\n    def _build_ota_command_packet(self, tar: bytes) -> bytes:\n        \"\"\"Build OTA command packet.\"\"\"\n        # Command Packet Identifier\n        cpi = 0x02\n\n        # Command Header (simplified)\n        header = bytearray()\n        header.append(len(tar) + 5)  # CPL\n        header.append(0x00)  # CHL\n        header.append(0x00)  # SPI (first byte)\n        header.append(0x00)  # SPI (second byte)\n        header.append(0x00)  # KIc\n        header.append(0x00)  # KID\n        header.extend(tar)   # TAR\n\n        return bytes([cpi]) + bytes(header)\n\n    def get_message_history(self, limit: int = 100) -> List[SMSMessage]:\n        \"\"\"Get SMS message history.\"\"\"\n        return self._message_history[-limit:]\n\n    def get_message(self, message_id: str) -> Optional[SMSMessage]:\n        \"\"\"Get specific message.\"\"\"\n        for msg in self._message_history:\n            if msg.message_id == message_id:\n                return msg\n        return None\n```\n\n### 6. Event Manager\n\nEvent subscription and distribution.\n\n```python\nfrom typing import List, Dict, Any, Callable, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport asyncio\n\n@dataclass\nclass NetworkEvent:\n    \"\"\"Network event data.\"\"\"\n    event_id: str\n    event_type: str\n    timestamp: datetime\n    source: str\n    data: Dict[str, Any]\n    correlation_id: Optional[str] = None\n\nclass EventManager:\n    \"\"\"Manages network events.\"\"\"\n\n    def __init__(self, adapter: SimulatorInterface,\n                 event_emitter: Optional['EventEmitter'] = None):\n        self._adapter = adapter\n        self._event_emitter = event_emitter\n        self._event_history: List[NetworkEvent] = []\n        self._event_id = 0\n        self._subscribers: Dict[str, List[Callable]] = {}\n        self._monitoring = False\n\n        # Subscribe to simulator events\n        self._adapter.subscribe_events(self._handle_simulator_event)\n\n    def _handle_simulator_event(self, event: dict) -> None:\n        \"\"\"Handle event from simulator.\"\"\"\n        self._event_id += 1\n\n        network_event = NetworkEvent(\n            event_id=f\"evt_{self._event_id}\",\n            event_type=event.get('event', 'unknown'),\n            timestamp=datetime.utcnow(),\n            source='simulator',\n            data=event\n        )\n\n        self._event_history.append(network_event)\n\n        # Emit to external listeners\n        if self._event_emitter:\n            self._event_emitter.emit('network_event', {\n                'event_id': network_event.event_id,\n                'type': network_event.event_type,\n                'timestamp': network_event.timestamp.isoformat(),\n                'data': network_event.data\n            })\n\n        # Notify subscribers\n        self._notify_subscribers(network_event)\n\n    def _notify_subscribers(self, event: NetworkEvent) -> None:\n        \"\"\"Notify subscribers of event.\"\"\"\n        # Type-specific subscribers\n        if event.event_type in self._subscribers:\n            for callback in self._subscribers[event.event_type]:\n                try:\n                    callback(event)\n                except Exception:\n                    pass\n\n        # Wildcard subscribers\n        if '*' in self._subscribers:\n            for callback in self._subscribers['*']:\n                try:\n                    callback(event)\n                except Exception:\n                    pass\n\n    def subscribe(self, event_type: str, callback: Callable[[NetworkEvent], None]) -> None:\n        \"\"\"Subscribe to event type.\"\"\"\n        if event_type not in self._subscribers:\n            self._subscribers[event_type] = []\n        self._subscribers[event_type].append(callback)\n\n    def unsubscribe(self, event_type: str, callback: Callable = None) -> None:\n        \"\"\"Unsubscribe from event type.\"\"\"\n        if event_type in self._subscribers:\n            if callback:\n                self._subscribers[event_type].remove(callback)\n            else:\n                del self._subscribers[event_type]\n\n    async def start_monitoring(self) -> None:\n        \"\"\"Start event monitoring.\"\"\"\n        self._monitoring = True\n\n    async def stop_monitoring(self) -> None:\n        \"\"\"Stop event monitoring.\"\"\"\n        self._monitoring = False\n\n    def get_event_history(self,\n                         event_type: str = None,\n                         start_time: datetime = None,\n                         end_time: datetime = None,\n                         limit: int = 100) -> List[NetworkEvent]:\n        \"\"\"Get filtered event history.\"\"\"\n        events = self._event_history\n\n        if event_type:\n            events = [e for e in events if e.event_type == event_type]\n\n        if start_time:\n            events = [e for e in events if e.timestamp >= start_time]\n\n        if end_time:\n            events = [e for e in events if e.timestamp <= end_time]\n\n        return events[-limit:]\n\n    def correlate_events(self, imsi: str,\n                        time_window: float = 60.0) -> List[NetworkEvent]:\n        \"\"\"Get events correlated by IMSI within time window.\"\"\"\n        now = datetime.utcnow()\n        correlated = []\n\n        for event in self._event_history:\n            # Check time window\n            if (now - event.timestamp).total_seconds() > time_window:\n                continue\n\n            # Check IMSI in event data\n            if event.data.get('imsi') == imsi:\n                correlated.append(event)\n\n        return correlated\n\n    def export_events(self, format: str = 'json') -> str:\n        \"\"\"Export event history.\"\"\"\n        import json\n\n        events = [\n            {\n                'event_id': e.event_id,\n                'event_type': e.event_type,\n                'timestamp': e.timestamp.isoformat(),\n                'source': e.source,\n                'data': e.data\n            }\n            for e in self._event_history\n        ]\n\n        if format == 'json':\n            return json.dumps(events, indent=2)\n        elif format == 'csv':\n            import csv\n            import io\n            output = io.StringIO()\n            writer = csv.writer(output)\n            writer.writerow(['event_id', 'event_type', 'timestamp', 'source', 'data'])\n            for e in events:\n                writer.writerow([e['event_id'], e['event_type'], e['timestamp'],\n                               e['source'], json.dumps(e['data'])])\n            return output.getvalue()\n\n        return ''\n```\n\n### 7. Scenario Runner\n\nTest scenario orchestration.\n\n```python\nfrom typing import Dict, Any, List, Optional\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom datetime import datetime\nimport asyncio\nimport yaml\n\nclass StepStatus(Enum):\n    PENDING = 'pending'\n    RUNNING = 'running'\n    PASSED = 'passed'\n    FAILED = 'failed'\n    SKIPPED = 'skipped'\n\n@dataclass\nclass ScenarioStep:\n    \"\"\"Scenario step definition.\"\"\"\n    name: str\n    action: str\n    params: Dict[str, Any] = field(default_factory=dict)\n    timeout: float = 30.0\n    continue_on_failure: bool = False\n    condition: Optional[str] = None\n\n@dataclass\nclass StepResult:\n    \"\"\"Step execution result.\"\"\"\n    step_name: str\n    status: StepStatus\n    start_time: datetime\n    end_time: Optional[datetime] = None\n    duration_ms: Optional[float] = None\n    error: Optional[str] = None\n    output: Optional[Dict[str, Any]] = None\n\n@dataclass\nclass Scenario:\n    \"\"\"Test scenario definition.\"\"\"\n    name: str\n    description: str\n    steps: List[ScenarioStep]\n    variables: Dict[str, Any] = field(default_factory=dict)\n\n    @classmethod\n    def from_yaml(cls, yaml_str: str) -> 'Scenario':\n        \"\"\"Load scenario from YAML.\"\"\"\n        data = yaml.safe_load(yaml_str)\n\n        steps = [\n            ScenarioStep(\n                name=s.get('name', f'step_{i}'),\n                action=s['action'],\n                params=s.get('params', {}),\n                timeout=s.get('timeout', 30.0),\n                continue_on_failure=s.get('continue_on_failure', False),\n                condition=s.get('condition')\n            )\n            for i, s in enumerate(data.get('steps', []))\n        ]\n\n        return cls(\n            name=data.get('name', 'Unnamed'),\n            description=data.get('description', ''),\n            steps=steps,\n            variables=data.get('variables', {})\n        )\n\n\nclass ScenarioRunner:\n    \"\"\"Executes test scenarios.\"\"\"\n\n    def __init__(self,\n                 simulator_manager: SimulatorManager,\n                 device_controller=None,\n                 server_controller=None,\n                 event_emitter: Optional['EventEmitter'] = None):\n        self._simulator = simulator_manager\n        self._device = device_controller\n        self._server = server_controller\n        self._event_emitter = event_emitter\n        self._running = False\n        self._current_scenario: Optional[Scenario] = None\n        self._results: List[StepResult] = []\n        self._variables: Dict[str, Any] = {}\n\n    async def run(self, scenario: Scenario) -> List[StepResult]:\n        \"\"\"Run scenario.\"\"\"\n        self._running = True\n        self._current_scenario = scenario\n        self._results = []\n        self._variables = dict(scenario.variables)\n\n        if self._event_emitter:\n            self._event_emitter.emit('scenario_started', {\n                'name': scenario.name,\n                'step_count': len(scenario.steps)\n            })\n\n        for step in scenario.steps:\n            if not self._running:\n                break\n\n            # Check condition\n            if step.condition and not self._evaluate_condition(step.condition):\n                result = StepResult(\n                    step_name=step.name,\n                    status=StepStatus.SKIPPED,\n                    start_time=datetime.utcnow()\n                )\n                self._results.append(result)\n                continue\n\n            # Execute step\n            result = await self._execute_step(step)\n            self._results.append(result)\n\n            if self._event_emitter:\n                self._event_emitter.emit('scenario_step_completed', {\n                    'step_name': step.name,\n                    'status': result.status.value,\n                    'duration_ms': result.duration_ms\n                })\n\n            # Check failure\n            if result.status == StepStatus.FAILED and not step.continue_on_failure:\n                break\n\n        self._running = False\n\n        if self._event_emitter:\n            self._event_emitter.emit('scenario_completed', {\n                'name': scenario.name,\n                'results': [\n                    {'step': r.step_name, 'status': r.status.value}\n                    for r in self._results\n                ]\n            })\n\n        return self._results\n\n    async def _execute_step(self, step: ScenarioStep) -> StepResult:\n        \"\"\"Execute single step.\"\"\"\n        start_time = datetime.utcnow()\n\n        result = StepResult(\n            step_name=step.name,\n            status=StepStatus.RUNNING,\n            start_time=start_time\n        )\n\n        try:\n            # Resolve parameters\n            params = self._resolve_params(step.params)\n\n            # Execute action\n            output = await asyncio.wait_for(\n                self._execute_action(step.action, params),\n                timeout=step.timeout\n            )\n\n            result.status = StepStatus.PASSED\n            result.output = output\n\n            # Store output in variables\n            if output and isinstance(output, dict):\n                self._variables.update(output)\n\n        except asyncio.TimeoutError:\n            result.status = StepStatus.FAILED\n            result.error = f\"Timeout after {step.timeout}s\"\n\n        except Exception as e:\n            result.status = StepStatus.FAILED\n            result.error = str(e)\n\n        result.end_time = datetime.utcnow()\n        result.duration_ms = (result.end_time - start_time).total_seconds() * 1000\n\n        return result\n\n    async def _execute_action(self, action: str, params: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        \"\"\"Execute action by name.\"\"\"\n        action_map = {\n            # Simulator actions\n            'simulator.start_cell': lambda p: self._simulator.cell.start(),\n            'simulator.stop_cell': lambda p: self._simulator.cell.stop(),\n            'simulator.wait_ue': lambda p: self._simulator.ue.wait_for_registration(\n                p['imsi'], p.get('timeout', 60)\n            ),\n            'simulator.send_sms': lambda p: self._simulator.sms.send_mt_sms(\n                p['imsi'], bytes.fromhex(p['pdu'])\n            ),\n            'simulator.trigger_event': lambda p: self._simulator._adapter.trigger_event(\n                p['type'], p.get('params', {})\n            ),\n\n            # Wait actions\n            'wait': lambda p: asyncio.sleep(p.get('seconds', 1)),\n\n            # Variable actions\n            'set_variable': lambda p: self._set_variable(p['name'], p['value']),\n        }\n\n        if action in action_map:\n            return await action_map[action](params)\n        else:\n            raise ValueError(f\"Unknown action: {action}\")\n\n    def _resolve_params(self, params: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Resolve variable references in params.\"\"\"\n        resolved = {}\n        for key, value in params.items():\n            if isinstance(value, str) and value.startswith('${') and value.endswith('}'):\n                var_name = value[2:-1]\n                resolved[key] = self._variables.get(var_name, value)\n            else:\n                resolved[key] = value\n        return resolved\n\n    def _evaluate_condition(self, condition: str) -> bool:\n        \"\"\"Evaluate condition expression.\"\"\"\n        # Simple variable existence check\n        if condition.startswith('defined:'):\n            var_name = condition[8:]\n            return var_name in self._variables\n\n        return True\n\n    def _set_variable(self, name: str, value: Any) -> Dict[str, Any]:\n        \"\"\"Set variable.\"\"\"\n        self._variables[name] = value\n        return {name: value}\n\n    def stop(self) -> None:\n        \"\"\"Stop scenario execution.\"\"\"\n        self._running = False\n\n    def get_results(self) -> List[StepResult]:\n        \"\"\"Get current results.\"\"\"\n        return self._results.copy()\n```\n\n## CLI Design\n\n### Command Structure\n\n```\ncardlink-netsim\n├── connect <url>           # Connect to simulator\n│   ├── --type <type>      # Simulator type (amarisoft)\n│   ├── --api-key <key>    # API key for auth\n│   └── --tls              # Enable TLS\n├── disconnect              # Disconnect from simulator\n├── status                  # Show simulator status\n│   └── --json             # JSON output\n├── cell                    # Cell operations\n│   ├── start              # Start cell\n│   ├── stop               # Stop cell\n│   └── status             # Cell status\n├── ue                      # UE operations\n│   ├── list               # List connected UEs\n│   ├── get <imsi>         # Get UE details\n│   ├── wait <imsi>        # Wait for registration\n│   │   └── --timeout <s>  # Wait timeout\n│   └── detach <imsi>      # Detach UE\n├── sms                     # SMS operations\n│   ├── send <imsi> <pdu>  # Send MT-SMS\n│   └── trigger <imsi>     # Send OTA trigger\n│       └── --tar <hex>    # TAR value\n├── event                   # Event operations\n│   ├── trigger <type>     # Trigger network event\n│   ├── list               # List recent events\n│   └── export <file>      # Export events\n├── scenario                # Scenario operations\n│   ├── run <file>         # Run scenario\n│   ├── validate <file>    # Validate scenario\n│   └── list               # List available scenarios\n└── config                  # Configuration\n    ├── show               # Show current config\n    ├── load <file>        # Load config\n    └── save <file>        # Save config\n```\n\n## Dependencies\n\n### Required Packages\n\n```\nwebsockets>=11.0           # WebSocket client\npyyaml>=6.0                # YAML scenario files\n```\n\n### Optional Packages\n\n```\naiohttp>=3.8.0             # Alternative HTTP client\n```\n",
  "fileStats": {
    "size": 55931,
    "lines": 1588,
    "lastModified": "2025-11-25T12:27:21.864Z"
  },
  "comments": []
}