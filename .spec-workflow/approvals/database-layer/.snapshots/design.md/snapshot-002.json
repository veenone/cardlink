{
  "id": "snapshot_1764071618545_9cjgorpzw",
  "approvalId": "approval_1764071606134_s44qwi91c",
  "approvalTitle": "Database Layer Design Document",
  "version": 2,
  "timestamp": "2025-11-25T11:53:38.545Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Database Layer\n\n## Introduction\n\nThis document describes the technical design for the Database Layer component of CardLink. The database layer provides persistent storage using SQLAlchemy ORM with support for SQLite, MySQL, and PostgreSQL backends, implementing the repository pattern for clean data access.\n\n## System Architecture\n\n### High-Level Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                              Application Layer                               │\n│         (PSK-TLS Server, Phone Controller, Modem Controller, etc.)          │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                            Repository Layer                                  │\n│  ┌───────────────┐ ┌───────────────┐ ┌───────────────┐ ┌───────────────┐   │\n│  │DeviceRepository│ │CardRepository │ │SessionRepository│ │LogRepository │   │\n│  └───────────────┘ └───────────────┘ └───────────────┘ └───────────────┘   │\n│  ┌───────────────┐ ┌───────────────┐ ┌───────────────┐                      │\n│  │TestRepository │ │SettingsRepo   │ │ QueryBuilder  │                      │\n│  └───────────────┘ └───────────────┘ └───────────────┘                      │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                           Unit of Work Layer                                 │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                        UnitOfWork                                    │   │\n│  │  - Transaction management                                            │   │\n│  │  - Session lifecycle                                                 │   │\n│  │  - Repository factory                                                │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                             Model Layer                                      │\n│  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐    │\n│  │  Device   │ │CardProfile│ │  Session  │ │CommLog    │ │TestResult │    │\n│  └───────────┘ └───────────┘ └───────────┘ └───────────┘ └───────────┘    │\n│  ┌───────────┐ ┌───────────┐                                               │\n│  │  Setting  │ │ BaseModel │                                               │\n│  └───────────┘ └───────────┘                                               │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                            Database Engine                                   │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                      DatabaseManager                                 │   │\n│  │  - Connection management                                             │   │\n│  │  - Engine configuration                                              │   │\n│  │  - Session factory                                                   │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                           Migration Layer                                    │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                     Alembic Migrations                               │   │\n│  │  - Version control                                                   │   │\n│  │  - Schema upgrades/downgrades                                        │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                          Database Backends                                   │\n│  ┌───────────────┐    ┌───────────────┐    ┌───────────────┐              │\n│  │    SQLite     │    │     MySQL     │    │  PostgreSQL   │              │\n│  │  (Default)    │    │   (Team)      │    │ (Enterprise)  │              │\n│  └───────────────┘    └───────────────┘    └───────────────┘              │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n### Component Descriptions\n\n| Component | Responsibility |\n|-----------|----------------|\n| **DatabaseManager** | Connection management, engine configuration, session factory |\n| **UnitOfWork** | Transaction management, repository access, commit/rollback |\n| **BaseModel** | SQLAlchemy declarative base with common fields |\n| **Device** | Phone and modem device configuration model |\n| **CardProfile** | UICC card profile model with encrypted PSK |\n| **Session** | OTA session record model |\n| **CommLog** | Communication log entry model |\n| **TestResult** | Test execution result model |\n| **Setting** | Server configuration setting model |\n| **DeviceRepository** | Device CRUD operations |\n| **CardRepository** | Card profile CRUD operations |\n| **SessionRepository** | Session CRUD and queries |\n| **LogRepository** | Communication log operations |\n| **TestRepository** | Test result operations |\n| **SettingsRepository** | Settings CRUD operations |\n| **QueryBuilder** | Dynamic query construction |\n\n## Component Design\n\n### 1. DatabaseManager\n\nManages database connections and session lifecycle.\n\n```python\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom sqlalchemy.pool import QueuePool, NullPool\nfrom contextlib import contextmanager\nfrom typing import Optional, Generator\nimport os\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass DatabaseConfig:\n    \"\"\"Database configuration.\"\"\"\n\n    def __init__(self,\n                 url: Optional[str] = None,\n                 pool_size: int = 5,\n                 max_overflow: int = 10,\n                 pool_timeout: int = 30,\n                 echo: bool = False):\n        self.url = url or os.environ.get('DATABASE_URL', 'sqlite:///data/cardlink.db')\n        self.pool_size = pool_size\n        self.max_overflow = max_overflow\n        self.pool_timeout = pool_timeout\n        self.echo = echo\n\n    @property\n    def is_sqlite(self) -> bool:\n        return self.url.startswith('sqlite')\n\n    @property\n    def is_mysql(self) -> bool:\n        return self.url.startswith('mysql')\n\n    @property\n    def is_postgresql(self) -> bool:\n        return self.url.startswith('postgresql')\n\n\nclass DatabaseManager:\n    \"\"\"Manages database connections and sessions.\"\"\"\n\n    def __init__(self, config: Optional[DatabaseConfig] = None):\n        self.config = config or DatabaseConfig()\n        self._engine = None\n        self._session_factory = None\n        self._initialized = False\n\n    def initialize(self) -> None:\n        \"\"\"Initialize database engine and session factory.\"\"\"\n        if self._initialized:\n            return\n\n        engine_kwargs = {\n            'echo': self.config.echo\n        }\n\n        # Configure pool based on backend\n        if self.config.is_sqlite:\n            # SQLite uses NullPool for thread safety\n            engine_kwargs['poolclass'] = NullPool\n            # Ensure directory exists\n            self._ensure_sqlite_directory()\n        else:\n            # MySQL/PostgreSQL use connection pooling\n            engine_kwargs['poolclass'] = QueuePool\n            engine_kwargs['pool_size'] = self.config.pool_size\n            engine_kwargs['max_overflow'] = self.config.max_overflow\n            engine_kwargs['pool_timeout'] = self.config.pool_timeout\n\n        self._engine = create_engine(self.config.url, **engine_kwargs)\n\n        # Configure SQLite for better concurrency\n        if self.config.is_sqlite:\n            self._configure_sqlite()\n\n        self._session_factory = sessionmaker(bind=self._engine)\n        self._initialized = True\n\n        logger.info(f\"Database initialized: {self._get_safe_url()}\")\n\n    def _ensure_sqlite_directory(self) -> None:\n        \"\"\"Create SQLite database directory if needed.\"\"\"\n        if ':///' in self.config.url:\n            db_path = self.config.url.split(':///')[-1]\n            if db_path != ':memory:':\n                os.makedirs(os.path.dirname(db_path) or '.', exist_ok=True)\n\n    def _configure_sqlite(self) -> None:\n        \"\"\"Configure SQLite for optimal performance.\"\"\"\n        @event.listens_for(self._engine, 'connect')\n        def set_sqlite_pragma(dbapi_connection, connection_record):\n            cursor = dbapi_connection.cursor()\n            # Enable WAL mode for concurrent reads\n            cursor.execute('PRAGMA journal_mode=WAL')\n            # Enable foreign keys\n            cursor.execute('PRAGMA foreign_keys=ON')\n            # Optimize synchronous mode\n            cursor.execute('PRAGMA synchronous=NORMAL')\n            # Increase cache size\n            cursor.execute('PRAGMA cache_size=-64000')  # 64MB\n            cursor.close()\n\n    def _get_safe_url(self) -> str:\n        \"\"\"Get URL with password redacted.\"\"\"\n        url = self.config.url\n        if '@' in url:\n            # Redact password\n            parts = url.split('@')\n            prefix = parts[0].rsplit(':', 1)[0]\n            return f\"{prefix}:***@{parts[1]}\"\n        return url\n\n    @property\n    def engine(self):\n        \"\"\"Get database engine.\"\"\"\n        if not self._initialized:\n            self.initialize()\n        return self._engine\n\n    def create_session(self) -> Session:\n        \"\"\"Create a new database session.\"\"\"\n        if not self._initialized:\n            self.initialize()\n        return self._session_factory()\n\n    @contextmanager\n    def session_scope(self) -> Generator[Session, None, None]:\n        \"\"\"Provide a transactional scope around operations.\"\"\"\n        session = self.create_session()\n        try:\n            yield session\n            session.commit()\n        except Exception:\n            session.rollback()\n            raise\n        finally:\n            session.close()\n\n    def create_tables(self) -> None:\n        \"\"\"Create all tables defined in models.\"\"\"\n        from .models import Base\n        Base.metadata.create_all(self.engine)\n        logger.info(\"Database tables created\")\n\n    def drop_tables(self) -> None:\n        \"\"\"Drop all tables (use with caution).\"\"\"\n        from .models import Base\n        Base.metadata.drop_all(self.engine)\n        logger.warning(\"Database tables dropped\")\n\n    def close(self) -> None:\n        \"\"\"Close database connections.\"\"\"\n        if self._engine:\n            self._engine.dispose()\n            self._initialized = False\n            logger.info(\"Database connections closed\")\n\n    def health_check(self) -> dict:\n        \"\"\"Check database health.\"\"\"\n        try:\n            with self.session_scope() as session:\n                session.execute('SELECT 1')\n            return {\n                'status': 'healthy',\n                'backend': self._get_backend_name(),\n                'url': self._get_safe_url()\n            }\n        except Exception as e:\n            return {\n                'status': 'unhealthy',\n                'error': str(e)\n            }\n\n    def _get_backend_name(self) -> str:\n        \"\"\"Get human-readable backend name.\"\"\"\n        if self.config.is_sqlite:\n            return 'SQLite'\n        elif self.config.is_mysql:\n            return 'MySQL'\n        elif self.config.is_postgresql:\n            return 'PostgreSQL'\n        return 'Unknown'\n```\n\n### 2. Model Definitions\n\nSQLAlchemy models for all entities.\n\n```python\nfrom sqlalchemy import (\n    Column, String, Integer, Float, Boolean, DateTime, Text,\n    ForeignKey, Enum, Index, JSON, LargeBinary\n)\nfrom sqlalchemy.orm import declarative_base, relationship\nfrom sqlalchemy.sql import func\nfrom datetime import datetime\nfrom typing import Optional\nimport enum\nimport uuid\n\nBase = declarative_base()\n\ndef generate_uuid() -> str:\n    \"\"\"Generate UUID string.\"\"\"\n    return str(uuid.uuid4())\n\n\nclass TimestampMixin:\n    \"\"\"Mixin for created/updated timestamps.\"\"\"\n    created_at = Column(DateTime, default=func.now(), nullable=False)\n    updated_at = Column(DateTime, default=func.now(), onupdate=func.now(), nullable=False)\n\n\nclass DeviceType(enum.Enum):\n    \"\"\"Device type enumeration.\"\"\"\n    PHONE = 'phone'\n    MODEM = 'modem'\n\n\nclass SessionStatus(enum.Enum):\n    \"\"\"OTA session status enumeration.\"\"\"\n    PENDING = 'pending'\n    ACTIVE = 'active'\n    COMPLETED = 'completed'\n    FAILED = 'failed'\n    TIMEOUT = 'timeout'\n\n\nclass TestStatus(enum.Enum):\n    \"\"\"Test result status enumeration.\"\"\"\n    PASSED = 'passed'\n    FAILED = 'failed'\n    SKIPPED = 'skipped'\n    ERROR = 'error'\n\n\nclass Device(Base, TimestampMixin):\n    \"\"\"Device configuration model (phones and modems).\"\"\"\n\n    __tablename__ = 'devices'\n\n    id = Column(String(64), primary_key=True)  # ADB serial or serial port\n    name = Column(String(128), nullable=True)  # User-friendly alias\n    device_type = Column(Enum(DeviceType), nullable=False)\n\n    # Device info\n    manufacturer = Column(String(64), nullable=True)\n    model = Column(String(64), nullable=True)\n    firmware_version = Column(String(64), nullable=True)\n\n    # Identifiers\n    imei = Column(String(20), nullable=True)\n    imsi = Column(String(20), nullable=True)\n    iccid = Column(String(22), nullable=True)\n\n    # Connection settings (JSON for flexibility)\n    connection_settings = Column(JSON, nullable=True)\n\n    # Status\n    last_seen = Column(DateTime, nullable=True)\n    is_active = Column(Boolean, default=True)\n\n    # Notes\n    notes = Column(Text, nullable=True)\n\n    # Relationships\n    sessions = relationship('OTASession', back_populates='device')\n    test_results = relationship('TestResult', back_populates='device')\n\n    __table_args__ = (\n        Index('idx_device_type', 'device_type'),\n        Index('idx_device_iccid', 'iccid'),\n        Index('idx_device_last_seen', 'last_seen'),\n    )\n\n\nclass CardProfile(Base, TimestampMixin):\n    \"\"\"UICC card profile model.\"\"\"\n\n    __tablename__ = 'card_profiles'\n\n    iccid = Column(String(22), primary_key=True)\n    imsi = Column(String(20), nullable=True)\n    card_type = Column(String(20), default='UICC')  # UICC, USIM, eUICC\n    atr = Column(String(128), nullable=True)  # Hex encoded\n\n    # PSK configuration\n    psk_identity = Column(String(128), nullable=True)\n    psk_key_encrypted = Column(LargeBinary, nullable=True)  # Encrypted key\n\n    # Server configuration\n    admin_url = Column(String(255), nullable=True)\n\n    # Trigger configuration (JSON)\n    trigger_config = Column(JSON, nullable=True)\n\n    # BIP configuration (JSON)\n    bip_config = Column(JSON, nullable=True)\n\n    # Security Domain info (JSON)\n    security_domains = Column(JSON, nullable=True)\n\n    # Notes\n    notes = Column(Text, nullable=True)\n\n    # Relationships\n    sessions = relationship('OTASession', back_populates='card')\n    test_results = relationship('TestResult', back_populates='card')\n\n    __table_args__ = (\n        Index('idx_card_type', 'card_type'),\n        Index('idx_card_psk_identity', 'psk_identity'),\n    )\n\n\nclass OTASession(Base, TimestampMixin):\n    \"\"\"OTA session record model.\"\"\"\n\n    __tablename__ = 'ota_sessions'\n\n    id = Column(String(36), primary_key=True, default=generate_uuid)\n    device_id = Column(String(64), ForeignKey('devices.id'), nullable=True)\n    card_iccid = Column(String(22), ForeignKey('card_profiles.iccid'), nullable=True)\n\n    # Session info\n    session_type = Column(String(20), nullable=True)  # triggered, polled\n    status = Column(Enum(SessionStatus), default=SessionStatus.PENDING)\n\n    # Timestamps\n    started_at = Column(DateTime, nullable=True)\n    ended_at = Column(DateTime, nullable=True)\n    duration_ms = Column(Integer, nullable=True)\n\n    # TLS info\n    tls_cipher_suite = Column(String(64), nullable=True)\n    tls_psk_identity = Column(String(128), nullable=True)\n\n    # Error info\n    error_code = Column(String(32), nullable=True)\n    error_message = Column(Text, nullable=True)\n\n    # Relationships\n    device = relationship('Device', back_populates='sessions')\n    card = relationship('CardProfile', back_populates='sessions')\n    comm_logs = relationship('CommLog', back_populates='session', cascade='all, delete-orphan')\n\n    __table_args__ = (\n        Index('idx_session_device', 'device_id'),\n        Index('idx_session_card', 'card_iccid'),\n        Index('idx_session_status', 'status'),\n        Index('idx_session_created', 'created_at'),\n    )\n\n\nclass CommLog(Base):\n    \"\"\"Communication log entry model.\"\"\"\n\n    __tablename__ = 'comm_logs'\n\n    id = Column(Integer, primary_key=True, autoincrement=True)\n    session_id = Column(String(36), ForeignKey('ota_sessions.id'), nullable=False)\n\n    # Timing\n    timestamp = Column(DateTime, default=func.now(), nullable=False)\n    latency_ms = Column(Float, nullable=True)\n\n    # Data\n    direction = Column(String(10), nullable=False)  # command, response\n    raw_data = Column(Text, nullable=False)  # Hex encoded\n    decoded_data = Column(Text, nullable=True)\n\n    # Response info\n    status_word = Column(String(4), nullable=True)  # Hex SW1SW2\n    status_message = Column(String(128), nullable=True)\n\n    # Relationships\n    session = relationship('OTASession', back_populates='comm_logs')\n\n    __table_args__ = (\n        Index('idx_log_session', 'session_id'),\n        Index('idx_log_timestamp', 'timestamp'),\n        Index('idx_log_direction', 'direction'),\n    )\n\n\nclass TestResult(Base, TimestampMixin):\n    \"\"\"Test execution result model.\"\"\"\n\n    __tablename__ = 'test_results'\n\n    id = Column(String(36), primary_key=True, default=generate_uuid)\n    run_id = Column(String(36), nullable=False)  # Groups results by test run\n\n    # Test info\n    suite_name = Column(String(128), nullable=False)\n    test_name = Column(String(256), nullable=False)\n\n    # Device and card\n    device_id = Column(String(64), ForeignKey('devices.id'), nullable=True)\n    card_iccid = Column(String(22), ForeignKey('card_profiles.iccid'), nullable=True)\n\n    # Timing\n    started_at = Column(DateTime, nullable=False)\n    ended_at = Column(DateTime, nullable=True)\n    duration_ms = Column(Integer, nullable=True)\n\n    # Result\n    status = Column(Enum(TestStatus), nullable=False)\n    error_message = Column(Text, nullable=True)\n\n    # Details (JSON)\n    assertions = Column(JSON, nullable=True)  # Array of assertion results\n    metadata = Column(JSON, nullable=True)  # Additional test metadata\n\n    # Relationships\n    device = relationship('Device', back_populates='test_results')\n    card = relationship('CardProfile', back_populates='test_results')\n\n    __table_args__ = (\n        Index('idx_test_run', 'run_id'),\n        Index('idx_test_suite', 'suite_name'),\n        Index('idx_test_status', 'status'),\n        Index('idx_test_created', 'created_at'),\n    )\n\n\nclass Setting(Base, TimestampMixin):\n    \"\"\"Server configuration setting model.\"\"\"\n\n    __tablename__ = 'settings'\n\n    key = Column(String(128), primary_key=True)\n    value = Column(JSON, nullable=True)\n    description = Column(String(256), nullable=True)\n    category = Column(String(64), default='general')\n\n    __table_args__ = (\n        Index('idx_setting_category', 'category'),\n    )\n```\n\n### 3. Unit of Work\n\nTransaction management and repository factory.\n\n```python\nfrom typing import TypeVar, Type, Optional\nfrom sqlalchemy.orm import Session\n\nT = TypeVar('T')\n\nclass UnitOfWork:\n    \"\"\"Unit of Work pattern implementation.\"\"\"\n\n    def __init__(self, db_manager: DatabaseManager):\n        self._db_manager = db_manager\n        self._session: Optional[Session] = None\n        self._repositories: dict = {}\n\n    def __enter__(self) -> 'UnitOfWork':\n        self._session = self._db_manager.create_session()\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is not None:\n            self.rollback()\n        self.close()\n\n    @property\n    def session(self) -> Session:\n        \"\"\"Get current session.\"\"\"\n        if self._session is None:\n            raise RuntimeError(\"UnitOfWork not entered\")\n        return self._session\n\n    def commit(self) -> None:\n        \"\"\"Commit current transaction.\"\"\"\n        self._session.commit()\n\n    def rollback(self) -> None:\n        \"\"\"Rollback current transaction.\"\"\"\n        self._session.rollback()\n\n    def close(self) -> None:\n        \"\"\"Close session.\"\"\"\n        if self._session:\n            self._session.close()\n            self._session = None\n            self._repositories.clear()\n\n    def _get_repository(self, repo_class: Type[T]) -> T:\n        \"\"\"Get or create repository instance.\"\"\"\n        if repo_class not in self._repositories:\n            self._repositories[repo_class] = repo_class(self._session)\n        return self._repositories[repo_class]\n\n    @property\n    def devices(self) -> 'DeviceRepository':\n        \"\"\"Device repository.\"\"\"\n        return self._get_repository(DeviceRepository)\n\n    @property\n    def cards(self) -> 'CardRepository':\n        \"\"\"Card profile repository.\"\"\"\n        return self._get_repository(CardRepository)\n\n    @property\n    def sessions(self) -> 'SessionRepository':\n        \"\"\"Session repository.\"\"\"\n        return self._get_repository(SessionRepository)\n\n    @property\n    def logs(self) -> 'LogRepository':\n        \"\"\"Communication log repository.\"\"\"\n        return self._get_repository(LogRepository)\n\n    @property\n    def tests(self) -> 'TestRepository':\n        \"\"\"Test result repository.\"\"\"\n        return self._get_repository(TestRepository)\n\n    @property\n    def settings(self) -> 'SettingsRepository':\n        \"\"\"Settings repository.\"\"\"\n        return self._get_repository(SettingsRepository)\n```\n\n### 4. Base Repository\n\nGeneric repository implementation.\n\n```python\nfrom typing import TypeVar, Generic, Type, List, Optional, Dict, Any\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import and_, or_\nfrom dataclasses import dataclass\n\nT = TypeVar('T')\n\n@dataclass\nclass Page:\n    \"\"\"Pagination result.\"\"\"\n    items: List[Any]\n    total: int\n    page: int\n    per_page: int\n    pages: int\n\n\nclass BaseRepository(Generic[T]):\n    \"\"\"Base repository with common CRUD operations.\"\"\"\n\n    def __init__(self, session: Session, model_class: Type[T]):\n        self._session = session\n        self._model_class = model_class\n\n    def get_by_id(self, id: Any) -> Optional[T]:\n        \"\"\"Get entity by primary key.\"\"\"\n        return self._session.get(self._model_class, id)\n\n    def get_all(self, limit: Optional[int] = None) -> List[T]:\n        \"\"\"Get all entities with optional limit.\"\"\"\n        query = self._session.query(self._model_class)\n        if limit:\n            query = query.limit(limit)\n        return query.all()\n\n    def find_by(self, **kwargs) -> List[T]:\n        \"\"\"Find entities by attributes.\"\"\"\n        query = self._session.query(self._model_class)\n        for key, value in kwargs.items():\n            if hasattr(self._model_class, key):\n                query = query.filter(getattr(self._model_class, key) == value)\n        return query.all()\n\n    def find_one_by(self, **kwargs) -> Optional[T]:\n        \"\"\"Find single entity by attributes.\"\"\"\n        results = self.find_by(**kwargs)\n        return results[0] if results else None\n\n    def create(self, entity: T) -> T:\n        \"\"\"Create new entity.\"\"\"\n        self._session.add(entity)\n        self._session.flush()\n        return entity\n\n    def create_all(self, entities: List[T]) -> List[T]:\n        \"\"\"Create multiple entities.\"\"\"\n        self._session.add_all(entities)\n        self._session.flush()\n        return entities\n\n    def update(self, entity: T) -> T:\n        \"\"\"Update existing entity.\"\"\"\n        self._session.merge(entity)\n        self._session.flush()\n        return entity\n\n    def delete(self, entity: T) -> None:\n        \"\"\"Delete entity.\"\"\"\n        self._session.delete(entity)\n        self._session.flush()\n\n    def delete_by_id(self, id: Any) -> bool:\n        \"\"\"Delete entity by ID.\"\"\"\n        entity = self.get_by_id(id)\n        if entity:\n            self.delete(entity)\n            return True\n        return False\n\n    def exists(self, id: Any) -> bool:\n        \"\"\"Check if entity exists.\"\"\"\n        return self.get_by_id(id) is not None\n\n    def count(self) -> int:\n        \"\"\"Count all entities.\"\"\"\n        return self._session.query(self._model_class).count()\n\n    def count_by(self, **kwargs) -> int:\n        \"\"\"Count entities matching criteria.\"\"\"\n        query = self._session.query(self._model_class)\n        for key, value in kwargs.items():\n            if hasattr(self._model_class, key):\n                query = query.filter(getattr(self._model_class, key) == value)\n        return query.count()\n\n    def paginate(self, page: int = 1, per_page: int = 20,\n                 order_by: Optional[str] = None,\n                 descending: bool = False) -> Page:\n        \"\"\"Get paginated results.\"\"\"\n        query = self._session.query(self._model_class)\n\n        # Apply ordering\n        if order_by and hasattr(self._model_class, order_by):\n            column = getattr(self._model_class, order_by)\n            query = query.order_by(column.desc() if descending else column)\n\n        # Count total\n        total = query.count()\n\n        # Calculate pagination\n        pages = (total + per_page - 1) // per_page\n        offset = (page - 1) * per_page\n\n        # Fetch items\n        items = query.offset(offset).limit(per_page).all()\n\n        return Page(\n            items=items,\n            total=total,\n            page=page,\n            per_page=per_page,\n            pages=pages\n        )\n```\n\n### 5. Device Repository\n\nDevice-specific repository operations.\n\n```python\nfrom typing import List, Optional\nfrom datetime import datetime, timedelta\nfrom sqlalchemy import or_\n\nclass DeviceRepository(BaseRepository[Device]):\n    \"\"\"Repository for device operations.\"\"\"\n\n    def __init__(self, session: Session):\n        super().__init__(session, Device)\n\n    def find_by_type(self, device_type: DeviceType) -> List[Device]:\n        \"\"\"Find devices by type.\"\"\"\n        return self._session.query(Device).filter(\n            Device.device_type == device_type\n        ).all()\n\n    def find_phones(self) -> List[Device]:\n        \"\"\"Find all phone devices.\"\"\"\n        return self.find_by_type(DeviceType.PHONE)\n\n    def find_modems(self) -> List[Device]:\n        \"\"\"Find all modem devices.\"\"\"\n        return self.find_by_type(DeviceType.MODEM)\n\n    def find_active(self) -> List[Device]:\n        \"\"\"Find all active devices.\"\"\"\n        return self._session.query(Device).filter(\n            Device.is_active == True\n        ).all()\n\n    def find_recent(self, hours: int = 24) -> List[Device]:\n        \"\"\"Find devices seen recently.\"\"\"\n        cutoff = datetime.utcnow() - timedelta(hours=hours)\n        return self._session.query(Device).filter(\n            Device.last_seen >= cutoff\n        ).all()\n\n    def search(self, query: str) -> List[Device]:\n        \"\"\"Search devices by name or ID.\"\"\"\n        pattern = f'%{query}%'\n        return self._session.query(Device).filter(\n            or_(\n                Device.id.ilike(pattern),\n                Device.name.ilike(pattern),\n                Device.model.ilike(pattern)\n            )\n        ).all()\n\n    def update_last_seen(self, device_id: str) -> None:\n        \"\"\"Update device last seen timestamp.\"\"\"\n        self._session.query(Device).filter(\n            Device.id == device_id\n        ).update({'last_seen': datetime.utcnow()})\n\n    def find_by_iccid(self, iccid: str) -> List[Device]:\n        \"\"\"Find devices with specific ICCID.\"\"\"\n        return self._session.query(Device).filter(\n            Device.iccid == iccid\n        ).all()\n\n    def deactivate(self, device_id: str) -> bool:\n        \"\"\"Deactivate a device.\"\"\"\n        result = self._session.query(Device).filter(\n            Device.id == device_id\n        ).update({'is_active': False})\n        return result > 0\n```\n\n### 6. Card Repository\n\nCard profile repository with encryption support.\n\n```python\nfrom typing import List, Optional\nfrom cryptography.fernet import Fernet\nimport os\n\nclass CardRepository(BaseRepository[CardProfile]):\n    \"\"\"Repository for card profile operations.\"\"\"\n\n    def __init__(self, session: Session, encryption_key: Optional[bytes] = None):\n        super().__init__(session, CardProfile)\n        self._encryption_key = encryption_key or self._get_encryption_key()\n        self._cipher = Fernet(self._encryption_key) if self._encryption_key else None\n\n    def _get_encryption_key(self) -> Optional[bytes]:\n        \"\"\"Get encryption key from environment.\"\"\"\n        key = os.environ.get('CARDLINK_ENCRYPTION_KEY')\n        if key:\n            return key.encode()\n        return None\n\n    def create_with_psk(self, profile: CardProfile, psk_key: bytes) -> CardProfile:\n        \"\"\"Create profile with encrypted PSK key.\"\"\"\n        if self._cipher:\n            profile.psk_key_encrypted = self._cipher.encrypt(psk_key)\n        else:\n            # Warning: storing without encryption\n            profile.psk_key_encrypted = psk_key\n        return self.create(profile)\n\n    def get_psk_key(self, iccid: str) -> Optional[bytes]:\n        \"\"\"Get decrypted PSK key.\"\"\"\n        profile = self.get_by_id(iccid)\n        if profile and profile.psk_key_encrypted:\n            if self._cipher:\n                return self._cipher.decrypt(profile.psk_key_encrypted)\n            return profile.psk_key_encrypted\n        return None\n\n    def update_psk(self, iccid: str, psk_identity: str, psk_key: bytes) -> bool:\n        \"\"\"Update PSK configuration.\"\"\"\n        profile = self.get_by_id(iccid)\n        if not profile:\n            return False\n\n        profile.psk_identity = psk_identity\n        if self._cipher:\n            profile.psk_key_encrypted = self._cipher.encrypt(psk_key)\n        else:\n            profile.psk_key_encrypted = psk_key\n\n        self._session.flush()\n        return True\n\n    def find_by_type(self, card_type: str) -> List[CardProfile]:\n        \"\"\"Find profiles by card type.\"\"\"\n        return self._session.query(CardProfile).filter(\n            CardProfile.card_type == card_type\n        ).all()\n\n    def find_with_psk(self) -> List[CardProfile]:\n        \"\"\"Find profiles with PSK configured.\"\"\"\n        return self._session.query(CardProfile).filter(\n            CardProfile.psk_identity.isnot(None)\n        ).all()\n\n    def find_by_admin_url(self, url: str) -> List[CardProfile]:\n        \"\"\"Find profiles by admin URL.\"\"\"\n        return self._session.query(CardProfile).filter(\n            CardProfile.admin_url == url\n        ).all()\n\n    def export_profile(self, iccid: str, include_key: bool = False) -> Optional[dict]:\n        \"\"\"Export profile as dictionary.\"\"\"\n        profile = self.get_by_id(iccid)\n        if not profile:\n            return None\n\n        data = {\n            'iccid': profile.iccid,\n            'imsi': profile.imsi,\n            'card_type': profile.card_type,\n            'atr': profile.atr,\n            'psk_identity': profile.psk_identity,\n            'admin_url': profile.admin_url,\n            'trigger_config': profile.trigger_config,\n            'bip_config': profile.bip_config,\n            'notes': profile.notes\n        }\n\n        if include_key and profile.psk_key_encrypted:\n            key = self.get_psk_key(iccid)\n            if key:\n                data['psk_key'] = key.hex()\n\n        return data\n```\n\n### 7. Session Repository\n\nOTA session repository with query capabilities.\n\n```python\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime, timedelta\nfrom sqlalchemy import func, and_\n\nclass SessionRepository(BaseRepository[OTASession]):\n    \"\"\"Repository for OTA session operations.\"\"\"\n\n    def __init__(self, session: Session):\n        super().__init__(session, OTASession)\n\n    def create_session(self, device_id: str = None,\n                      card_iccid: str = None,\n                      session_type: str = None) -> OTASession:\n        \"\"\"Create new OTA session.\"\"\"\n        ota_session = OTASession(\n            device_id=device_id,\n            card_iccid=card_iccid,\n            session_type=session_type,\n            status=SessionStatus.PENDING\n        )\n        return self.create(ota_session)\n\n    def start_session(self, session_id: str) -> bool:\n        \"\"\"Mark session as started.\"\"\"\n        result = self._session.query(OTASession).filter(\n            OTASession.id == session_id\n        ).update({\n            'status': SessionStatus.ACTIVE,\n            'started_at': datetime.utcnow()\n        })\n        return result > 0\n\n    def complete_session(self, session_id: str) -> bool:\n        \"\"\"Mark session as completed.\"\"\"\n        ota_session = self.get_by_id(session_id)\n        if not ota_session:\n            return False\n\n        now = datetime.utcnow()\n        duration = None\n        if ota_session.started_at:\n            duration = int((now - ota_session.started_at).total_seconds() * 1000)\n\n        self._session.query(OTASession).filter(\n            OTASession.id == session_id\n        ).update({\n            'status': SessionStatus.COMPLETED,\n            'ended_at': now,\n            'duration_ms': duration\n        })\n        return True\n\n    def fail_session(self, session_id: str, error_code: str,\n                    error_message: str) -> bool:\n        \"\"\"Mark session as failed.\"\"\"\n        ota_session = self.get_by_id(session_id)\n        if not ota_session:\n            return False\n\n        now = datetime.utcnow()\n        duration = None\n        if ota_session.started_at:\n            duration = int((now - ota_session.started_at).total_seconds() * 1000)\n\n        self._session.query(OTASession).filter(\n            OTASession.id == session_id\n        ).update({\n            'status': SessionStatus.FAILED,\n            'ended_at': now,\n            'duration_ms': duration,\n            'error_code': error_code,\n            'error_message': error_message\n        })\n        return True\n\n    def set_tls_info(self, session_id: str, cipher_suite: str,\n                    psk_identity: str) -> bool:\n        \"\"\"Set TLS session information.\"\"\"\n        result = self._session.query(OTASession).filter(\n            OTASession.id == session_id\n        ).update({\n            'tls_cipher_suite': cipher_suite,\n            'tls_psk_identity': psk_identity\n        })\n        return result > 0\n\n    def find_by_device(self, device_id: str,\n                      limit: int = 100) -> List[OTASession]:\n        \"\"\"Find sessions for device.\"\"\"\n        return self._session.query(OTASession).filter(\n            OTASession.device_id == device_id\n        ).order_by(OTASession.created_at.desc()).limit(limit).all()\n\n    def find_by_card(self, iccid: str, limit: int = 100) -> List[OTASession]:\n        \"\"\"Find sessions for card.\"\"\"\n        return self._session.query(OTASession).filter(\n            OTASession.card_iccid == iccid\n        ).order_by(OTASession.created_at.desc()).limit(limit).all()\n\n    def find_by_status(self, status: SessionStatus) -> List[OTASession]:\n        \"\"\"Find sessions by status.\"\"\"\n        return self._session.query(OTASession).filter(\n            OTASession.status == status\n        ).all()\n\n    def find_active(self) -> List[OTASession]:\n        \"\"\"Find currently active sessions.\"\"\"\n        return self.find_by_status(SessionStatus.ACTIVE)\n\n    def find_by_date_range(self, start: datetime,\n                          end: datetime) -> List[OTASession]:\n        \"\"\"Find sessions in date range.\"\"\"\n        return self._session.query(OTASession).filter(\n            and_(\n                OTASession.created_at >= start,\n                OTASession.created_at <= end\n            )\n        ).order_by(OTASession.created_at.desc()).all()\n\n    def get_statistics(self, days: int = 7) -> Dict[str, Any]:\n        \"\"\"Get session statistics.\"\"\"\n        cutoff = datetime.utcnow() - timedelta(days=days)\n\n        # Total sessions\n        total = self._session.query(OTASession).filter(\n            OTASession.created_at >= cutoff\n        ).count()\n\n        # By status\n        by_status = {}\n        for status in SessionStatus:\n            count = self._session.query(OTASession).filter(\n                and_(\n                    OTASession.created_at >= cutoff,\n                    OTASession.status == status\n                )\n            ).count()\n            by_status[status.value] = count\n\n        # Average duration for completed\n        avg_duration = self._session.query(\n            func.avg(OTASession.duration_ms)\n        ).filter(\n            and_(\n                OTASession.created_at >= cutoff,\n                OTASession.status == SessionStatus.COMPLETED\n            )\n        ).scalar()\n\n        # Success rate\n        completed = by_status.get('completed', 0)\n        failed = by_status.get('failed', 0)\n        success_rate = completed / (completed + failed) if (completed + failed) > 0 else 0\n\n        return {\n            'period_days': days,\n            'total_sessions': total,\n            'by_status': by_status,\n            'avg_duration_ms': avg_duration,\n            'success_rate': success_rate\n        }\n```\n\n### 8. Log Repository\n\nCommunication log repository with batch operations.\n\n```python\nfrom typing import List, Optional\nfrom datetime import datetime, timedelta\nfrom sqlalchemy import and_\n\nclass LogRepository(BaseRepository[CommLog]):\n    \"\"\"Repository for communication log operations.\"\"\"\n\n    def __init__(self, session: Session):\n        super().__init__(session, CommLog)\n        self._batch: List[CommLog] = []\n        self._batch_size = 100\n\n    def add_log(self, session_id: str, direction: str, raw_data: str,\n                decoded_data: str = None, status_word: str = None,\n                status_message: str = None, latency_ms: float = None) -> CommLog:\n        \"\"\"Add single log entry.\"\"\"\n        log = CommLog(\n            session_id=session_id,\n            direction=direction,\n            raw_data=raw_data,\n            decoded_data=decoded_data,\n            status_word=status_word,\n            status_message=status_message,\n            latency_ms=latency_ms\n        )\n        return self.create(log)\n\n    def add_log_batch(self, session_id: str, direction: str, raw_data: str,\n                      **kwargs) -> None:\n        \"\"\"Add log to batch (for high-throughput logging).\"\"\"\n        log = CommLog(\n            session_id=session_id,\n            direction=direction,\n            raw_data=raw_data,\n            **kwargs\n        )\n        self._batch.append(log)\n\n        if len(self._batch) >= self._batch_size:\n            self.flush_batch()\n\n    def flush_batch(self) -> int:\n        \"\"\"Flush batch to database.\"\"\"\n        if not self._batch:\n            return 0\n\n        count = len(self._batch)\n        self._session.bulk_save_objects(self._batch)\n        self._session.flush()\n        self._batch.clear()\n        return count\n\n    def find_by_session(self, session_id: str) -> List[CommLog]:\n        \"\"\"Find all logs for session.\"\"\"\n        return self._session.query(CommLog).filter(\n            CommLog.session_id == session_id\n        ).order_by(CommLog.timestamp).all()\n\n    def find_by_direction(self, session_id: str,\n                         direction: str) -> List[CommLog]:\n        \"\"\"Find logs by direction.\"\"\"\n        return self._session.query(CommLog).filter(\n            and_(\n                CommLog.session_id == session_id,\n                CommLog.direction == direction\n            )\n        ).order_by(CommLog.timestamp).all()\n\n    def find_commands(self, session_id: str) -> List[CommLog]:\n        \"\"\"Find command logs.\"\"\"\n        return self.find_by_direction(session_id, 'command')\n\n    def find_responses(self, session_id: str) -> List[CommLog]:\n        \"\"\"Find response logs.\"\"\"\n        return self.find_by_direction(session_id, 'response')\n\n    def find_by_status(self, session_id: str, status_word: str) -> List[CommLog]:\n        \"\"\"Find logs by status word.\"\"\"\n        return self._session.query(CommLog).filter(\n            and_(\n                CommLog.session_id == session_id,\n                CommLog.status_word == status_word\n            )\n        ).all()\n\n    def find_errors(self, session_id: str) -> List[CommLog]:\n        \"\"\"Find error responses (non-9000 status).\"\"\"\n        return self._session.query(CommLog).filter(\n            and_(\n                CommLog.session_id == session_id,\n                CommLog.direction == 'response',\n                CommLog.status_word.isnot(None),\n                CommLog.status_word != '9000'\n            )\n        ).all()\n\n    def search_hex(self, pattern: str,\n                  session_id: str = None) -> List[CommLog]:\n        \"\"\"Search logs by hex pattern.\"\"\"\n        query = self._session.query(CommLog).filter(\n            CommLog.raw_data.ilike(f'%{pattern}%')\n        )\n        if session_id:\n            query = query.filter(CommLog.session_id == session_id)\n        return query.all()\n\n    def purge_old(self, days: int) -> int:\n        \"\"\"Delete logs older than specified days.\"\"\"\n        cutoff = datetime.utcnow() - timedelta(days=days)\n        result = self._session.query(CommLog).filter(\n            CommLog.timestamp < cutoff\n        ).delete()\n        return result\n\n    def count_by_session(self, session_id: str) -> int:\n        \"\"\"Count logs for session.\"\"\"\n        return self._session.query(CommLog).filter(\n            CommLog.session_id == session_id\n        ).count()\n\n    def export_session_logs(self, session_id: str) -> List[dict]:\n        \"\"\"Export logs as dictionaries.\"\"\"\n        logs = self.find_by_session(session_id)\n        return [\n            {\n                'timestamp': log.timestamp.isoformat(),\n                'direction': log.direction,\n                'raw_data': log.raw_data,\n                'decoded_data': log.decoded_data,\n                'status_word': log.status_word,\n                'status_message': log.status_message,\n                'latency_ms': log.latency_ms\n            }\n            for log in logs\n        ]\n```\n\n### 9. Test Repository\n\nTest result repository with reporting capabilities.\n\n```python\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime, timedelta\nfrom sqlalchemy import func, and_\nimport xml.etree.ElementTree as ET\n\nclass TestRepository(BaseRepository[TestResult]):\n    \"\"\"Repository for test result operations.\"\"\"\n\n    def __init__(self, session: Session):\n        super().__init__(session, TestResult)\n\n    def create_result(self, run_id: str, suite_name: str, test_name: str,\n                     status: TestStatus, started_at: datetime,\n                     device_id: str = None, card_iccid: str = None,\n                     ended_at: datetime = None, duration_ms: int = None,\n                     error_message: str = None, assertions: list = None,\n                     metadata: dict = None) -> TestResult:\n        \"\"\"Create test result.\"\"\"\n        result = TestResult(\n            run_id=run_id,\n            suite_name=suite_name,\n            test_name=test_name,\n            device_id=device_id,\n            card_iccid=card_iccid,\n            status=status,\n            started_at=started_at,\n            ended_at=ended_at or datetime.utcnow(),\n            duration_ms=duration_ms,\n            error_message=error_message,\n            assertions=assertions,\n            metadata=metadata\n        )\n        return self.create(result)\n\n    def find_by_run(self, run_id: str) -> List[TestResult]:\n        \"\"\"Find all results for a test run.\"\"\"\n        return self._session.query(TestResult).filter(\n            TestResult.run_id == run_id\n        ).order_by(TestResult.started_at).all()\n\n    def find_by_suite(self, suite_name: str,\n                     limit: int = 100) -> List[TestResult]:\n        \"\"\"Find results by suite.\"\"\"\n        return self._session.query(TestResult).filter(\n            TestResult.suite_name == suite_name\n        ).order_by(TestResult.created_at.desc()).limit(limit).all()\n\n    def find_by_status(self, status: TestStatus) -> List[TestResult]:\n        \"\"\"Find results by status.\"\"\"\n        return self._session.query(TestResult).filter(\n            TestResult.status == status\n        ).all()\n\n    def find_failures(self, run_id: str = None) -> List[TestResult]:\n        \"\"\"Find failed tests.\"\"\"\n        query = self._session.query(TestResult).filter(\n            TestResult.status == TestStatus.FAILED\n        )\n        if run_id:\n            query = query.filter(TestResult.run_id == run_id)\n        return query.all()\n\n    def get_run_summary(self, run_id: str) -> Dict[str, Any]:\n        \"\"\"Get summary for test run.\"\"\"\n        results = self.find_by_run(run_id)\n\n        if not results:\n            return {}\n\n        summary = {\n            'run_id': run_id,\n            'total': len(results),\n            'passed': 0,\n            'failed': 0,\n            'skipped': 0,\n            'error': 0,\n            'duration_ms': 0,\n            'started_at': None,\n            'ended_at': None\n        }\n\n        for result in results:\n            summary[result.status.value] += 1\n            if result.duration_ms:\n                summary['duration_ms'] += result.duration_ms\n\n            if summary['started_at'] is None or result.started_at < summary['started_at']:\n                summary['started_at'] = result.started_at\n            if summary['ended_at'] is None or result.ended_at > summary['ended_at']:\n                summary['ended_at'] = result.ended_at\n\n        summary['pass_rate'] = summary['passed'] / summary['total'] if summary['total'] > 0 else 0\n\n        return summary\n\n    def compare_runs(self, run_id1: str, run_id2: str) -> Dict[str, Any]:\n        \"\"\"Compare two test runs for regressions.\"\"\"\n        results1 = {r.test_name: r for r in self.find_by_run(run_id1)}\n        results2 = {r.test_name: r for r in self.find_by_run(run_id2)}\n\n        regressions = []\n        improvements = []\n        new_tests = []\n        removed_tests = []\n\n        for name, r2 in results2.items():\n            if name in results1:\n                r1 = results1[name]\n                if r1.status == TestStatus.PASSED and r2.status == TestStatus.FAILED:\n                    regressions.append(name)\n                elif r1.status == TestStatus.FAILED and r2.status == TestStatus.PASSED:\n                    improvements.append(name)\n            else:\n                new_tests.append(name)\n\n        for name in results1:\n            if name not in results2:\n                removed_tests.append(name)\n\n        return {\n            'regressions': regressions,\n            'improvements': improvements,\n            'new_tests': new_tests,\n            'removed_tests': removed_tests\n        }\n\n    def export_junit_xml(self, run_id: str) -> str:\n        \"\"\"Export test run as JUnit XML.\"\"\"\n        results = self.find_by_run(run_id)\n\n        # Group by suite\n        suites: Dict[str, List[TestResult]] = {}\n        for result in results:\n            if result.suite_name not in suites:\n                suites[result.suite_name] = []\n            suites[result.suite_name].append(result)\n\n        # Build XML\n        testsuites = ET.Element('testsuites')\n\n        for suite_name, suite_results in suites.items():\n            testsuite = ET.SubElement(testsuites, 'testsuite')\n            testsuite.set('name', suite_name)\n            testsuite.set('tests', str(len(suite_results)))\n            testsuite.set('failures', str(sum(1 for r in suite_results if r.status == TestStatus.FAILED)))\n            testsuite.set('errors', str(sum(1 for r in suite_results if r.status == TestStatus.ERROR)))\n            testsuite.set('skipped', str(sum(1 for r in suite_results if r.status == TestStatus.SKIPPED)))\n\n            total_time = sum(r.duration_ms or 0 for r in suite_results) / 1000\n            testsuite.set('time', f'{total_time:.3f}')\n\n            for result in suite_results:\n                testcase = ET.SubElement(testsuite, 'testcase')\n                testcase.set('name', result.test_name)\n                testcase.set('classname', suite_name)\n                if result.duration_ms:\n                    testcase.set('time', f'{result.duration_ms / 1000:.3f}')\n\n                if result.status == TestStatus.FAILED:\n                    failure = ET.SubElement(testcase, 'failure')\n                    if result.error_message:\n                        failure.set('message', result.error_message)\n                elif result.status == TestStatus.ERROR:\n                    error = ET.SubElement(testcase, 'error')\n                    if result.error_message:\n                        error.set('message', result.error_message)\n                elif result.status == TestStatus.SKIPPED:\n                    ET.SubElement(testcase, 'skipped')\n\n        return ET.tostring(testsuites, encoding='unicode', xml_declaration=True)\n```\n\n### 10. Settings Repository\n\nSettings repository with defaults and validation.\n\n```python\nfrom typing import Any, Dict, Optional, List\nimport json\nimport yaml\n\nclass SettingsRepository(BaseRepository[Setting]):\n    \"\"\"Repository for settings operations.\"\"\"\n\n    DEFAULTS = {\n        'server.port': 8443,\n        'server.timeout': 60,\n        'dashboard.port': 8080,\n        'dashboard.enabled': True,\n        'metrics.port': 9090,\n        'metrics.enabled': True,\n        'retention.logs_days': 30,\n        'retention.sessions_days': 90,\n    }\n\n    def __init__(self, session: Session):\n        super().__init__(session, Setting)\n\n    def get_value(self, key: str, default: Any = None) -> Any:\n        \"\"\"Get setting value with default.\"\"\"\n        setting = self.get_by_id(key)\n        if setting and setting.value is not None:\n            return setting.value\n        return default if default is not None else self.DEFAULTS.get(key)\n\n    def set_value(self, key: str, value: Any,\n                  description: str = None,\n                  category: str = 'general') -> Setting:\n        \"\"\"Set setting value.\"\"\"\n        setting = self.get_by_id(key)\n        if setting:\n            setting.value = value\n            if description:\n                setting.description = description\n            if category:\n                setting.category = category\n            self._session.flush()\n        else:\n            setting = Setting(\n                key=key,\n                value=value,\n                description=description,\n                category=category\n            )\n            self.create(setting)\n        return setting\n\n    def get_by_category(self, category: str) -> Dict[str, Any]:\n        \"\"\"Get all settings in category.\"\"\"\n        settings = self._session.query(Setting).filter(\n            Setting.category == category\n        ).all()\n        return {s.key: s.value for s in settings}\n\n    def get_all_settings(self) -> Dict[str, Any]:\n        \"\"\"Get all settings as dictionary.\"\"\"\n        settings = self.get_all()\n        result = dict(self.DEFAULTS)  # Start with defaults\n        for setting in settings:\n            result[setting.key] = setting.value\n        return result\n\n    def export_yaml(self) -> str:\n        \"\"\"Export settings as YAML.\"\"\"\n        settings = self.get_all_settings()\n        return yaml.dump(settings, default_flow_style=False)\n\n    def import_yaml(self, yaml_str: str) -> int:\n        \"\"\"Import settings from YAML.\"\"\"\n        data = yaml.safe_load(yaml_str)\n        count = 0\n        for key, value in data.items():\n            self.set_value(key, value)\n            count += 1\n        return count\n\n    def reset_to_defaults(self, category: str = None) -> int:\n        \"\"\"Reset settings to defaults.\"\"\"\n        if category:\n            query = self._session.query(Setting).filter(\n                Setting.category == category\n            )\n        else:\n            query = self._session.query(Setting)\n\n        count = query.delete()\n        return count\n```\n\n### 11. Event Emitter Integration\n\nEvent emission for data changes.\n\n```python\nfrom typing import Callable, Dict, List, Any\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport threading\n\n@dataclass\nclass DatabaseEvent:\n    \"\"\"Database event data.\"\"\"\n    event_type: str\n    entity_type: str\n    entity_id: Any\n    timestamp: str\n    data: Dict[str, Any]\n\n\nclass DatabaseEventEmitter:\n    \"\"\"Event emitter for database changes.\"\"\"\n\n    def __init__(self):\n        self._handlers: Dict[str, List[Callable]] = {}\n        self._lock = threading.Lock()\n\n    def on(self, event_type: str, handler: Callable[[DatabaseEvent], None]) -> None:\n        \"\"\"Register event handler.\"\"\"\n        with self._lock:\n            if event_type not in self._handlers:\n                self._handlers[event_type] = []\n            self._handlers[event_type].append(handler)\n\n    def off(self, event_type: str, handler: Callable = None) -> None:\n        \"\"\"Remove event handler.\"\"\"\n        with self._lock:\n            if event_type in self._handlers:\n                if handler:\n                    self._handlers[event_type].remove(handler)\n                else:\n                    del self._handlers[event_type]\n\n    def emit(self, event_type: str, entity_type: str,\n             entity_id: Any, data: Dict[str, Any] = None) -> None:\n        \"\"\"Emit database event.\"\"\"\n        event = DatabaseEvent(\n            event_type=event_type,\n            entity_type=entity_type,\n            entity_id=entity_id,\n            timestamp=datetime.utcnow().isoformat(),\n            data=data or {}\n        )\n\n        with self._lock:\n            handlers = list(self._handlers.get(event_type, []))\n            handlers += list(self._handlers.get('*', []))\n\n        for handler in handlers:\n            try:\n                handler(event)\n            except Exception:\n                pass  # Don't let handler errors break the flow\n```\n\n### 12. Data Export/Import\n\nExport and import functionality.\n\n```python\nfrom typing import Dict, Any, List, Optional\nfrom pathlib import Path\nimport json\nimport yaml\nfrom datetime import datetime\n\nclass DataExporter:\n    \"\"\"Export database data.\"\"\"\n\n    def __init__(self, uow: UnitOfWork):\n        self._uow = uow\n\n    def export_all(self, format: str = 'json') -> str:\n        \"\"\"Export all data.\"\"\"\n        data = {\n            'exported_at': datetime.utcnow().isoformat(),\n            'devices': self._export_devices(),\n            'card_profiles': self._export_cards(),\n            'sessions': self._export_sessions(),\n            'settings': self._export_settings()\n        }\n\n        if format == 'yaml':\n            return yaml.dump(data, default_flow_style=False)\n        return json.dumps(data, indent=2, default=str)\n\n    def export_selective(self, tables: List[str], format: str = 'json') -> str:\n        \"\"\"Export specific tables.\"\"\"\n        data = {'exported_at': datetime.utcnow().isoformat()}\n\n        if 'devices' in tables:\n            data['devices'] = self._export_devices()\n        if 'card_profiles' in tables:\n            data['card_profiles'] = self._export_cards()\n        if 'sessions' in tables:\n            data['sessions'] = self._export_sessions()\n        if 'settings' in tables:\n            data['settings'] = self._export_settings()\n\n        if format == 'yaml':\n            return yaml.dump(data, default_flow_style=False)\n        return json.dumps(data, indent=2, default=str)\n\n    def _export_devices(self) -> List[dict]:\n        \"\"\"Export devices.\"\"\"\n        with self._uow:\n            devices = self._uow.devices.get_all()\n            return [self._device_to_dict(d) for d in devices]\n\n    def _export_cards(self) -> List[dict]:\n        \"\"\"Export card profiles (without keys).\"\"\"\n        with self._uow:\n            cards = self._uow.cards.get_all()\n            return [self._uow.cards.export_profile(c.iccid, include_key=False)\n                    for c in cards]\n\n    def _export_sessions(self) -> List[dict]:\n        \"\"\"Export sessions.\"\"\"\n        with self._uow:\n            sessions = self._uow.sessions.get_all(limit=1000)\n            return [self._session_to_dict(s) for s in sessions]\n\n    def _export_settings(self) -> Dict[str, Any]:\n        \"\"\"Export settings.\"\"\"\n        with self._uow:\n            return self._uow.settings.get_all_settings()\n\n    def _device_to_dict(self, device: Device) -> dict:\n        \"\"\"Convert device to dictionary.\"\"\"\n        return {\n            'id': device.id,\n            'name': device.name,\n            'device_type': device.device_type.value,\n            'manufacturer': device.manufacturer,\n            'model': device.model,\n            'imei': device.imei,\n            'imsi': device.imsi,\n            'iccid': device.iccid,\n            'connection_settings': device.connection_settings,\n            'notes': device.notes\n        }\n\n    def _session_to_dict(self, session: OTASession) -> dict:\n        \"\"\"Convert session to dictionary.\"\"\"\n        return {\n            'id': session.id,\n            'device_id': session.device_id,\n            'card_iccid': session.card_iccid,\n            'session_type': session.session_type,\n            'status': session.status.value,\n            'started_at': session.started_at.isoformat() if session.started_at else None,\n            'ended_at': session.ended_at.isoformat() if session.ended_at else None,\n            'duration_ms': session.duration_ms,\n            'tls_cipher_suite': session.tls_cipher_suite\n        }\n\n\nclass DataImporter:\n    \"\"\"Import database data.\"\"\"\n\n    def __init__(self, uow: UnitOfWork):\n        self._uow = uow\n\n    def import_data(self, data_str: str, format: str = 'json',\n                   conflict_mode: str = 'skip') -> Dict[str, int]:\n        \"\"\"Import data from string.\"\"\"\n        if format == 'yaml':\n            data = yaml.safe_load(data_str)\n        else:\n            data = json.loads(data_str)\n\n        results = {\n            'devices_created': 0,\n            'devices_updated': 0,\n            'devices_skipped': 0,\n            'cards_created': 0,\n            'cards_updated': 0,\n            'cards_skipped': 0,\n            'settings_updated': 0\n        }\n\n        with self._uow:\n            if 'devices' in data:\n                self._import_devices(data['devices'], conflict_mode, results)\n            if 'card_profiles' in data:\n                self._import_cards(data['card_profiles'], conflict_mode, results)\n            if 'settings' in data:\n                self._import_settings(data['settings'], results)\n\n            self._uow.commit()\n\n        return results\n\n    def _import_devices(self, devices: List[dict],\n                       conflict_mode: str, results: dict) -> None:\n        \"\"\"Import devices.\"\"\"\n        for device_data in devices:\n            existing = self._uow.devices.get_by_id(device_data['id'])\n\n            if existing:\n                if conflict_mode == 'skip':\n                    results['devices_skipped'] += 1\n                elif conflict_mode == 'overwrite':\n                    self._update_device(existing, device_data)\n                    results['devices_updated'] += 1\n            else:\n                self._create_device(device_data)\n                results['devices_created'] += 1\n\n    def _import_cards(self, cards: List[dict],\n                     conflict_mode: str, results: dict) -> None:\n        \"\"\"Import card profiles.\"\"\"\n        for card_data in cards:\n            existing = self._uow.cards.get_by_id(card_data['iccid'])\n\n            if existing:\n                if conflict_mode == 'skip':\n                    results['cards_skipped'] += 1\n                elif conflict_mode == 'overwrite':\n                    self._update_card(existing, card_data)\n                    results['cards_updated'] += 1\n            else:\n                self._create_card(card_data)\n                results['cards_created'] += 1\n\n    def _import_settings(self, settings: Dict[str, Any], results: dict) -> None:\n        \"\"\"Import settings.\"\"\"\n        for key, value in settings.items():\n            self._uow.settings.set_value(key, value)\n            results['settings_updated'] += 1\n\n    def _create_device(self, data: dict) -> None:\n        \"\"\"Create device from data.\"\"\"\n        device = Device(\n            id=data['id'],\n            name=data.get('name'),\n            device_type=DeviceType(data['device_type']),\n            manufacturer=data.get('manufacturer'),\n            model=data.get('model'),\n            imei=data.get('imei'),\n            imsi=data.get('imsi'),\n            iccid=data.get('iccid'),\n            connection_settings=data.get('connection_settings'),\n            notes=data.get('notes')\n        )\n        self._uow.devices.create(device)\n\n    def _update_device(self, device: Device, data: dict) -> None:\n        \"\"\"Update device from data.\"\"\"\n        device.name = data.get('name', device.name)\n        device.manufacturer = data.get('manufacturer', device.manufacturer)\n        device.model = data.get('model', device.model)\n        device.connection_settings = data.get('connection_settings', device.connection_settings)\n        device.notes = data.get('notes', device.notes)\n\n    def _create_card(self, data: dict) -> None:\n        \"\"\"Create card profile from data.\"\"\"\n        profile = CardProfile(\n            iccid=data['iccid'],\n            imsi=data.get('imsi'),\n            card_type=data.get('card_type', 'UICC'),\n            atr=data.get('atr'),\n            psk_identity=data.get('psk_identity'),\n            admin_url=data.get('admin_url'),\n            trigger_config=data.get('trigger_config'),\n            bip_config=data.get('bip_config'),\n            notes=data.get('notes')\n        )\n        self._uow.cards.create(profile)\n\n    def _update_card(self, profile: CardProfile, data: dict) -> None:\n        \"\"\"Update card profile from data.\"\"\"\n        profile.imsi = data.get('imsi', profile.imsi)\n        profile.atr = data.get('atr', profile.atr)\n        profile.psk_identity = data.get('psk_identity', profile.psk_identity)\n        profile.admin_url = data.get('admin_url', profile.admin_url)\n        profile.trigger_config = data.get('trigger_config', profile.trigger_config)\n        profile.bip_config = data.get('bip_config', profile.bip_config)\n        profile.notes = data.get('notes', profile.notes)\n```\n\n## CLI Design\n\n### Command Structure\n\n```\ncardlink-db\n├── init                    # Initialize database\n│   └── --force            # Drop existing tables first\n├── migrate                 # Run migrations\n│   ├── --revision <rev>   # Migrate to specific revision\n│   └── --dry-run          # Show SQL without executing\n├── status                  # Show database status\n│   └── --verbose          # Include table details\n├── export                  # Export data\n│   ├── --format <fmt>     # json or yaml\n│   ├── --tables <list>    # Comma-separated table names\n│   └── --output <file>    # Output file path\n├── import                  # Import data\n│   ├── --format <fmt>     # json or yaml\n│   ├── --conflict <mode>  # skip, overwrite, merge\n│   └── <file>             # Input file\n├── purge                   # Delete old data\n│   ├── --older-than <days># Retention period\n│   └── --tables <list>    # Tables to purge\n└── stats                   # Show statistics\n    └── --json             # JSON output\n```\n\n## Error Handling\n\n```python\nclass DatabaseError(Exception):\n    \"\"\"Base database exception.\"\"\"\n    pass\n\nclass ConnectionError(DatabaseError):\n    \"\"\"Connection failed.\"\"\"\n    pass\n\nclass MigrationError(DatabaseError):\n    \"\"\"Migration failed.\"\"\"\n    pass\n\nclass IntegrityError(DatabaseError):\n    \"\"\"Data integrity violation.\"\"\"\n    pass\n\nclass NotFoundError(DatabaseError):\n    \"\"\"Entity not found.\"\"\"\n    pass\n```\n\n## Dependencies\n\n### Required Packages\n\n```\nsqlalchemy>=2.0.0          # ORM\nalembic>=1.12.0            # Migrations\ncryptography>=41.0.0       # Key encryption\npyyaml>=6.0                # YAML export/import\n```\n\n### Database Drivers\n\n```\n# SQLite - built into Python\n# MySQL\nmysqlclient>=2.0.0         # or PyMySQL\n\n# PostgreSQL\npsycopg2-binary>=2.9.0     # or asyncpg for async\n```\n",
  "fileStats": {
    "size": 67448,
    "lines": 1870,
    "lastModified": "2025-11-25T11:53:20.374Z"
  },
  "comments": []
}