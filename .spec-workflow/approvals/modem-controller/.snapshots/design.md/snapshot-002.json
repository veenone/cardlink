{
  "id": "snapshot_1764069919452_uwec0fg6a",
  "approvalId": "approval_1764069834157_cyyrjzpmy",
  "approvalTitle": "Modem Controller Design Document",
  "version": 2,
  "timestamp": "2025-11-25T11:25:19.452Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document: Modem Controller\n\n## Technical Approach\n\n### Overview\n\nThe Modem Controller is implemented as a Python module that interfaces with IoT cellular modems via serial/USB communication. It provides device management, AT command execution, BIP event monitoring via URCs, and optional QXDM diagnostic integration through a layered architecture.\n\n### Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                            Modem Controller                                  │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                                                                              │\n│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐         │\n│  │   CLI Entry     │───▶│ ModemController │───▶│  EventEmitter   │         │\n│  │   (Click)       │    │   (Main Class)  │    │  (Pub/Sub)      │         │\n│  └─────────────────┘    └────────┬────────┘    └─────────────────┘         │\n│                                  │                                          │\n│              ┌───────────────────┼───────────────────┐                     │\n│              │                   │                   │                     │\n│              ▼                   ▼                   ▼                     │\n│   ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐             │\n│   │  ModemManager   │ │   ATInterface   │ │   BIPMonitor    │             │\n│   │  (Discovery)    │ │  (AT Commands)  │ │  (URC Monitor)  │             │\n│   └────────┬────────┘ └────────┬────────┘ └────────┬────────┘             │\n│            │                   │                   │                       │\n│            │                   │                   │                       │\n│            ▼                   ▼                   ▼                       │\n│   ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐             │\n│   │   ModemInfo     │ │   SMSTrigger    │ │   URCParser     │             │\n│   │  (Profiling)    │ │  (PDU Encode)   │ │  (Event Parse)  │             │\n│   └─────────────────┘ └─────────────────┘ └─────────────────┘             │\n│                                                                              │\n│   ┌─────────────────┐ ┌─────────────────────────────────────────────────┐   │\n│   │  QXDMInterface  │ │              SerialClient                        │   │\n│   │  (Diagnostics)  │ │         (Low-level Serial I/O)                   │   │\n│   └─────────────────┘ └─────────────────────────────────────────────────┘   │\n│                                                                              │\n└─────────────────────────────────────────────────────────────────────────────┘\n                                      │\n                    ┌─────────────────┴─────────────────┐\n                    ▼                                   ▼\n          ┌─────────────────┐                 ┌─────────────────┐\n          │   AT Port       │                 │   DM Port       │\n          │ (Serial/USB)    │                 │ (QXDM Diag)     │\n          └─────────────────┘                 └─────────────────┘\n                    │                                   │\n                    └─────────────────┬─────────────────┘\n                                      ▼\n                            ┌─────────────────┐\n                            │   IoT Modem     │\n                            │ (Quectel, etc.) │\n                            └─────────────────┘\n```\n\n### Key Design Decisions\n\n1. **Serial Port Communication**: Use pyserial for cross-platform serial communication with configurable baud rate and timeouts.\n\n2. **Async AT Command Processing**: Use asyncio with serial port for non-blocking command/response handling.\n\n3. **URC-Based Monitoring**: Monitor Unsolicited Result Codes (URCs) in separate read thread for real-time BIP event detection.\n\n4. **Modem Vendor Abstraction**: Abstract interface to support multiple modem vendors with vendor-specific subclasses.\n\n5. **QXDM Optional Integration**: QXDM diagnostics as optional feature that degrades gracefully when unavailable.\n\n6. **Port Discovery**: Automatic serial port scanning with modem identification via ATI command.\n\n## Component Design\n\n### Component 1: ModemController\n\n**Purpose**: Main orchestrator class that coordinates all modem control operations.\n\n**Interface**:\n```python\nclass ModemController:\n    \"\"\"Main modem controller for IoT cellular modem management.\"\"\"\n\n    def __init__(\n        self,\n        event_emitter: Optional[EventEmitter] = None\n    ):\n        \"\"\"Initialize controller with optional event emitter.\"\"\"\n\n    async def discover_modems(self) -> List[ModemInfo]:\n        \"\"\"Scan for connected modems on serial ports.\"\"\"\n\n    def get_modem(self, port: str) -> Optional[Modem]:\n        \"\"\"Get modem instance by port name.\"\"\"\n\n    async def refresh_modems(self) -> None:\n        \"\"\"Refresh modem list and status.\"\"\"\n\n    def on_modem_connected(self, callback: Callable) -> None:\n        \"\"\"Register callback for modem connection events.\"\"\"\n\n    def on_modem_disconnected(self, callback: Callable) -> None:\n        \"\"\"Register callback for modem disconnection events.\"\"\"\n```\n\n**Key Behaviors**:\n- Maintains registry of discovered modems\n- Polls for modem changes every 5 seconds\n- Creates Modem instances for each detected modem\n- Emits modem_connected/disconnected events\n\n### Component 2: SerialClient\n\n**Purpose**: Low-level serial port communication wrapper.\n\n**Interface**:\n```python\nclass SerialClient:\n    \"\"\"Low-level serial port communication.\"\"\"\n\n    def __init__(\n        self,\n        port: str,\n        baudrate: int = 115200,\n        timeout: float = 1.0\n    ):\n        \"\"\"Initialize serial connection.\"\"\"\n\n    async def open(self) -> None:\n        \"\"\"Open serial port.\"\"\"\n\n    async def close(self) -> None:\n        \"\"\"Close serial port.\"\"\"\n\n    async def write(self, data: bytes) -> int:\n        \"\"\"Write data to serial port.\"\"\"\n\n    async def read(self, size: int = 1024) -> bytes:\n        \"\"\"Read data from serial port.\"\"\"\n\n    async def read_line(self, timeout: float = None) -> str:\n        \"\"\"Read line from serial port.\"\"\"\n\n    async def read_until(self, terminator: bytes, timeout: float = None) -> bytes:\n        \"\"\"Read until terminator or timeout.\"\"\"\n\n    def is_open(self) -> bool:\n        \"\"\"Check if port is open.\"\"\"\n\n    @staticmethod\n    def list_ports() -> List[PortInfo]:\n        \"\"\"List available serial ports.\"\"\"\n```\n\n**Port Discovery**:\n```python\n@dataclass\nclass PortInfo:\n    port: str           # /dev/ttyUSB0 or COM3\n    description: str    # \"Quectel USB AT Port\"\n    hwid: str          # USB VID:PID\n    manufacturer: str   # \"Quectel\"\n    product: str       # \"EG25-G\"\n    serial_number: str  # Module serial\n\n# Quectel USB VID:PID mappings\nQUECTEL_USB_IDS = {\n    '2c7c:0125': 'EC25',\n    '2c7c:0121': 'EC21',\n    '2c7c:0195': 'EG25-G',\n    '2c7c:0800': 'RG500Q',\n    '2c7c:0801': 'RG520N',\n}\n```\n\n**Key Behaviors**:\n- Uses pyserial for cross-platform support\n- Configurable baud rate (default 115200)\n- Timeout handling for read operations\n- Thread-safe for concurrent reads/writes\n\n### Component 3: ModemManager\n\n**Purpose**: Manages modem discovery, connection monitoring, and modem lifecycle.\n\n**Interface**:\n```python\nclass ModemManager:\n    \"\"\"Manages modem discovery and connection state.\"\"\"\n\n    def __init__(\n        self,\n        event_emitter: EventEmitter,\n        poll_interval: float = 5.0\n    ):\n        \"\"\"Initialize with polling interval.\"\"\"\n\n    async def start_monitoring(self) -> None:\n        \"\"\"Start background modem monitoring.\"\"\"\n\n    async def stop_monitoring(self) -> None:\n        \"\"\"Stop background modem monitoring.\"\"\"\n\n    async def scan_modems(self) -> List[ModemInfo]:\n        \"\"\"Perform one-time modem scan.\"\"\"\n\n    def get_connected_modems(self) -> List[str]:\n        \"\"\"Get list of connected modem ports.\"\"\"\n\n    def is_modem_connected(self, port: str) -> bool:\n        \"\"\"Check if specific modem is connected.\"\"\"\n```\n\n**Modem Detection Logic**:\n```python\nasync def _identify_modem(self, port: str) -> Optional[ModemInfo]:\n    \"\"\"Identify modem on serial port.\"\"\"\n    try:\n        serial = SerialClient(port, baudrate=115200, timeout=2.0)\n        await serial.open()\n\n        # Send ATI for identification\n        await serial.write(b'ATI\\r\\n')\n        response = await serial.read_until(b'OK', timeout=2.0)\n\n        # Parse response to determine vendor/model\n        if b'Quectel' in response:\n            return self._parse_quectel_info(response, port)\n        elif b'Sierra' in response:\n            return self._parse_sierra_info(response, port)\n\n        return None\n    finally:\n        await serial.close()\n```\n\n### Component 4: ModemInfo\n\n**Purpose**: Retrieves and stores comprehensive modem and UICC information.\n\n**Interface**:\n```python\nclass ModemInfo:\n    \"\"\"Modem information retrieval and profiling.\"\"\"\n\n    def __init__(self, at_interface: ATInterface):\n        \"\"\"Initialize with AT interface.\"\"\"\n\n    async def get_modem_info(self) -> ModemProfile:\n        \"\"\"Get modem hardware/firmware information.\"\"\"\n\n    async def get_sim_info(self) -> SIMProfile:\n        \"\"\"Get UICC/SIM card information.\"\"\"\n\n    async def get_network_info(self) -> NetworkProfile:\n        \"\"\"Get network registration and signal information.\"\"\"\n\n    async def get_full_profile(self) -> FullModemProfile:\n        \"\"\"Get complete modem profile.\"\"\"\n\n    async def refresh(self) -> None:\n        \"\"\"Force refresh all cached information.\"\"\"\n\n    def export_json(self) -> str:\n        \"\"\"Export profile as JSON string.\"\"\"\n```\n\n**AT Commands for Information**:\n```python\nMODEM_INFO_COMMANDS = {\n    'manufacturer': 'AT+CGMI',\n    'model': 'AT+CGMM',\n    'firmware': 'AT+CGMR',\n    'imei': 'AT+CGSN',\n}\n\nSIM_INFO_COMMANDS = {\n    'status': 'AT+CPIN?',\n    'iccid': 'AT+QCCID',      # Quectel specific\n    'iccid_alt': 'AT+CCID',   # Standard\n    'imsi': 'AT+CIMI',\n    'msisdn': 'AT+CNUM',\n}\n\nNETWORK_INFO_COMMANDS = {\n    'registration': 'AT+CREG?',\n    'eps_registration': 'AT+CEREG?',\n    'operator': 'AT+COPS?',\n    'signal_csq': 'AT+CSQ',\n    'signal_qcsq': 'AT+QCSQ',  # Quectel detailed\n    'pdp_context': 'AT+CGDCONT?',\n}\n```\n\n**Data Models**:\n```python\n@dataclass\nclass ModemProfile:\n    manufacturer: str\n    model: str\n    firmware_version: str\n    imei: str\n    serial_number: str\n    module_type: str\n    supported_bands: List[str]\n\n@dataclass\nclass SIMProfile:\n    status: str  # READY, SIM PIN, etc.\n    iccid: Optional[str]\n    imsi: Optional[str]\n    msisdn: Optional[str]\n    spn: Optional[str]\n    mcc: Optional[str]\n    mnc: Optional[str]\n\n@dataclass\nclass NetworkProfile:\n    registration_status: str\n    operator_name: str\n    network_type: str  # LTE, NR5G\n    rssi: int\n    rsrp: Optional[int]\n    rsrq: Optional[int]\n    sinr: Optional[int]\n    cell_id: str\n    tac: str\n    apn: str\n\n@dataclass\nclass FullModemProfile:\n    modem: ModemProfile\n    sim: SIMProfile\n    network: NetworkProfile\n    timestamp: datetime\n```\n\n### Component 5: ATInterface\n\n**Purpose**: Sends AT commands and parses responses with URC handling.\n\n**Interface**:\n```python\nclass ATInterface:\n    \"\"\"AT command interface for modem communication.\"\"\"\n\n    def __init__(\n        self,\n        serial_client: SerialClient,\n        urc_callback: Optional[Callable] = None\n    ):\n        \"\"\"Initialize with serial client and optional URC handler.\"\"\"\n\n    async def send_command(\n        self,\n        command: str,\n        timeout: float = 5.0,\n        expect_response: bool = True\n    ) -> ATResponse:\n        \"\"\"Send AT command and return response.\"\"\"\n\n    async def send_raw(self, data: bytes) -> None:\n        \"\"\"Send raw bytes (for PDU mode).\"\"\"\n\n    def register_urc_handler(\n        self,\n        pattern: str,\n        callback: Callable\n    ) -> None:\n        \"\"\"Register handler for specific URC pattern.\"\"\"\n\n    async def start_urc_monitoring(self) -> None:\n        \"\"\"Start background URC monitoring.\"\"\"\n\n    async def stop_urc_monitoring(self) -> None:\n        \"\"\"Stop background URC monitoring.\"\"\"\n```\n\n**AT Response Parsing**:\n```python\n@dataclass\nclass ATResponse:\n    command: str\n    raw_response: str\n    result: ATResult  # OK, ERROR, CME_ERROR, CMS_ERROR\n    data: List[str]   # Parsed response lines\n    error_code: Optional[int]\n    success: bool\n\nclass ATResult(Enum):\n    OK = \"OK\"\n    ERROR = \"ERROR\"\n    CME_ERROR = \"+CME ERROR\"\n    CMS_ERROR = \"+CMS ERROR\"\n    TIMEOUT = \"TIMEOUT\"\n    NO_RESPONSE = \"NO_RESPONSE\"\n```\n\n**URC Handling**:\n```python\n# Common URCs to monitor\nURC_PATTERNS = {\n    r'\\+CREG: (\\d)': 'network_registration',\n    r'\\+CEREG: (\\d)': 'eps_registration',\n    r'\\+CPIN: (.+)': 'sim_status',\n    r'\\+QSTK: (.+)': 'stk_event',      # Quectel STK\n    r'\\+STKPCI: (.+)': 'stk_proactive', # STK proactive command\n    r'\\+QIND: (.+)': 'indication',     # Quectel indication\n}\n```\n\n**Key Behaviors**:\n- Command/response synchronization with timeout\n- Background thread for URC monitoring\n- Queue URCs for processing\n- Support for multi-line responses\n\n### Component 6: BIPMonitor\n\n**Purpose**: Monitors for BIP (Bearer Independent Protocol) events via URCs and STK notifications.\n\n**Interface**:\n```python\nclass BIPMonitor:\n    \"\"\"Monitors BIP events via modem URCs.\"\"\"\n\n    def __init__(\n        self,\n        at_interface: ATInterface,\n        event_emitter: EventEmitter\n    ):\n        \"\"\"Initialize monitor with AT interface.\"\"\"\n\n    async def start(self) -> None:\n        \"\"\"Start BIP event monitoring.\"\"\"\n\n    async def stop(self) -> None:\n        \"\"\"Stop BIP event monitoring.\"\"\"\n\n    def is_running(self) -> bool:\n        \"\"\"Check if monitor is active.\"\"\"\n\n    async def enable_stk_notifications(self) -> None:\n        \"\"\"Enable STK/USAT URC notifications.\"\"\"\n```\n\n**STK Command Detection**:\n```python\n# Proactive commands related to BIP\nSTK_BIP_COMMANDS = {\n    0x40: 'OPEN_CHANNEL',\n    0x41: 'CLOSE_CHANNEL',\n    0x42: 'RECEIVE_DATA',\n    0x43: 'SEND_DATA',\n    0x44: 'GET_CHANNEL_STATUS',\n}\n\nasync def _process_stk_event(self, urc_data: str) -> Optional[BIPEvent]:\n    \"\"\"Parse STK URC into BIP event.\"\"\"\n    # Parse proactive command TLV\n    # Extract command type and parameters\n    # Return BIPEvent if BIP-related\n```\n\n**Key Behaviors**:\n- Enable STK notifications via AT+QSTK=1 (Quectel)\n- Parse proactive command TLVs\n- Emit BIP events to EventEmitter\n- Correlate with OTA sessions\n\n### Component 7: URCParser\n\n**Purpose**: Parses Unsolicited Result Codes into structured events.\n\n**Interface**:\n```python\nclass URCParser:\n    \"\"\"Parses modem URCs into structured events.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize parser with pattern matchers.\"\"\"\n\n    def parse(self, line: str) -> Optional[URCEvent]:\n        \"\"\"Parse URC line into event.\"\"\"\n\n    def is_urc(self, line: str) -> bool:\n        \"\"\"Check if line is a URC.\"\"\"\n\n    def register_pattern(\n        self,\n        pattern: str,\n        event_type: str,\n        parser: Callable\n    ) -> None:\n        \"\"\"Register custom URC pattern.\"\"\"\n```\n\n**URC Event Types**:\n```python\n@dataclass\nclass URCEvent:\n    type: str\n    timestamp: datetime\n    raw_line: str\n    data: Dict[str, Any]\n\n# Example events\n# +CREG: 1,1 -> URCEvent(type='network_registration', data={'stat': 1, 'lac': None})\n# +QSTK: \"D0...\"  -> URCEvent(type='stk_proactive', data={'pdu': 'D0...'})\n```\n\n### Component 8: SMSTrigger\n\n**Purpose**: Sends SMS-PP trigger messages in PDU mode.\n\n**Interface**:\n```python\nclass SMSTrigger:\n    \"\"\"SMS-PP OTA trigger message sender.\"\"\"\n\n    def __init__(self, at_interface: ATInterface):\n        \"\"\"Initialize with AT interface.\"\"\"\n\n    async def send_trigger(\n        self,\n        template: TriggerTemplate,\n        params: Dict[str, Any]\n    ) -> TriggerResult:\n        \"\"\"Send OTA trigger using template.\"\"\"\n\n    async def send_raw_pdu(self, pdu: bytes) -> TriggerResult:\n        \"\"\"Send raw PDU bytes as SMS-PP.\"\"\"\n\n    async def configure_pdu_mode(self) -> bool:\n        \"\"\"Set modem to PDU mode (AT+CMGF=0).\"\"\"\n```\n\n**PDU Mode SMS Sending**:\n```python\nasync def _send_pdu(self, pdu: bytes) -> TriggerResult:\n    \"\"\"Send SMS via AT+CMGS in PDU mode.\"\"\"\n    # Ensure PDU mode\n    await self.at_interface.send_command('AT+CMGF=0')\n\n    # Calculate TPDU length (excluding SMSC)\n    tpdu_length = len(pdu) - 1 - pdu[0]  # Subtract SMSC length\n\n    # Send AT+CMGS=<length>\n    response = await self.at_interface.send_command(\n        f'AT+CMGS={tpdu_length}',\n        timeout=5.0,\n        expect_response=False\n    )\n\n    # Wait for > prompt\n    # Send PDU bytes + Ctrl+Z\n    await self.at_interface.send_raw(pdu.hex().encode() + b'\\x1a')\n\n    # Wait for +CMGS: <mr> response\n    result = await self.at_interface.read_response(timeout=60.0)\n\n    return TriggerResult(\n        success='+CMGS:' in result,\n        message_reference=self._parse_mr(result),\n        raw_response=result\n    )\n```\n\n### Component 9: QXDMInterface\n\n**Purpose**: Optional QXDM diagnostic integration for Qualcomm-based modems.\n\n**Interface**:\n```python\nclass QXDMInterface:\n    \"\"\"QXDM diagnostic interface for Qualcomm modems.\"\"\"\n\n    def __init__(self, dm_port: str):\n        \"\"\"Initialize with diagnostic port.\"\"\"\n\n    async def connect(self) -> bool:\n        \"\"\"Connect to DM port.\"\"\"\n\n    async def disconnect(self) -> None:\n        \"\"\"Disconnect from DM port.\"\"\"\n\n    def is_available(self) -> bool:\n        \"\"\"Check if QXDM interface is available.\"\"\"\n\n    async def start_logging(self, log_codes: List[int]) -> None:\n        \"\"\"Start diagnostic logging for specified codes.\"\"\"\n\n    async def stop_logging(self) -> None:\n        \"\"\"Stop diagnostic logging.\"\"\"\n\n    async def export_log(self, filepath: str, format: str = 'isf') -> None:\n        \"\"\"Export captured logs to file.\"\"\"\n\n    def get_dm_port(self) -> Optional[str]:\n        \"\"\"Find DM port for connected modem.\"\"\"\n```\n\n**Diagnostic Port Detection**:\n```python\n# Quectel modems expose multiple USB interfaces:\n# - AT port (ttyUSB2 typically)\n# - DM port (ttyUSB0 typically)\n# - NMEA port (ttyUSB1 typically)\n\nQUECTEL_PORT_FUNCTIONS = {\n    0: 'DM',     # Diagnostic/QXDM\n    1: 'NMEA',   # GPS NMEA\n    2: 'AT',     # AT commands\n    3: 'PPP',    # Data/PPP\n}\n```\n\n**Key Behaviors**:\n- Auto-detect DM port from USB interface mapping\n- Support common QXDM log codes for OTA/BIP debugging\n- Export to ISF/DLF format for QXDM analysis\n- Graceful degradation when QXDM unavailable\n\n### Component 10: NetworkManager\n\n**Purpose**: Manages modem network configuration and data connection.\n\n**Interface**:\n```python\nclass NetworkManager:\n    \"\"\"Manages modem network configuration.\"\"\"\n\n    def __init__(self, at_interface: ATInterface):\n        \"\"\"Initialize with AT interface.\"\"\"\n\n    async def configure_apn(\n        self,\n        apn: str,\n        username: str = '',\n        password: str = '',\n        auth_type: str = 'NONE'\n    ) -> bool:\n        \"\"\"Configure APN settings.\"\"\"\n\n    async def activate_pdp(self, cid: int = 1) -> bool:\n        \"\"\"Activate PDP context.\"\"\"\n\n    async def deactivate_pdp(self, cid: int = 1) -> bool:\n        \"\"\"Deactivate PDP context.\"\"\"\n\n    async def get_ip_address(self, cid: int = 1) -> Optional[str]:\n        \"\"\"Get assigned IP address.\"\"\"\n\n    async def check_registration(self) -> RegistrationStatus:\n        \"\"\"Check network registration status.\"\"\"\n\n    async def ping(self, host: str, count: int = 4) -> PingResult:\n        \"\"\"Ping host via modem (AT+QPING for Quectel).\"\"\"\n```\n\n**AT Commands**:\n```python\n# PDP Context configuration\n# AT+CGDCONT=<cid>,\"IP\",\"<apn>\"\n# AT+CGAUTH=<cid>,<auth_type>,\"<password>\",\"<username>\"\n\n# PDP activation\n# AT+CGACT=1,<cid>\n\n# IP address query\n# AT+CGPADDR=<cid>\n\n# Quectel data activation\n# AT+QIACT=<cid>\n\n# Quectel ping\n# AT+QPING=<cid>,\"<host>\"[,<timeout>][,<count>]\n```\n\n### Component 11: QuectelModem\n\n**Purpose**: Quectel-specific modem implementation with vendor commands.\n\n**Interface**:\n```python\nclass QuectelModem(Modem):\n    \"\"\"Quectel-specific modem implementation.\"\"\"\n\n    async def get_detailed_signal(self) -> QuectelSignalInfo:\n        \"\"\"Get detailed signal info via AT+QCSQ.\"\"\"\n\n    async def configure_bands(self, bands: List[str]) -> bool:\n        \"\"\"Configure LTE bands via AT+QCFG='band'.\"\"\"\n\n    async def enable_stk(self) -> bool:\n        \"\"\"Enable STK via AT+QSTK=1.\"\"\"\n\n    async def get_qeng_info(self) -> QEngInfo:\n        \"\"\"Get engineering mode info via AT+QENG.\"\"\"\n\n    async def send_ussd(self, code: str) -> str:\n        \"\"\"Send USSD via AT+CUSD.\"\"\"\n```\n\n**Quectel-Specific AT Commands**:\n```python\nQUECTEL_COMMANDS = {\n    'signal_detail': 'AT+QCSQ',      # Detailed signal: RSSI, RSRP, SINR, RSRQ\n    'engineering': 'AT+QENG=\"servingcell\"',  # Serving cell info\n    'band_config': 'AT+QCFG=\"band\"', # Band configuration\n    'stk_enable': 'AT+QSTK=1',       # Enable STK URCs\n    'network_scan': 'AT+QSCAN=3',    # Network scan\n    'gps_enable': 'AT+QGPS=1',       # Enable GPS\n}\n```\n\n## File Structure\n\n```\nsrc/cardlink/modem/\n├── __init__.py                 # Public API exports\n├── controller.py               # ModemController main class\n├── serial_client.py            # SerialClient low-level serial I/O\n├── modem_manager.py            # ModemManager discovery/monitoring\n├── modem_info.py               # ModemInfo profiling\n├── at_interface.py             # ATInterface command handling\n├── urc_parser.py               # URCParser event parsing\n├── bip_monitor.py              # BIPMonitor URC-based monitoring\n├── sms_trigger.py              # SMSTrigger PDU encoding/sending\n├── network_manager.py          # NetworkManager network config\n├── qxdm_interface.py           # QXDMInterface diagnostics\n├── profile_manager.py          # ProfileManager profile storage\n├── vendors/                    # Vendor-specific implementations\n│   ├── __init__.py\n│   ├── base.py                 # Base Modem class\n│   ├── quectel.py              # QuectelModem\n│   └── sierra.py               # SierraModem (future)\n├── models.py                   # Data models and enums\n└── exceptions.py               # Custom exceptions\n```\n\n## Dependencies\n\n### Internal Dependencies\n\n| Module | Depends On |\n|--------|------------|\n| `controller` | `modem_manager`, `at_interface`, `bip_monitor`, `network_manager` |\n| `modem_manager` | `serial_client`, `modem_info`, `vendors` |\n| `at_interface` | `serial_client`, `urc_parser` |\n| `bip_monitor` | `at_interface`, `urc_parser` |\n| `sms_trigger` | `at_interface` |\n| `qxdm_interface` | `serial_client` |\n\n### External Dependencies\n\n| Library | Purpose |\n|---------|---------|\n| `pyserial` | Serial port communication |\n| `asyncio` | Async I/O |\n| `click` | CLI framework |\n\n## Error Handling\n\n### Error Types\n\n```python\nclass ModemControllerError(Exception):\n    \"\"\"Base exception for modem controller errors.\"\"\"\n\nclass ModemNotFoundError(ModemControllerError):\n    \"\"\"Specified modem not connected.\"\"\"\n\nclass SerialPortError(ModemControllerError):\n    \"\"\"Serial port communication error.\"\"\"\n\nclass ATCommandError(ModemControllerError):\n    \"\"\"AT command execution failed.\"\"\"\n\nclass ATTimeoutError(ModemControllerError):\n    \"\"\"AT command timed out.\"\"\"\n\nclass CMEError(ATCommandError):\n    \"\"\"+CME ERROR from modem.\"\"\"\n    def __init__(self, code: int, message: str):\n        self.code = code\n        self.message = message\n\nclass CMSError(ATCommandError):\n    \"\"\"+CMS ERROR from modem.\"\"\"\n    def __init__(self, code: int, message: str):\n        self.code = code\n        self.message = message\n```\n\n### CME/CMS Error Codes\n\n```python\nCME_ERRORS = {\n    0: 'Phone failure',\n    3: 'Operation not allowed',\n    4: 'Operation not supported',\n    5: 'PH-SIM PIN required',\n    10: 'SIM not inserted',\n    11: 'SIM PIN required',\n    12: 'SIM PUK required',\n    13: 'SIM failure',\n    16: 'Incorrect password',\n    30: 'No network service',\n    100: 'Unknown error',\n}\n\nCMS_ERRORS = {\n    301: 'SMS service reserved',\n    302: 'Operation not allowed',\n    303: 'Operation not supported',\n    304: 'Invalid PDU mode parameter',\n    305: 'Invalid text mode parameter',\n    321: 'Invalid memory index',\n    322: 'SIM memory full',\n}\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n| Component | Test Focus |\n|-----------|------------|\n| `SerialClient` | Port listing, read/write operations |\n| `ATInterface` | Command formatting, response parsing, URC detection |\n| `URCParser` | Pattern matching, event extraction |\n| `SMSTrigger` | PDU encoding |\n| `ModemInfo` | AT response parsing |\n\n### Integration Tests\n\n| Test | Description |\n|------|-------------|\n| Modem discovery | Detect real connected modem |\n| AT command | Send ATI and parse response |\n| SIM status | Query AT+CPIN? |\n| Network registration | Monitor AT+CREG |\n\n### Mock Strategy\n\n```python\nclass MockSerialClient(SerialClient):\n    \"\"\"Mock serial client for testing.\"\"\"\n\n    def __init__(self, responses: Dict[str, str]):\n        self.responses = responses\n        self.written_data = []\n\n    async def write(self, data: bytes) -> int:\n        self.written_data.append(data)\n        return len(data)\n\n    async def read_until(self, terminator: bytes, timeout: float = None) -> bytes:\n        command = self.written_data[-1].decode().strip()\n        return self.responses.get(command, b'ERROR\\r\\n')\n```\n\n## Performance Considerations\n\n1. **Serial Buffer Management**: Read serial data in chunks, buffer until complete response.\n\n2. **URC Thread**: Dedicated thread for URC monitoring to avoid blocking main AT interface.\n\n3. **Command Queuing**: Queue AT commands to prevent concurrent access to serial port.\n\n4. **Timeout Tuning**: Different timeouts for different operations (quick: 2s, network: 180s).\n\n5. **Port Caching**: Cache port information to avoid repeated scanning.\n\n## Security Considerations\n\n1. **No PIN Storage**: Never persist SIM PIN codes.\n\n2. **Sensitive Data Logging**: Mask IMSI, IMEI in logs (show only last 4 digits).\n\n3. **Port Permissions**: Document required permissions for serial port access (dialout group on Linux).\n\n4. **QXDM Access**: Document QXDM license requirements for Qualcomm diagnostics.\n",
  "fileStats": {
    "size": 28409,
    "lines": 884,
    "lastModified": "2025-11-25T11:23:48.074Z"
  },
  "comments": []
}